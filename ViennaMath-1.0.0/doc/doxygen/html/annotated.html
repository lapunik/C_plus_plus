<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ViennaMath: Data Structures</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Data Structures</h1>  </div>
</div>
<div class="contents">
Here are the data structures with brief descriptions:<table>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1add.html">add&lt; LHS, RHS, b1, b2 &gt;</a></td><td class="indexvalue">Returns the type of adding two expressions together. Default case: both types are runtime expressions </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1add_3_01_l_h_s_00_01_r_h_s_00_01true_00_01true_01_4.html">add&lt; LHS, RHS, true, true &gt;</a></td><td class="indexvalue">Metafunction for adding two compiletime expressions </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1analytic__integration__not__supported__exception.html">analytic_integration_not_supported_exception</a></td><td class="indexvalue">Analytic integration at runtime not supported </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1callback__if__castable.html">callback_if_castable&lt; CastToType &gt;</a></td><td class="indexvalue">A helper class which calls a provided functor if the supplied expression pointer can be cast to the target type </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1cartesian.html">cartesian&lt; dim &gt;</a></td><td class="indexvalue">A tag representing a Cartesian coordinate system in arbitrary dimensions </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1coefficient.html">coefficient&lt; FactorType, ExpressionType &gt;</a></td><td class="indexvalue">User metafunction for extracting the coefficient of a variable or sub-expression from an expression </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1coefficient__impl.html">coefficient_impl&lt; FactorType, ExpressionType &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1coefficient__impl_3_01_factor_type_00_01ct__binary__00060ebabb5871f056afcf83e4e13555.html">coefficient_impl&lt; FactorType, ct_binary_expr&lt; FactorType, op_mult&lt; NumericT &gt;, FactorType &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1coefficient__impl_3_01_factor_type_00_01ct__binary__f8c9fd9bce46a7cb1ff311afb1101414.html">coefficient_impl&lt; FactorType, ct_binary_expr&lt; FactorType, op_mult&lt; NumericT &gt;, RHS &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1coefficient__impl_3_01_factor_type_00_01ct__binary__ecd8256a6cf790dd5455a6166613f60d.html">coefficient_impl&lt; FactorType, ct_binary_expr&lt; LHS, op_div&lt; NumericT &gt;, RHS &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1coefficient__impl_3_01_factor_type_00_01ct__binary__73e228e9360af1de1f27ae5eae9a8a59.html">coefficient_impl&lt; FactorType, ct_binary_expr&lt; LHS, op_minus&lt; NumericT &gt;, RHS &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1coefficient__impl_3_01_factor_type_00_01ct__binary__59526efdc82c4dc782a639d0570ab61c.html">coefficient_impl&lt; FactorType, ct_binary_expr&lt; LHS, op_mult&lt; NumericT &gt;, FactorType &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1coefficient__impl_3_01_factor_type_00_01ct__binary__a52119e55f613f0748673053ead15eb1.html">coefficient_impl&lt; FactorType, ct_binary_expr&lt; LHS, op_mult&lt; NumericT &gt;, RHS &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1coefficient__impl_3_01_factor_type_00_01ct__binary__a7047a159b5e0a09b32f0de2e7ad0b1d.html">coefficient_impl&lt; FactorType, ct_binary_expr&lt; LHS, op_plus&lt; NumericT &gt;, RHS &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1coefficient__impl_3_01_factor_type_00_01_factor_type_01_4.html">coefficient_impl&lt; FactorType, FactorType &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr&lt; LHS, OP, RHS &gt;</a></td><td class="indexvalue">A compile time expression consisting of two operands and one operation (taking two arguments) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1ct__constant.html">ct_constant&lt; value_ &gt;</a></td><td class="indexvalue">A compiletime constant </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation&lt; LHS, RHS &gt;</a></td><td class="indexvalue">A compile time equation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol&lt; Tag &gt;</a></td><td class="indexvalue">A function symbol. Can be used for unknown functions, test functions, etc. Cannot be evaluated, but substituted with an evaluable object </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1ct__index.html">ct_index&lt; i &gt;</a></td><td class="indexvalue">Compiletime respresentation of a vector access index </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval&lt; LHS, RHS &gt;</a></td><td class="indexvalue">A compile time interval </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr&lt; LHS, OP &gt;</a></td><td class="indexvalue">Defines a unary expression f(e), where f is function and 'e' is an expression </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1ct__variable.html">ct_variable&lt; id &gt;</a></td><td class="indexvalue">Representation of a mathematical variable. If the supplied argument is some vector type, a traits system accesses the id-th component </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1ct__vector__1.html">ct_vector_1&lt; T0 &gt;</a></td><td class="indexvalue">Compiletime vector with one element </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1ct__vector__2.html">ct_vector_2&lt; T0, T1 &gt;</a></td><td class="indexvalue">Compiletime vector with one element </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1ct__vector__3.html">ct_vector_3&lt; T0, T1, T2 &gt;</a></td><td class="indexvalue">Compiletime vector with one element </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1diff.html">diff&lt; ARG, VAR &gt;</a></td><td class="indexvalue">Returns the type of the expression after differentiation of 'ARG' with respect to the variable 'VAR' </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1diff_3_01ct__binary__expr_3_01_l_h_s_00_01op__div_3_01default_59039fed55e880846bd895a748cc6c13.html">diff&lt; ct_binary_expr&lt; LHS, op_div&lt; default_numeric_type &gt;, RHS &gt;, ct_variable&lt; id &gt; &gt;</a></td><td class="indexvalue">Specialization implementing the rule (u/v)' = (u'*v - u*v') / v^2 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1diff_3_01ct__binary__expr_3_01_l_h_s_00_01op__minus_3_01defaule9db20293bc6e480bd470a0c3f79d2ff.html">diff&lt; ct_binary_expr&lt; LHS, op_minus&lt; default_numeric_type &gt;, RHS &gt;, ct_variable&lt; id &gt; &gt;</a></td><td class="indexvalue">Specialization implementing the rule (u - v)' = u' - v' </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1diff_3_01ct__binary__expr_3_01_l_h_s_00_01op__mult_3_01default16fc32b6df86c99bbf5b44a9c99a24a3.html">diff&lt; ct_binary_expr&lt; LHS, op_mult&lt; default_numeric_type &gt;, RHS &gt;, ct_variable&lt; id &gt; &gt;</a></td><td class="indexvalue">Specialization implementing the rule (u * v)' = u'*v + u*v' </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1diff_3_01ct__binary__expr_3_01_l_h_s_00_01op__plus_3_01default35c76917fe8543b1779c6cfc35509a9b.html">diff&lt; ct_binary_expr&lt; LHS, op_plus&lt; default_numeric_type &gt;, RHS &gt;, ct_variable&lt; id &gt; &gt;</a></td><td class="indexvalue">Specialization implementing the rule (u + v)' = u' + v' </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1diff_3_01ct__constant_3_01value_01_4_00_01ct__variable_3_01id_01_4_01_4.html">diff&lt; ct_constant&lt; value &gt;, ct_variable&lt; id &gt; &gt;</a></td><td class="indexvalue">Specialization: The derivative of a constant is zero </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1diff_3_01ct__variable_3_01id_01_4_00_01ct__variable_3_01id_01_4_01_4.html">diff&lt; ct_variable&lt; id &gt;, ct_variable&lt; id &gt; &gt;</a></td><td class="indexvalue">Specialization for (d x) / (d x) = 1 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1diff_3_01ct__variable_3_01other__id_01_4_00_01ct__variable_3_01id_01_4_01_4.html">diff&lt; ct_variable&lt; other_id &gt;, ct_variable&lt; id &gt; &gt;</a></td><td class="indexvalue">Specialization of (d x_i) / (d x_j) for i != j </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1div.html">div&lt; LHS, RHS, b1, b2 &gt;</a></td><td class="indexvalue">Returns the type when dividing two expressions. Default case: both types are runtime expressions </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1div_3_01_l_h_s_00_01_r_h_s_00_01true_00_01true_01_4.html">div&lt; LHS, RHS, true, true &gt;</a></td><td class="indexvalue">Metafunction for dividing two compiletime expressions </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1drop__dependent__terms.html">drop_dependent_terms&lt; FactorType, ExpressionType &gt;</a></td><td class="indexvalue">Interface metafunction for removing dependent terms from an expression </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1enable__if.html">enable_if&lt; b, T &gt;</a></td><td class="indexvalue">Simple enable-if variant that uses the SFINAE pattern </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1enable__if_3_01false_00_01_t_01_4.html">enable_if&lt; false, T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1eval.html">eval&lt; ExpressionType, VectorType, ct_evaluable &gt;</a></td><td class="indexvalue">Main metafunction for compiletime evaluation </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1eval_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h_s_01_db90f7eb7bd2b096d615bcfeb42df358.html">eval&lt; ct_binary_expr&lt; LHS, OP, RHS &gt;, VectorType, true &gt;</a></td><td class="indexvalue">Specialization for the evaluation of a binary expression at compile time </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1eval_3_01ct__constant_3_01value_01_4_00_01_vector_type_00_01true_01_4.html">eval&lt; ct_constant&lt; value &gt;, VectorType, true &gt;</a></td><td class="indexvalue">Specialization for the evaluation of a constant at compile time </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1eval_3_01ct__variable_3_010_01_4_00_01ct__constant_3_01value_01_4_00_01true_01_4.html">eval&lt; ct_variable&lt; 0 &gt;, ct_constant&lt; value &gt;, true &gt;</a></td><td class="indexvalue">Specialization for the evaluation of a variable at compile time </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1eval_3_01ct__variable_3_01id_01_4_00_01_vector_type_00_01true_01_4.html">eval&lt; ct_variable&lt; id &gt;, VectorType, true &gt;</a></td><td class="indexvalue">Specialization for the evaluation of a variable at compile time </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1expand.html">expand&lt; T &gt;</a></td><td class="indexvalue">The main metafunction for expanding a compiletime expression </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1expand_3_01ct__binary__expr_3_01_l_h_s_00_01op__div_3_01_numeric_t_01_4_00_01_r_h_s_01_4_01_4.html">expand&lt; ct_binary_expr&lt; LHS, op_div&lt; NumericT &gt;, RHS &gt; &gt;</a></td><td class="indexvalue">Specialization for a binary expression (division): Expand numerator and denominator of fractional expressions separately </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1expand_3_01ct__binary__expr_3_01_l_h_s_00_01op__minus_3_01_numeea9524141404cff40a860ffa58b8ffa.html">expand&lt; ct_binary_expr&lt; LHS, op_minus&lt; NumericT &gt;, RHS &gt; &gt;</a></td><td class="indexvalue">Specialization for a binary expression (subtraction): Expand both operands </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1expand_3_01ct__binary__expr_3_01_l_h_s_00_01op__mult_3_01_nume1224f84215ff3684f7a545ed2488e312.html">expand&lt; ct_binary_expr&lt; LHS, op_mult&lt; NumericT &gt;, RHS &gt; &gt;</a></td><td class="indexvalue">Specialization for a binary expression (product): Redirect to helper metafunction </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1expand_3_01ct__binary__expr_3_01_l_h_s_00_01op__plus_3_01_numebb7e1f9fd45ab94339a2f0531c5f695c.html">expand&lt; ct_binary_expr&lt; LHS, op_plus&lt; NumericT &gt;, RHS &gt; &gt;</a></td><td class="indexvalue">Specialization for a binary expression (addition): Expand both addends </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1expand_3_01ct__constant_3_01value_01_4_01_4.html">expand&lt; ct_constant&lt; value &gt; &gt;</a></td><td class="indexvalue">A constant cannot be further expanded, thus it is returned unmodified </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1expand_3_01ct__function__symbol_3_01_t_a_g_01_4_01_4.html">expand&lt; ct_function_symbol&lt; TAG &gt; &gt;</a></td><td class="indexvalue">A function symbol cannot be further expanded, thus it is returned unmodified </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1expand_3_01ct__unary__expr_3_01_l_h_s_00_01_o_p_01_4_01_4.html">expand&lt; ct_unary_expr&lt; LHS, OP &gt; &gt;</a></td><td class="indexvalue">A unary expression is not expanded further, since the operator is typically nonlinear </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1expand_3_01ct__variable_3_01id_01_4_01_4.html">expand&lt; ct_variable&lt; id &gt; &gt;</a></td><td class="indexvalue">A variable cannot be further expanded, thus it is returned unmodified </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1expand__product.html">expand_product&lt; LHS, RHS, lhs_expandable, rhs_expandable &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1expand__product_3_01_l_h_s_00_01_r_h_s_00_01false_00_01true_01_4.html">expand_product&lt; LHS, RHS, false, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1expand__product_3_01_l_h_s_00_01_r_h_s_00_01true_00_01false_01_4.html">expand_product&lt; LHS, RHS, true, false &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1expand__product_3_01_l_h_s_00_01_r_h_s_00_01true_00_01true_01_4.html">expand_product&lt; LHS, RHS, true, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1expand__with__factor.html">expand_with_factor&lt; ExpressionType, FactorType, needs_expansion &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1expand__with__factor_3_01ct__binary__expr_3_01_l_h_s67ea1cf1c1c8386454880c93f47a4d96.html">expand_with_factor&lt; ct_binary_expr&lt; LHS, op_div&lt; NumericT &gt;, RHS &gt;, FactorType, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1expand__with__factor_3_01ct__binary__expr_3_01_l_h_s1d9f60ef8ef35c9a3521acf5d5ac4dad.html">expand_with_factor&lt; ct_binary_expr&lt; LHS, op_minus&lt; NumericT &gt;, RHS &gt;, FactorType, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1expand__with__factor_3_01ct__binary__expr_3_01_l_h_se1e42fec13b2a1f234ae94d0cb5f2613.html">expand_with_factor&lt; ct_binary_expr&lt; LHS, op_mult&lt; NumericT &gt;, RHS &gt;, FactorType, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1expand__with__factor_3_01ct__binary__expr_3_01_l_h_sd486895472ed00baf306433d69759f97.html">expand_with_factor&lt; ct_binary_expr&lt; LHS, op_plus&lt; NumericT &gt;, RHS &gt;, FactorType, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1expression__not__differentiable__exception.html">expression_not_differentiable_exception</a></td><td class="indexvalue">An exception which is thrown if an expression should be differentiated, but at least one of the leaves in the expression tree cannot be differentiated (e.g. is a function symbol) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1expression__not__evaluable__exception.html">expression_not_evaluable_exception</a></td><td class="indexvalue">An exception which is thrown if an expression should be evaluated to a floating point number using <a class="el" href="namespaceviennamath.html#adc71b02c9631188dfd54d127ab2fabd4" title="Main user function for the evaluation of a compiletime expression at compiletime.">eval()</a>, but at least one of the leaves in the expression tree cannot be evaluated (e.g. is a function symbol) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1expression__not__unwrappable__exception.html">expression_not_unwrappable_exception</a></td><td class="indexvalue">An exception which is thrown if an expression should be reduced to a floating point number using unwrap(), but at least one of the leaves in the expression tree is not a constant (e.g. is a variable) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1expression__traits.html">expression_traits&lt; T &gt;</a></td><td class="indexvalue">A traits system for expressions. For now provides a deduction of the const reference type only </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1expression__traits_3_01ct__constant_3_01value_01_4_01_4.html">expression_traits&lt; ct_constant&lt; value &gt; &gt;</a></td><td class="indexvalue">Specialization of the expression traits system: A compiletime constant can be copied with no extra cost, thus no need for const reference </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1expression__traits_3_01rt__constant_3_01_t_00_01_interface_type_01_4_01_4.html">expression_traits&lt; rt_constant&lt; T, InterfaceType &gt; &gt;</a></td><td class="indexvalue">Specialization of the expression traits system: A runtime constant does not allow for copying, otherwise one runs into problems with tempories </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1extract__factor__from__product.html">extract_factor_from_product&lt; FactorType, LHS, NumericT, RHS, lhs_has_factor, rhs_has_factor &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1extract__factor__from__product_3_01_factor_type_00_01b2afabdc3a89d8350fba32686388259.html">extract_factor_from_product&lt; FactorType, LHS, NumericT, RHS, false, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1extract__factor__from__product_3_01_factor_type_00_0a5b2fcb70e199fcd21bfa1a3b7223107.html">extract_factor_from_product&lt; FactorType, LHS, NumericT, RHS, true, false &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1extract__factor__from__product_3_01_factor_type_00_04b6dc70cf9258b92228035e87ce1eca5.html">extract_factor_from_product&lt; FactorType, LHS, NumericT, RHS, true, true &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1gcd.html">gcd&lt; a, b &gt;</a></td><td class="indexvalue">Helper metafunction for computing the greatest common divisor of two numbers </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1gcd_3_010_00_010_01_4.html">gcd&lt; 0, 0 &gt;</a></td><td class="indexvalue">Specialization forcing a compile time error, since the greatest common divisor of 0 and 0 is not defined </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1gcd_3_01a_00_010_01_4.html">gcd&lt; a, 0 &gt;</a></td><td class="indexvalue">Specialization for the computation of the greatest common divisor of a and 0, which is a </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1has__factor.html">has_factor&lt; FactorType, ExpressionType &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1has__factor_3_01_factor_type_00_01ct__binary__expr_34c49138b3ff8b0b133bc9fb70932ba63.html">has_factor&lt; FactorType, ct_binary_expr&lt; LHS, op_div&lt; NumericT &gt;, RHS &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1has__factor_3_01_factor_type_00_01ct__binary__expr_373c86696d63bfdf84390fea872516535.html">has_factor&lt; FactorType, ct_binary_expr&lt; LHS, op_minus&lt; NumericT &gt;, RHS &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1has__factor_3_01_factor_type_00_01ct__binary__expr_3825b3ed9c7c8d93f639ecc64c09e5b14.html">has_factor&lt; FactorType, ct_binary_expr&lt; LHS, op_mult&lt; NumericT &gt;, RHS &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1has__factor_3_01_factor_type_00_01ct__binary__expr_3f76e5dc0d7bc9a8715853a3c18e9838d.html">has_factor&lt; FactorType, ct_binary_expr&lt; LHS, op_plus&lt; NumericT &gt;, RHS &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1has__factor_3_01_factor_type_00_01_factor_type_01_4.html">has_factor&lt; FactorType, FactorType &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1has__plus__or__minus.html">has_plus_or_minus&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1has__plus__or__minus_3_01ct__binary__expr_3_01_l_h_s8d63a9d7343552c919560f07e62a40b0.html">has_plus_or_minus&lt; ct_binary_expr&lt; LHS, op_div&lt; NumericT &gt;, RHS &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1has__plus__or__minus_3_01ct__binary__expr_3_01_l_h_sfc531f2dfb79b5be5c09aab138ae014f.html">has_plus_or_minus&lt; ct_binary_expr&lt; LHS, op_minus&lt; NumericT &gt;, RHS &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1has__plus__or__minus_3_01ct__binary__expr_3_01_l_h_s4a957ed1b2903e4662aea58aa24de4e7.html">has_plus_or_minus&lt; ct_binary_expr&lt; LHS, op_mult&lt; NumericT &gt;, RHS &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1has__plus__or__minus_3_01ct__binary__expr_3_01_l_h_se049d668c4d125271fbd1ffd704f6d80.html">has_plus_or_minus&lt; ct_binary_expr&lt; LHS, op_plus&lt; NumericT &gt;, RHS &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1detail_1_1integral__substitution__functor.html">integral_substitution_functor&lt; InterfaceType &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1integrate.html">integrate&lt; LowerBound, UpperBound, IntegrandType, VariableType &gt;</a></td><td class="indexvalue">The main metafunction for the integration of a compiletime expression </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1integrate_3_01_lower_bound_00_01_upper_bound_00_01ct__binary__c4222aa27a8f7b17f5140ee52a07e1c4.html">integrate&lt; LowerBound, UpperBound, ct_binary_expr&lt; LHS, OP, RHS &gt;, VariableType &gt;</a></td><td class="indexvalue">Specialization for the integration of a compiletime binary expression </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1integrate_3_01_lower_bound_00_01_upper_bound_00_01ct__constant02b081c2f089a06c586708c4b92c875a.html">integrate&lt; LowerBound, UpperBound, ct_constant&lt; value &gt;, VariableType &gt;</a></td><td class="indexvalue">Specialization for the integration of a compile time constant. Forwards the integration to the worker metafunction integrate_impl </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1integrate_3_01_lower_bound_00_01_upper_bound_00_01ct__function139534101d1214c10af6b9693c6cbd3f.html">integrate&lt; LowerBound, UpperBound, ct_function_symbol&lt; TAG &gt;, VariableType &gt;</a></td><td class="indexvalue">Specialization for the integration of a compiletime function symbol. This is a user error, since a function symbol should have been replaced already by another expression. Thus, a compile time error is forced </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1integrate_3_01_lower_bound_00_01_upper_bound_00_01ct__unary__efaee4c5ac766cbccfefa4176f3dee264.html">integrate&lt; LowerBound, UpperBound, ct_unary_expr&lt; LHS, OP &gt;, VariableType &gt;</a></td><td class="indexvalue">Specialization for the integration of a compiletime unary expression. Not supported at the moment, thus a compile time error is forced </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1integrate_3_01_lower_bound_00_01_upper_bound_00_01ct__variablea894654a1d801866c901af7b510b4946.html">integrate&lt; LowerBound, UpperBound, ct_variable&lt; id &gt;, VariableType &gt;</a></td><td class="indexvalue">Specialization for the integration of a compile time variable. Forwards the integration to the worker metafunction integrate_impl </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1integrate__impl.html">integrate_impl&lt; LowerBound, UpperBound, IntegrandType, VariableType &gt;</a></td><td class="indexvalue">The worker metafunction for compile time integration. Each specialization represents an integration rule </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1integrate__impl_3_01_lower_bound_00_01_upper_bound_0e96255a448fa0031cee33b5e784ea331.html">integrate_impl&lt; LowerBound, UpperBound, ct_binary_expr&lt; LHS, op_div&lt; NumericT &gt;, RHS &gt;, VariableType &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1integrate__impl_3_01_lower_bound_00_01_upper_bound_0aaf3e55bee1d5dd5822913fc3ce2cda6.html">integrate_impl&lt; LowerBound, UpperBound, ct_binary_expr&lt; LHS, op_minus&lt; NumericT &gt;, RHS &gt;, VariableType &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1integrate__impl_3_01_lower_bound_00_01_upper_bound_0c182a11f3caf84a6b5c176d1a0fb3685.html">integrate_impl&lt; LowerBound, UpperBound, ct_binary_expr&lt; LHS, op_mult&lt; NumericT &gt;, RHS &gt;, VariableType &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1integrate__impl_3_01_lower_bound_00_01_upper_bound_03b5409207416a85f4fe528af02a2dd8a.html">integrate_impl&lt; LowerBound, UpperBound, ct_binary_expr&lt; LHS, op_plus&lt; NumericT &gt;, RHS &gt;, VariableType &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1integrate__impl_3_01_lower_bound_00_01_upper_bound_05ec5acd5e2fca455a3b9a2906a23dd97.html">integrate_impl&lt; LowerBound, UpperBound, ct_constant&lt; value &gt;, VariableType &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1integrate__impl_3_01_lower_bound_00_01_upper_bound_0c77698fd676a42870bc92df38e3484f8.html">integrate_impl&lt; LowerBound, UpperBound, ct_function_symbol&lt; TAG &gt;, VariableType &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1integrate__impl_3_01_lower_bound_00_01_upper_bound_03be8dc0d56d6f8c9e708e0b648cdc1ba.html">integrate_impl&lt; LowerBound, UpperBound, ct_unary_expr&lt; LHS, OP &gt;, VariableType &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1integrate__impl_3_01_lower_bound_00_01_upper_bound_014648cc0208df2334078cb4736cf3c49.html">integrate_impl&lt; LowerBound, UpperBound, ct_variable&lt; id &gt;, VariableType &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1integrate__monomial.html">integrate_monomial&lt; VariableType, exponent &gt;</a></td><td class="indexvalue">Metafunction for the integration of a monomial consisting of a single variable </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1integrate__monomial_3_01_variable_type_00_010_01_4.html">integrate_monomial&lt; VariableType, 0 &gt;</a></td><td class="indexvalue">Specialization for the integration of a constant: Return the variable directly </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1integration__without__integral__exception.html">integration_without_integral_exception</a></td><td class="indexvalue">Exception for the case that an integration over expressions without integral is attempted </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1interface.html">interface&lt; LHS, RHS &gt;</a></td><td class="indexvalue">A metafunction deducing the ViennaMath runtime expression interface (base class) from two types. The first argument has priority </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1interface_3_01default__numeric__type_00_01rt__binary__expr_3_01_t_01_4_01_4.html">interface&lt; default_numeric_type, rt_binary_expr&lt; T &gt; &gt;</a></td><td class="indexvalue">Specialization of the runtime expression interface deduction for a ViennaMath runtime binary expression </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1interface_3_01default__numeric__type_00_01rt__variable_3_01_t_01_4_01_4.html">interface&lt; default_numeric_type, rt_variable&lt; T &gt; &gt;</a></td><td class="indexvalue">Specialization of the runtime expression interface deduction for a ViennaMath runtime variable </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1interface_3_01double_00_01rt__expr_3_01_t_01_4_01_4.html">interface&lt; double, rt_expr&lt; T &gt; &gt;</a></td><td class="indexvalue">Specialization of the runtime expression interface deduction for the ViennaMath runtime expression wrapper </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1interface_3_01rt__binary__expr_3_01_t_01_4_00_01_r_h_s_01_4.html">interface&lt; rt_binary_expr&lt; T &gt;, RHS &gt;</a></td><td class="indexvalue">Specialization of the runtime expression interface deduction for a ViennaMath runtime binary expression </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1interface_3_01rt__constant_3_01_t_00_01_u_01_4_00_01_r_h_s_01_4.html">interface&lt; rt_constant&lt; T, U &gt;, RHS &gt;</a></td><td class="indexvalue">Specialization of the runtime expression interface deduction for a ViennaMath runtime constant </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1interface_3_01rt__expr_3_01_t_01_4_00_01_r_h_s_01_4.html">interface&lt; rt_expr&lt; T &gt;, RHS &gt;</a></td><td class="indexvalue">Specialization of the runtime expression interface deduction for the ViennaMath runtime expression wrapper </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1interface_3_01rt__unary__expr_3_01_t_01_4_00_01_r_h_s_01_4.html">interface&lt; rt_unary_expr&lt; T &gt;, RHS &gt;</a></td><td class="indexvalue">Specialization of the runtime expression interface deduction for a ViennaMath runtime unary expression </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1interface_3_01rt__variable_3_01_t_01_4_00_01_r_h_s_01_4.html">interface&lt; rt_variable&lt; T &gt;, RHS &gt;</a></td><td class="indexvalue">Specialization of the runtime expression interface deduction for a ViennaMath runtime variable </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1is__compiletime.html">is_compiletime&lt; T &gt;</a></td><td class="indexvalue">A metafunction returning a value 'true' if the provided argument is a ViennaMath compiletime expression type. Otherwise, false is returned </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h_s_01_4_01_4.html">is_compiletime&lt; ct_binary_expr&lt; LHS, OP, RHS &gt; &gt;</a></td><td class="indexvalue">Specialization of the metafunction for a ViennaMath compiletime binary expression </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__constant_3_01val_01_4_01_4.html">is_compiletime&lt; ct_constant&lt; val &gt; &gt;</a></td><td class="indexvalue">Specialization of the metafunction for a ViennaMath compiletime constant </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__function__symbol_3_01_t_a_g_01_4_01_4.html">is_compiletime&lt; ct_function_symbol&lt; TAG &gt; &gt;</a></td><td class="indexvalue">Specialization of the metafunction for a ViennaMath compiletime function symbol </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__unary__expr_3_01_l_h_s_00_01_o_p_01_4_01_4.html">is_compiletime&lt; ct_unary_expr&lt; LHS, OP &gt; &gt;</a></td><td class="indexvalue">Specialization of the metafunction for a ViennaMath compiletime unary expression </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__variable_3_01id_01_4_01_4.html">is_compiletime&lt; ct_variable&lt; id &gt; &gt;</a></td><td class="indexvalue">Specialization of the metafunction for a ViennaMath compiletime variable </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1is__ct__evaluable.html">is_ct_evaluable&lt; E &gt;</a></td><td class="indexvalue">Returns nonzero if supplied expression can be evaluated at compile time </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1is__ct__evaluable_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h_s_01_4_01_4.html">is_ct_evaluable&lt; ct_binary_expr&lt; LHS, OP, RHS &gt; &gt;</a></td><td class="indexvalue">Specialization: Determines whether a binary expression is compiletime evaluable by recursively acting on the operands </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1is__ct__evaluable_3_01ct__constant_3_01val_01_4_01_4.html">is_ct_evaluable&lt; ct_constant&lt; val &gt; &gt;</a></td><td class="indexvalue">Specialization: A constant is compiletime evaluable </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1is__ct__evaluable_3_01ct__variable_3_01id_01_4_01_4.html">is_ct_evaluable&lt; ct_variable&lt; id &gt; &gt;</a></td><td class="indexvalue">Specialization: A variable is compiletime evaluable </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1is__ct__vector.html">is_ct_vector&lt; VectorType &gt;</a></td><td class="indexvalue">Returns nonzero if the supplied vector type is a compile-time vector </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1is__ct__vector_3_01ct__vector__1_3_01_t0_01_4_01_4.html">is_ct_vector&lt; ct_vector_1&lt; T0 &gt; &gt;</a></td><td class="indexvalue">Specialization of the helper function for the determination of whether a vector is a compiletime type </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1is__ct__vector_3_01ct__vector__2_3_01_t0_00_01_t1_01_4_01_4.html">is_ct_vector&lt; ct_vector_2&lt; T0, T1 &gt; &gt;</a></td><td class="indexvalue">Specialization of the helper function for the determination of whether a vector is a compiletime type </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1is__ct__vector_3_01ct__vector__3_3_01_t0_00_01_t1_00_01_t2_01_4_01_4.html">is_ct_vector&lt; ct_vector_3&lt; T0, T1, T2 &gt; &gt;</a></td><td class="indexvalue">Specialization of the helper function for the determination of whether a vector is a compiletime type </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath.html">is_viennamath&lt; T &gt;</a></td><td class="indexvalue">A metafunction with value 'true' if the provided argument is a ViennaMath expression type. Otherwise, false is returned </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h_s_01_4_01_4.html">is_viennamath&lt; ct_binary_expr&lt; LHS, OP, RHS &gt; &gt;</a></td><td class="indexvalue">Specialization of the metafunction for a ViennaMath compiletime binary expression </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__constant_3_01val_01_4_01_4.html">is_viennamath&lt; ct_constant&lt; val &gt; &gt;</a></td><td class="indexvalue">Specialization of the metafunction for a ViennaMath compiletime constant </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__function__symbol_3_01_t_a_g_01_4_01_4.html">is_viennamath&lt; ct_function_symbol&lt; TAG &gt; &gt;</a></td><td class="indexvalue">Specialization of the metafunction for a ViennaMath compiletime function symbol </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__unary__expr_3_01_l_h_s_00_01_o_p_01_4_01_4.html">is_viennamath&lt; ct_unary_expr&lt; LHS, OP &gt; &gt;</a></td><td class="indexvalue">Specialization of the metafunction for a ViennaMath compiletime unary expression </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__variable_3_01id_01_4_01_4.html">is_viennamath&lt; ct_variable&lt; id &gt; &gt;</a></td><td class="indexvalue">Specialization of the metafunction for a ViennaMath compiletime variable </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__binary__expr_3_01_interface_type_01_4_01_4.html">is_viennamath&lt; rt_binary_expr&lt; InterfaceType &gt; &gt;</a></td><td class="indexvalue">Specialization of the metafunction for a ViennaMath runtime binary expression </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__constant_3_01_numeric_type_00_01_interface_type_01_4_01_4.html">is_viennamath&lt; rt_constant&lt; NumericType, InterfaceType &gt; &gt;</a></td><td class="indexvalue">Specialization of the metafunction for a ViennaMath runtime constant </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__expr_3_01_interface_type_01_4_01_4.html">is_viennamath&lt; rt_expr&lt; InterfaceType &gt; &gt;</a></td><td class="indexvalue">Specialization of the metafunction for a ViennaMath runtime expression </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__function__symbol_3_01_interface_type_01_4_01_4.html">is_viennamath&lt; rt_function_symbol&lt; InterfaceType &gt; &gt;</a></td><td class="indexvalue">Specialization of the metafunction for a ViennaMath runtime function symbol </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__unary__expr_3_01_interface_type_01_4_01_4.html">is_viennamath&lt; rt_unary_expr&lt; InterfaceType &gt; &gt;</a></td><td class="indexvalue">Specialization of the metafunction for a ViennaMath runtime unary expression </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__variable_3_01_interface_type_01_4_01_4.html">is_viennamath&lt; rt_variable&lt; InterfaceType &gt; &gt;</a></td><td class="indexvalue">Specialization of the metafunction for a ViennaMath runtime variable </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1mult.html">mult&lt; LHS, RHS, b1, b2 &gt;</a></td><td class="indexvalue">Returns the type when multiplying two expressions. Default case: both types are runtime expressions </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1mult_3_01_l_h_s_00_01_r_h_s_00_01true_00_01true_01_4.html">mult&lt; LHS, RHS, true, true &gt;</a></td><td class="indexvalue">Metafunction for multiplying two compiletime expressions </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1no__rhs__provided__exception.html">no_rhs_provided_exception</a></td><td class="indexvalue">An exception which is thrown if no right hand side operand is passed to a binary operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1numeric__type__proxy.html">numeric_type_proxy&lt; NumericT &gt;</a></td><td class="indexvalue">A proxy object which allows for the use of plain default_numeric_type with template operator+, operator-, operator*, operator/ without running into problems with ambiguity. With the proxy object, one additional conversion is required, thus resolving the ambiguity </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1numerical__quadrature__interface.html">numerical_quadrature_interface&lt; InterfaceType &gt;</a></td><td class="indexvalue">The abstract runtime interface for all numerical quadrature rules </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1op__binary.html">op_binary&lt; BinaryOperation, InterfaceType &gt;</a></td><td class="indexvalue">This is the common wrapper class for binary operations </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1op__cos.html">op_cos&lt; NumericT &gt;</a></td><td class="indexvalue">Cosine function: x |--&gt; cos(x) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1op__ct__integral.html">op_ct_integral&lt; IntervalType, integration_variable &gt;</a></td><td class="indexvalue">Integration operator: f |--&gt; \int_I f d x </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1op__div.html">op_div&lt; NumericT &gt;</a></td><td class="indexvalue">Tag for division </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1op__divergence.html">op_divergence&lt; NumericT &gt;</a></td><td class="indexvalue">Divergence operator: f |--&gt; div(f) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1op__exp.html">op_exp&lt; NumericT &gt;</a></td><td class="indexvalue">Exponential mapping: x |--&gt; exp(x) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1op__fabs.html">op_fabs&lt; NumericT &gt;</a></td><td class="indexvalue">Modulus: x |--&gt; |x| </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1op__gradient.html">op_gradient&lt; NumericT &gt;</a></td><td class="indexvalue">Gradient operator: f |--&gt; grad(x) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1op__id.html">op_id&lt; NumericT &gt;</a></td><td class="indexvalue">Identity mapping: x |--&gt; x </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1op__interface.html">op_interface&lt; InterfaceType &gt;</a></td><td class="indexvalue">The abstract runtime interface for all operations (unary and binary) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1op__log.html">op_log&lt; NumericT &gt;</a></td><td class="indexvalue">Natural logarithm function: x |--&gt; ln(x) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1op__log10.html">op_log10&lt; NumericT &gt;</a></td><td class="indexvalue">Logarithm with base 10: x |--&gt; \log_{10}(x) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1op__minus.html">op_minus&lt; NumericT &gt;</a></td><td class="indexvalue">Tag for subtraction </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1op__mult.html">op_mult&lt; NumericT &gt;</a></td><td class="indexvalue">Tag for multiplication </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1op__partial__deriv.html">op_partial_deriv&lt; NumericT &gt;</a></td><td class="indexvalue">Divergence operator: f |--&gt; d f / (d x_i) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1op__plus.html">op_plus&lt; NumericT &gt;</a></td><td class="indexvalue">Tag for addition </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1op__rt__integral.html">op_rt_integral&lt; InterfaceType &gt;</a></td><td class="indexvalue">A unary operation defining an integral over an interval </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1op__rt__symbolic__integral.html">op_rt_symbolic_integral&lt; InterfaceType &gt;</a></td><td class="indexvalue">A unary operation encoding a symbolic interval. Cannot be evaluated and is meant to be replaced by a concrete integration later on </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1op__sin.html">op_sin&lt; NumericT &gt;</a></td><td class="indexvalue">Sine function: x |--&gt; sin(x) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1op__sqrt.html">op_sqrt&lt; NumericT &gt;</a></td><td class="indexvalue">Square root: x |--&gt; \sqrt{x} </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1op__tan.html">op_tan&lt; NumericT &gt;</a></td><td class="indexvalue">Tangent function: x |--&gt; tan(x) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1op__unary.html">op_unary&lt; UnaryOperation, InterfaceType &gt;</a></td><td class="indexvalue">Main class for all unary operations </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1polynomial__degree.html">polynomial_degree&lt; VariableType, ExpressionType &gt;</a></td><td class="indexvalue">Returns the power of ct_variable&lt;id&gt; inside an expression </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1polynomial__degree_3_01_variable_type_00_01ct__binary__expr_3_b20424c975b4dadc767ddf0fc1d6c56e.html">polynomial_degree&lt; VariableType, ct_binary_expr&lt; LHS, op_div&lt; NumericT &gt;, RHS &gt; &gt;</a></td><td class="indexvalue">Specialization for a division: The polynomial degree is given by the difference of the polynomial degree of the numerator and the denominator </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1polynomial__degree_3_01_variable_type_00_01ct__binary__expr_3_fdbaf8c21bf2ae3e8daff8a1f4ebbc70.html">polynomial_degree&lt; VariableType, ct_binary_expr&lt; LHS, op_minus&lt; NumericT &gt;, RHS &gt; &gt;</a></td><td class="indexvalue">Specialization for forcing a compile time error if a difference of expressions is encountered </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1polynomial__degree_3_01_variable_type_00_01ct__binary__expr_3_4297520c494f4bda043f15dd68a7c9c2.html">polynomial_degree&lt; VariableType, ct_binary_expr&lt; LHS, op_mult&lt; NumericT &gt;, RHS &gt; &gt;</a></td><td class="indexvalue">Specialization for a product: The polynomial degree is given by the sum of the polynomial degree of each factor </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1polynomial__degree_3_01_variable_type_00_01ct__binary__expr_3_c3665fc8f61c26fe040a2219edb47c23.html">polynomial_degree&lt; VariableType, ct_binary_expr&lt; LHS, op_plus&lt; NumericT &gt;, RHS &gt; &gt;</a></td><td class="indexvalue">Specialization for forcing a compile time error if a sum of expressions is encountered </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1polynomial__degree_3_01_variable_type_00_01_variable_type_01_4.html">polynomial_degree&lt; VariableType, VariableType &gt;</a></td><td class="indexvalue">Specialization for the power of a single variable, which is known to be 1 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1pow.html">pow&lt; T, exponent &gt;</a></td><td class="indexvalue">Metafunction returning the power of an expression. Tries to balance the generated expression tree </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1pow_3_01_t_00_010_01_4.html">pow&lt; T, 0 &gt;</a></td><td class="indexvalue">Specialization for the zeroth power of an expression </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1pow_3_01_t_00_011_01_4.html">pow&lt; T, 1 &gt;</a></td><td class="indexvalue">Specialization for the first power of an expression </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1pow_3_01_t_00_012_01_4.html">pow&lt; T, 2 &gt;</a></td><td class="indexvalue">Specialization for the square of an expression </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1promote__traits.html">promote_traits&lt; T, OP, U &gt;</a></td><td class="indexvalue">For two numeric types T and U with objects t and u respectively, the result type of t+u is returned. Default case: return the basic numeric type for ViennaMath </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1promote__traits_3_01double_00_01_o_p_00_01float_01_4.html">promote_traits&lt; double, OP, float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1promote__traits_3_01double_00_01_o_p_00_01int_01_4.html">promote_traits&lt; double, OP, int &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1promote__traits_3_01double_00_01_o_p_00_01long_01_4.html">promote_traits&lt; double, OP, long &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1promote__traits_3_01float_00_01_o_p_00_01double_01_4.html">promote_traits&lt; float, OP, double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1promote__traits_3_01float_00_01_o_p_00_01int_01_4.html">promote_traits&lt; float, OP, int &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1promote__traits_3_01float_00_01_o_p_00_01long_01_4.html">promote_traits&lt; float, OP, long &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1promote__traits_3_01int_00_01_o_p_00_01double_01_4.html">promote_traits&lt; int, OP, double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1promote__traits_3_01int_00_01_o_p_00_01float_01_4.html">promote_traits&lt; int, OP, float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1promote__traits_3_01int_00_01op__div_3_01_numeric_type_01_4_00_01long_01_4.html">promote_traits&lt; int, op_div&lt; NumericType &gt;, long &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1promote__traits_3_01long_00_01_o_p_00_01double_01_4.html">promote_traits&lt; long, OP, double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1promote__traits_3_01long_00_01_o_p_00_01float_01_4.html">promote_traits&lt; long, OP, float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1promote__traits_3_01long_00_01op__div_3_01_numeric_type_01_4_00_01int_01_4.html">promote_traits&lt; long, op_div&lt; NumericType &gt;, int &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1promote__traits_3_01long_00_01op__div_3_01_numeric_type_01_4_00_01long_01_4.html">promote_traits&lt; long, op_div&lt; NumericType &gt;, long &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1promote__traits_3_01_t_00_01_o_p_00_01_t_01_4.html">promote_traits&lt; T, OP, T &gt;</a></td><td class="indexvalue">The result type of two operands of the same type is of the same type again (cf. standard C/C++ behavior for integers) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1rhs__provided__for__unary__operation__exception.html">rhs_provided_for_unary_operation_exception</a></td><td class="indexvalue">An exception which is thrown if a right hand side argument is passed to a unary operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr&lt; InterfaceType &gt;</a></td><td class="indexvalue">Runtime representation of a binary expression F(x,y), where F is a function of two argument (e.g. +) and x,y are expressions </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1rt__constant.html">rt_constant&lt; ScalarType, InterfaceType &gt;</a></td><td class="indexvalue">Representation of a constant within the expression setting of ViennaMath </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation&lt; InterfaceType &gt;</a></td><td class="indexvalue">Runtime representation of a equation by a left hand side and a right hand side expresssion </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr&lt; InterfaceType &gt;</a></td><td class="indexvalue">This class represents a smart pointer to all types expressions </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1rt__expression__interface.html">rt_expression_interface&lt; NumericT &gt;</a></td><td class="indexvalue">Abstract interface for all ViennaMath runtime expressions </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1rt__function__symbol.html">rt_function_symbol&lt; InterfaceType &gt;</a></td><td class="indexvalue">A function symbol. Can be used for unknown functions, test functions, etc. Cannot be evaluated, but substituted with an evaluable object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1rt__gauss__quad__1.html">rt_gauss_quad_1&lt; InterfaceType &gt;</a></td><td class="indexvalue">Gauss quadrature rule with first-order accuracy </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval&lt; InterfaceType &gt;</a></td><td class="indexvalue">Represents an interval [a,b] at runtime. Note that the interval boundaries do not need to be constants </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1rt__latex__binary__expr__processor.html">rt_latex_binary_expr_processor&lt; InterfaceType &gt;</a></td><td class="indexvalue">A LaTeX processor responsible for translating binary expressions to LaTeX code </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1rt__latex__constant__processor.html">rt_latex_constant_processor&lt; InterfaceType &gt;</a></td><td class="indexvalue">A LaTeX processor responsible for translating ViennaMath runtime constants to LaTeX code </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1rt__latex__function__symbol__processor.html">rt_latex_function_symbol_processor&lt; InterfaceType &gt;</a></td><td class="indexvalue">A LaTeX processor responsible for translating ViennaMath runtime function symbols to LaTeX code </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1rt__latex__processor__interface.html">rt_latex_processor_interface&lt; InterfaceType &gt;</a></td><td class="indexvalue">The abstract interface for each LaTeX processor module </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1rt__latex__translator.html">rt_latex_translator&lt; InterfaceType &gt;</a></td><td class="indexvalue">The main LaTeX translator class. To be used and manipulated by the ViennaMath library user </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1rt__latex__unary__expr__processor.html">rt_latex_unary_expr_processor&lt; InterfaceType &gt;</a></td><td class="indexvalue">A LaTeX processor responsible for translating unary expressions to LaTeX code </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1rt__latex__variable__processor.html">rt_latex_variable_processor&lt; InterfaceType &gt;</a></td><td class="indexvalue">A LaTeX processor responsible for translating ViennaMath runtime variables to LaTeX code </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1rt__manipulation__interface.html">rt_manipulation_interface&lt; InterfaceType &gt;</a></td><td class="indexvalue">The abstract runtime interface for all expression manipulators </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1rt__manipulation__wrapper.html">rt_manipulation_wrapper&lt; InterfaceType &gt;</a></td><td class="indexvalue">A wrapper using type erasure for manipulation functors acting on expressions </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1rt__numerical__quadrature.html">rt_numerical_quadrature&lt; InterfaceType &gt;</a></td><td class="indexvalue">The main numerical quadrature rule class. Wraps the integration rule and performs all the book-keeping for the evaluation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1rt__symbolic__interval.html">rt_symbolic_interval&lt; InterfaceType &gt;</a></td><td class="indexvalue">A symbolic runtime interval </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1rt__traversal__interface.html">rt_traversal_interface&lt; InterfaceType &gt;</a></td><td class="indexvalue">The abstract runtime interface for all expression traversal routines </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1rt__traversal__wrapper.html">rt_traversal_wrapper&lt; InterfaceType &gt;</a></td><td class="indexvalue">A wrapper using type erasure for traversal functions acting on expressions </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr&lt; InterfaceType &gt;</a></td><td class="indexvalue">Runtime representation of a unary expression F(e), where F is a function of one argument (e.g. <a class="el" href="namespaceviennamath.html#aeb237d8f5686e7cddc50e8b2dc5a703e" title="Overload of the natural logarithm function for a ViennaMath runtime constant.">log()</a>) and e is an expression </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1rt__variable.html">rt_variable&lt; InterfaceType &gt;</a></td><td class="indexvalue">Representation of an variable (a variable). If the supplied argument is some vector type, a traits system accesses the id-th component </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1rt__vector__expr.html">rt_vector_expr&lt; InterfaceType &gt;</a></td><td class="indexvalue">An tweaked auto_ptr for run time <a class="el" href="classviennamath_1_1rt__expr.html" title="This class represents a smart pointer to all types expressions.">rt_expr</a> types </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1simplify.html">simplify&lt; ExpressionType, optimization_possible &gt;</a></td><td class="indexvalue">Top-level metafunction for the simplification of expressions. Loops over simplification rules until no more simplifications can be applied </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1simplify_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h_s_01_4_00_01false_01_4.html">simplify&lt; ct_binary_expr&lt; LHS, OP, RHS &gt;, false &gt;</a></td><td class="indexvalue">Specialization for a binary expression, for which no optimizations can be applied: Return the unmodified expression </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1simplify_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h_s_01_4_00_01true_01_4.html">simplify&lt; ct_binary_expr&lt; LHS, OP, RHS &gt;, true &gt;</a></td><td class="indexvalue">Specialization for a binary expression, for which optimizations can be applied </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1simplify_3_01ct__constant_3_01value_01_4_00_01false_01_4.html">simplify&lt; ct_constant&lt; value &gt;, false &gt;</a></td><td class="indexvalue">Specialization for a constant, for which no optimizations can be applied: Return the unmodified constant </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1simplify_3_01ct__constant_3_01value_01_4_00_01true_01_4.html">simplify&lt; ct_constant&lt; value &gt;, true &gt;</a></td><td class="indexvalue">Specialization for a constant, for which optimizations can be applied </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1simplify_3_01ct__function__symbol_3_01_t_a_g_01_4_00_01false_01_4.html">simplify&lt; ct_function_symbol&lt; TAG &gt;, false &gt;</a></td><td class="indexvalue">Specialization for a function symbol, for which no optimizations can be applied: Return the unmodified constant </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1simplify_3_01ct__function__symbol_3_01_t_a_g_01_4_00_01true_01_4.html">simplify&lt; ct_function_symbol&lt; TAG &gt;, true &gt;</a></td><td class="indexvalue">Specialization for a function symbol, for which optimizations can be applied </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1simplify_3_01ct__unary__expr_3_01_l_h_s_00_01_o_p_01_4_00_01false_01_4.html">simplify&lt; ct_unary_expr&lt; LHS, OP &gt;, false &gt;</a></td><td class="indexvalue">Specialization for a unary expression, for which no optimizations can be applied: Return the unmodified expression </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1simplify_3_01ct__unary__expr_3_01_l_h_s_00_01_o_p_01_4_00_01true_01_4.html">simplify&lt; ct_unary_expr&lt; LHS, OP &gt;, true &gt;</a></td><td class="indexvalue">Specialization for a unary expression, for which optimizations can be applied </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1simplify_3_01ct__variable_3_01id_01_4_00_01false_01_4.html">simplify&lt; ct_variable&lt; id &gt;, false &gt;</a></td><td class="indexvalue">Specialization for a compiletime variable, for which no optimizations can be applied: Return the unmodified constant </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1simplify_3_01ct__variable_3_01id_01_4_00_01true_01_4.html">simplify&lt; ct_variable&lt; id &gt;, true &gt;</a></td><td class="indexvalue">Specialization for a variable, for which optimizations can be applied </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl.html">simplify_impl&lt; ExpressionType &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__binary__cd976b5ea96734a912c29b789df99b64.html">simplify_impl&lt; ct_binary_expr&lt; ct_binary_expr&lt; ct_constant&lt; 0 &gt;, op_minus&lt; NumericT &gt;, RHS1 &gt;, op_minus&lt; NumericT &gt;, ct_binary_expr&lt; ct_constant&lt; 0 &gt;, op_minus&lt; NumericT &gt;, RHS2 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__binary__5ae9031e9fc0170323c465f9ee039ace.html">simplify_impl&lt; ct_binary_expr&lt; ct_binary_expr&lt; ct_constant&lt; 0 &gt;, op_minus&lt; NumericT &gt;, RHS1 &gt;, op_minus&lt; NumericT &gt;, RHS2 &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__binary__fcaf6a8df16c8d7386cc43f9a48937be.html">simplify_impl&lt; ct_binary_expr&lt; ct_binary_expr&lt; ct_constant&lt; 0 &gt;, op_minus&lt; NumericT &gt;, RHS1 &gt;, op_plus&lt; NumericT &gt;, ct_binary_expr&lt; ct_constant&lt; 0 &gt;, op_minus&lt; NumericT &gt;, RHS2 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__binary__3f4582f7d655eef3fceb638569786c61.html">simplify_impl&lt; ct_binary_expr&lt; ct_binary_expr&lt; ct_constant&lt; 0 &gt;, op_minus&lt; NumericT &gt;, RHS1 &gt;, op_plus&lt; NumericT &gt;, RHS2 &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__binary__4caf5ad1bdeacdee7cfe909d13a5d202.html">simplify_impl&lt; ct_binary_expr&lt; ct_binary_expr&lt; ct_constant&lt; 1 &gt;, op_div&lt; NumericT &gt;, RHS1 &gt;, op_mult&lt; NumericT &gt;, ct_binary_expr&lt; ct_constant&lt; 1 &gt;, op_div&lt; NumericT &gt;, RHS2 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__binary__87085a3aae000f4e21b37e47277b4dbd.html">simplify_impl&lt; ct_binary_expr&lt; ct_binary_expr&lt; ct_constant&lt; 1 &gt;, op_div&lt; NumericT &gt;, RHS1 &gt;, op_mult&lt; NumericT &gt;, RHS2 &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__binary__eaa9bd6e5d85ef52b7365182c7cfcd36.html">simplify_impl&lt; ct_binary_expr&lt; ct_binary_expr&lt; ct_constant&lt; numerator_1 &gt;, op_div&lt; NumericT &gt;, ct_constant&lt; denominator_1 &gt; &gt;, op_div&lt; NumericT &gt;, ct_binary_expr&lt; ct_constant&lt; numerator_2 &gt;, op_div&lt; NumericT &gt;, ct_constant&lt; denominator_2 &gt; &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__binary__2331f98d2593a557f5d4aca672a3e17e.html">simplify_impl&lt; ct_binary_expr&lt; ct_binary_expr&lt; ct_constant&lt; numerator_1 &gt;, op_div&lt; NumericT &gt;, ct_constant&lt; denominator_1 &gt; &gt;, op_div&lt; NumericT &gt;, ct_constant&lt; value_2 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__binary__ba3e1b214b34f43b636b432947041426.html">simplify_impl&lt; ct_binary_expr&lt; ct_binary_expr&lt; ct_constant&lt; numerator_1 &gt;, op_div&lt; NumericT &gt;, ct_constant&lt; denominator_1 &gt; &gt;, op_minus&lt; NumericT &gt;, ct_binary_expr&lt; ct_constant&lt; numerator_2 &gt;, op_div&lt; NumericT &gt;, ct_constant&lt; denominator_2 &gt; &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__binary__fc30a93e2d0d650f283123113481edad.html">simplify_impl&lt; ct_binary_expr&lt; ct_binary_expr&lt; ct_constant&lt; numerator_1 &gt;, op_div&lt; NumericT &gt;, ct_constant&lt; denominator_1 &gt; &gt;, op_minus&lt; NumericT &gt;, ct_constant&lt; 0 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__binary__4ae2fec5e37d19bdf99a4761a7cb9071.html">simplify_impl&lt; ct_binary_expr&lt; ct_binary_expr&lt; ct_constant&lt; numerator_1 &gt;, op_div&lt; NumericT &gt;, ct_constant&lt; denominator_1 &gt; &gt;, op_minus&lt; NumericT &gt;, ct_constant&lt; value_2 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__binary__6efa9285284345d8327b6cf7620459c2.html">simplify_impl&lt; ct_binary_expr&lt; ct_binary_expr&lt; ct_constant&lt; numerator_1 &gt;, op_div&lt; NumericT &gt;, ct_constant&lt; denominator_1 &gt; &gt;, op_mult&lt; NumericT &gt;, ct_binary_expr&lt; ct_constant&lt; numerator_2 &gt;, op_div&lt; NumericT &gt;, ct_constant&lt; denominator_2 &gt; &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__binary__20f23e5277ea599bc4187428f11279cf.html">simplify_impl&lt; ct_binary_expr&lt; ct_binary_expr&lt; ct_constant&lt; numerator_1 &gt;, op_div&lt; NumericT &gt;, ct_constant&lt; denominator_1 &gt; &gt;, op_mult&lt; NumericT &gt;, ct_constant&lt; value_2 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__binary__50fdc345a1fefc52f5361ca66d26cce0.html">simplify_impl&lt; ct_binary_expr&lt; ct_binary_expr&lt; ct_constant&lt; numerator_1 &gt;, op_div&lt; NumericT &gt;, ct_constant&lt; denominator_1 &gt; &gt;, op_plus&lt; NumericT &gt;, ct_binary_expr&lt; ct_constant&lt; numerator_2 &gt;, op_div&lt; NumericT &gt;, ct_constant&lt; denominator_2 &gt; &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__binary__1e9d81396f9ab72aeb708a783f9c32e4.html">simplify_impl&lt; ct_binary_expr&lt; ct_binary_expr&lt; ct_constant&lt; numerator_1 &gt;, op_div&lt; NumericT &gt;, ct_constant&lt; denominator_1 &gt; &gt;, op_plus&lt; NumericT &gt;, ct_constant&lt; value_2 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constant365271dedc5ae6ad81710bfbd1d55d34.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; 0 &gt;, op_div&lt; NumericT &gt;, ct_constant&lt; 0 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constant7c53f853bd251afd8ccef2e356f7995c.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; 0 &gt;, op_div&lt; NumericT &gt;, ct_constant&lt; 1 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constant4750d41f79be4fc74f0efc83e3e99bf0.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; 0 &gt;, op_div&lt; NumericT &gt;, ct_constant&lt; value_2 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constant22b8eb3c5321747aa19f8857fdd6350d.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; 0 &gt;, op_div&lt; NumericT &gt;, RHS &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constant5db70a173089e170b47379c0b7a6eaaa.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; 0 &gt;, op_mult&lt; NumericT &gt;, ct_constant&lt; 0 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constante1867da05ee3154442a3b0f6a210b8b3.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; 0 &gt;, op_mult&lt; NumericT &gt;, ct_constant&lt; 1 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constantbd070e689e84be7bfa42810afaa0bd96.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; 0 &gt;, op_mult&lt; NumericT &gt;, ct_constant&lt; value_2 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constant768204f14b8d033e6cf235f1d9cad0e0.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; 0 &gt;, op_mult&lt; NumericT &gt;, RHS &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constant638921282f4743aa47d7bd6bcfe713c8.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; 0 &gt;, op_plus&lt; NumericT &gt;, ct_constant&lt; 0 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constant9bb3e05e912bc52dce0345d8775bf6a7.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; 0 &gt;, op_plus&lt; NumericT &gt;, ct_constant&lt; value_2 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constante7a27747c9586d0521a20a6af0cb3e67.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; 0 &gt;, op_plus&lt; NumericT &gt;, RHS &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constantd6ad1f60e618c27004f7fb1656968eca.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; 1 &gt;, op_minus&lt; NumericT &gt;, ct_constant&lt; 0 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constantf2a8b6691fdb4f01ca3ef67ec3932717.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; 1 &gt;, op_mult&lt; NumericT &gt;, ct_constant&lt; 0 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constant0e93195672dfe8bdc016da5c4dfef577.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; 1 &gt;, op_mult&lt; NumericT &gt;, ct_constant&lt; 1 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constant07d42a7db14f00d1d5389cf7a7ab524b.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; 1 &gt;, op_mult&lt; NumericT &gt;, ct_constant&lt; value_2 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constantb53e39916caeb51b6e114948ee784513.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; 1 &gt;, op_mult&lt; NumericT &gt;, RHS &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constant1ee8cd59f622bb99d93baf09e6574011.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; value_1 &gt;, op_div&lt; NumericT &gt;, ct_binary_expr&lt; ct_constant&lt; numerator_2 &gt;, op_div&lt; NumericT &gt;, ct_constant&lt; denominator_2 &gt; &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constant22e354c9d5724ca0e7e63f4361eb3e99.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; value_1 &gt;, op_div&lt; NumericT &gt;, ct_constant&lt; 1 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constant461bdebfdaf54461f1763d2845a1bf19.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; value_1 &gt;, op_div&lt; NumericT &gt;, ct_constant&lt; value_2 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constant5970b5736c1b0b0fd529ef2e9f798199.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; value_1 &gt;, op_div&lt; NumericT &gt;, ct_constant&lt;-1 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constantf7d0941b4baeb6599ee5e7adc940436b.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; value_1 &gt;, op_minus&lt; NumericT &gt;, ct_binary_expr&lt; ct_constant&lt; numerator_2 &gt;, op_div&lt; NumericT &gt;, ct_constant&lt; denominator_2 &gt; &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constantd6a26c2abb0576da06e880a9a3577f8e.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; value_1 &gt;, op_minus&lt; NumericT &gt;, ct_constant&lt; value_2 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constantb2cb63e3b6032cb6ad54b766030327c8.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; value_1 &gt;, op_mult&lt; NumericT &gt;, ct_binary_expr&lt; ct_constant&lt; numerator_2 &gt;, op_div&lt; NumericT &gt;, ct_constant&lt; denominator_2 &gt; &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constant6dc932c93a4849be894f3fd7485dab89.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; value_1 &gt;, op_mult&lt; NumericT &gt;, ct_constant&lt; 0 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constant05cc87ad242bb39f3a426b5582d97fae.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; value_1 &gt;, op_mult&lt; NumericT &gt;, ct_constant&lt; 1 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constant10d3772a4d19519b16c86a3695ce457a.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; value_1 &gt;, op_mult&lt; NumericT &gt;, ct_constant&lt; value_2 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constant88f17b71e79b492966421be11734c665.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; value_1 &gt;, op_plus&lt; NumericT &gt;, ct_binary_expr&lt; ct_constant&lt; numerator_2 &gt;, op_div&lt; NumericT &gt;, ct_constant&lt; denominator_2 &gt; &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constant32bce80a5173b9021ccd2472344c91c3.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; value_1 &gt;, op_plus&lt; NumericT &gt;, ct_constant&lt; 0 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constant129aaba7b80b6caae23bd8ac0b5629ce.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt; value_1 &gt;, op_plus&lt; NumericT &gt;, ct_constant&lt; value_2 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01ct__constantde766235a9dae8304570967a1d9df2a2.html">simplify_impl&lt; ct_binary_expr&lt; ct_constant&lt;-1 &gt;, op_minus&lt; NumericT &gt;, ct_constant&lt; 0 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h_s_01_4_01_4.html">simplify_impl&lt; ct_binary_expr&lt; LHS, OP, RHS &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01_l_h_s_00_014d033dcd3ce47d707f5285d1be7e79c8.html">simplify_impl&lt; ct_binary_expr&lt; LHS, op_div&lt; NumericT &gt;, ct_constant&lt; 0 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01_l_h_s_00_01bcf2ac6f30aa3b9b2de2645004c400f3.html">simplify_impl&lt; ct_binary_expr&lt; LHS, op_div&lt; NumericT &gt;, ct_constant&lt; 1 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01_l_h_s_00_01f6dd5bb36ea1b0ba394a32dd36d14dc4.html">simplify_impl&lt; ct_binary_expr&lt; LHS, op_minus&lt; NumericT &gt;, ct_constant&lt; 0 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01_l_h_s_00_01079745e72830e4f7c9d352e9fffce507.html">simplify_impl&lt; ct_binary_expr&lt; LHS, op_mult&lt; NumericT &gt;, ct_binary_expr&lt; ct_constant&lt; 1 &gt;, op_div&lt; NumericT &gt;, RHS &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01_l_h_s_00_01cbad551d1cba4ff69cd68d541f6f6233.html">simplify_impl&lt; ct_binary_expr&lt; LHS, op_mult&lt; NumericT &gt;, ct_constant&lt; 0 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01_l_h_s_00_01ce1db17b2d0228cd3083dfd27481d6d6.html">simplify_impl&lt; ct_binary_expr&lt; LHS, op_mult&lt; NumericT &gt;, ct_constant&lt; 1 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01_l_h_s_00_0189ecb1ddba067bb2cb49682399bba067.html">simplify_impl&lt; ct_binary_expr&lt; LHS, op_plus&lt; NumericT &gt;, ct_constant&lt; 0 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01_l_h_s1_00_0d6959ce2c85ba4328f95dd841c7de2a1.html">simplify_impl&lt; ct_binary_expr&lt; LHS1, op_minus&lt; NumericT &gt;, ct_binary_expr&lt; ct_constant&lt; 0 &gt;, op_minus&lt; NumericT &gt;, RHS2 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1detail_1_1simplify__impl_3_01ct__binary__expr_3_01_l_h_s1_00_02338557a9322f23b07828c61a821122b.html">simplify_impl&lt; ct_binary_expr&lt; LHS1, op_plus&lt; NumericT &gt;, ct_binary_expr&lt; ct_constant&lt; 0 &gt;, op_minus&lt; NumericT &gt;, RHS2 &gt; &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1substitute.html">substitute&lt; SearchType, ReplacementType, ExpressionType &gt;</a></td><td class="indexvalue">Default case for the compiletime substitution metafunction: Do not define any return type. This provides SFINAE for the interface function </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h0f87136a71f9c909af6daee650d850ae.html">substitute&lt; ct_binary_expr&lt; LHS, OP, RHS &gt;, ReplacementType, ct_binary_expr&lt; LHS, OP, RHS &gt; &gt;</a></td><td class="indexvalue">If there is a match for the binary expression, the replacement is returned </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01ct__constant_3_01value_01_4_00_01_replacement_t36a9dee6096d8d038c95b59e92d1fadc.html">substitute&lt; ct_constant&lt; value &gt;, ReplacementType, ct_constant&lt; value &gt; &gt;</a></td><td class="indexvalue">If there is a match for the compiletime constant, the replacement is returned </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01ct__function__symbol_3_01_t_a_g_01_4_00_01_repl533efeac83c878388aa392e01e71cdbe.html">substitute&lt; ct_function_symbol&lt; TAG &gt;, ReplacementType, ct_function_symbol&lt; TAG &gt; &gt;</a></td><td class="indexvalue">If there is a match for the compiletime function symbol, the replacement is returned </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01ct__unary__expr_3_01_l_h_s_00_01_o_p_01_4_00_01cbe037ca3f825a32f06c7ffee55d38e2.html">substitute&lt; ct_unary_expr&lt; LHS, OP &gt;, ReplacementType, ct_unary_expr&lt; LHS, OP &gt; &gt;</a></td><td class="indexvalue">If there is a match for the unary expression, the replacement is returned </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01ct__variable_3_01id_01_4_00_01_replacement_typeddebcd8dd4169a510fb84cc21bdffaa5.html">substitute&lt; ct_variable&lt; id &gt;, ReplacementType, ct_variable&lt; id &gt; &gt;</a></td><td class="indexvalue">If there is a match for the compiletime variable, the replacement is returned </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01_search_type_00_01_replacement_type_00_01ct__bi8a26ae43012ec44e7b3eb1374af4669d.html">substitute&lt; SearchType, ReplacementType, ct_binary_expr&lt; LHS, OP, RHS &gt; &gt;</a></td><td class="indexvalue">For a binary expression, the substitution is performed for both operands </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01_search_type_00_01_replacement_type_00_01ct__constant_3_01value_01_4_01_4.html">substitute&lt; SearchType, ReplacementType, ct_constant&lt; value &gt; &gt;</a></td><td class="indexvalue">By default, a compiletime constant is left unmodified (no match) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01_search_type_00_01_replacement_type_00_01ct__fuc4542387a2938c39fb0805bb1220ae46.html">substitute&lt; SearchType, ReplacementType, ct_function_symbol&lt; TAG &gt; &gt;</a></td><td class="indexvalue">By default, a compiletime function symbol is left unmodified (no match) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01_search_type_00_01_replacement_type_00_01ct__un0dd76973b9488f668651aa73794c79b9.html">substitute&lt; SearchType, ReplacementType, ct_unary_expr&lt; LHS, OP &gt; &gt;</a></td><td class="indexvalue">For a unary expression, the substitution is performed for the operand </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01_search_type_00_01_replacement_type_00_01ct__variable_3_01id_01_4_01_4.html">substitute&lt; SearchType, ReplacementType, ct_variable&lt; id &gt; &gt;</a></td><td class="indexvalue">By default, a compiletime variable is left unmodified (no match) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1subtract.html">subtract&lt; LHS, RHS, b1, b2 &gt;</a></td><td class="indexvalue">Returns the type when subtracting two expressions. Default case: both types are runtime expressions </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1result__of_1_1subtract_3_01_l_h_s_00_01_r_h_s_00_01true_00_01true_01_4.html">subtract&lt; LHS, RHS, true, true &gt;</a></td><td class="indexvalue">Metafunction for subtracting two compiletime expressions </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1symbolic__integral__evaluation__not__possible__exception.html">symbolic_integral_evaluation_not_possible_exception</a></td><td class="indexvalue">Analytic integration at runtime not supported </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1test__tag.html">test_tag&lt; ct_id &gt;</a></td><td class="indexvalue">A compiletime tag for a test function: </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1type__by__index.html">type_by_index&lt; vmath_vector, id &gt;</a></td><td class="indexvalue">Helper metafunction for returning the 'id'-th entry of a compiletime vector </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1type__by__index_3_01vmath__vector_00_010_01_4.html">type_by_index&lt; vmath_vector, 0 &gt;</a></td><td class="indexvalue">Accesses the first entry in a compiletime vector </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1type__by__index_3_01vmath__vector_00_011_01_4.html">type_by_index&lt; vmath_vector, 1 &gt;</a></td><td class="indexvalue">Accesses the second entry in a compiletime vector </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1type__by__index_3_01vmath__vector_00_012_01_4.html">type_by_index&lt; vmath_vector, 2 &gt;</a></td><td class="indexvalue">Accesses the third entry in a compiletime vector </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1unknown__tag.html">unknown_tag&lt; ct_id &gt;</a></td><td class="indexvalue">A compiletime tag for an unknown function: </td></tr>
  <tr><td class="indexkey"><a class="el" href="classviennamath_1_1variable__index__out__of__bounds__exception.html">variable_index_out_of_bounds_exception</a></td><td class="indexvalue">An exception which is thrown if a variable index is out of bounds. Similar to the C++ STL, index checks are performed on vectors using the .at() member function only </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1variable__traits.html">variable_traits&lt; VectorType, id &gt;</a></td><td class="indexvalue">Helper struct for accessing the i-th element of a vector at runtime </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1variable__traits_3_01ct__constant_3_01value___01_4_00_010_01_4.html">variable_traits&lt; ct_constant&lt; value_ &gt;, 0 &gt;</a></td><td class="indexvalue">Helper struct for accessing the 0-th element of a constant at runtime </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1variable__traits_3_01ct__constant_3_01value___01_4_00_01id_01_4.html">variable_traits&lt; ct_constant&lt; value_ &gt;, id &gt;</a></td><td class="indexvalue">Compiletime guard for index out of bounds </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1variable__traits_3_01ct__vector__1_3_01_t0_01_4_00_01id_01_4.html">variable_traits&lt; ct_vector_1&lt; T0 &gt;, id &gt;</a></td><td class="indexvalue">Helper struct for accessing the i-th element of a vector at runtime. Specialization for a ViennaMath compiletime vector with one entry </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1variable__traits_3_01ct__vector__2_3_01_t0_00_01_t1_01_4_00_01id_01_4.html">variable_traits&lt; ct_vector_2&lt; T0, T1 &gt;, id &gt;</a></td><td class="indexvalue">Helper struct for accessing the i-th element of a vector at runtime. Specialization for a ViennaMath compiletime vector with two entries </td></tr>
  <tr><td class="indexkey"><a class="el" href="structviennamath_1_1variable__traits_3_01ct__vector__3_3_01_t0_00_01_t1_00_01_t2_01_4_00_01id_01_4.html">variable_traits&lt; ct_vector_3&lt; T0, T1, T2 &gt;, id &gt;</a></td><td class="indexvalue">Helper struct for accessing the i-th element of a vector at runtime. Specialization for a ViennaMath compiletime vector with three entries </td></tr>
</table>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Feb 29 2012 21:50:44 for ViennaMath by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
