<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ViennaMath: op_interface&lt; InterfaceType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceviennamath.html">viennamath</a>      </li>
      <li><a class="el" href="classviennamath_1_1op__interface.html">op_interface&lt; InterfaceType &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>op_interface&lt; InterfaceType &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="viennamath::op_interface" -->
<p>The abstract runtime interface for all operations (unary and binary).  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="op__interface_8hpp_source.html">op_interface.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for op_interface&lt; InterfaceType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classviennamath_1_1op__interface.png" usemap="#op_interface&lt; InterfaceType &gt;_map" alt=""/>
  <map id="op_interface&lt; InterfaceType &gt;_map" name="op_interface&lt; InterfaceType &gt;_map">
<area href="classviennamath_1_1op__binary.html" alt="op_binary&lt; BinaryOperation, InterfaceType &gt;" shape="rect" coords="0,56,273,80"/>
<area href="classviennamath_1_1op__unary.html" alt="op_unary&lt; UnaryOperation, InterfaceType &gt;" shape="rect" coords="283,56,556,80"/>
</map>
</div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef InterfaceType::numeric_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1op__interface.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1op__interface.html#a35cba5468afea7dd1390c85665a00850">~op_interface</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classviennamath_1_1op__interface.html">op_interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1op__interface.html#acb42de0ac93a04c69b872d6dcf0645ca">clone</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The operator returns a pointer to a copy of itself.  <a href="#acb42de0ac93a04c69b872d6dcf0645ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1op__interface.html#a6522bc65bd97a6b1ef6cdfe78462a919">str</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an identification string describing the operator, e.g. exp, sin, cos, ...  <a href="#a6522bc65bd97a6b1ef6cdfe78462a919"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classviennamath_1_1op__interface.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1op__interface.html#aea3fb95031a66329766379367a8cf2f0">apply</a> (<a class="el" href="classviennamath_1_1op__interface.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> value) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applys the operator to the provided value. Unary operators must overwrite this function.  <a href="#aea3fb95031a66329766379367a8cf2f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classviennamath_1_1op__interface.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1op__interface.html#ac4685fd21ebfc57933427ce28f185521">apply</a> (<a class="el" href="classviennamath_1_1op__interface.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> lhs, <a class="el" href="classviennamath_1_1op__interface.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> rhs) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applys the operator to the left hand side 'lhs' and the right hand side 'rhs'. Binary operators must overwrite this function.  <a href="#ac4685fd21ebfc57933427ce28f185521"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1op__interface.html#af625108815456e0f5b28b6e05f0aefee">is_unary</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A boolean flag that specifies whether the operator is an unary operator, i.e. taking one argument only.  <a href="#af625108815456e0f5b28b6e05f0aefee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual InterfaceType *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1op__interface.html#a824f3bdf40476278afc17b57c726cf83">diff</a> (const InterfaceType *e, const InterfaceType *diff_var) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface for differentation of a unary expression.  <a href="#a824f3bdf40476278afc17b57c726cf83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual InterfaceType *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1op__interface.html#a0c62ce4d4c629fe8e2191fc9e711c959">diff</a> (const InterfaceType *lhs, const InterfaceType *rhs, const InterfaceType *diff_var) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface for differentation of a binary expression.  <a href="#a0c62ce4d4c629fe8e2191fc9e711c959"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual InterfaceType *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1op__interface.html#a977a47ff2a042403c0754b5de837a905">simplify</a> (const InterfaceType *lhs, const InterfaceType *rhs) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface for the simplification of a binary expression by passing the two operands.  <a href="#a977a47ff2a042403c0754b5de837a905"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1op__interface.html#ac82e4adc666e7f9cc09cd2f0bfbe238d">can_simplify</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the unary expression can be simplified.  <a href="#ac82e4adc666e7f9cc09cd2f0bfbe238d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1op__interface.html#aeb190de6dd6fb0c4ea1bc8372f08656b">can_simplify</a> (const InterfaceType *lhs, const InterfaceType *rhs) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the binary expression can be simplified.  <a href="#aeb190de6dd6fb0c4ea1bc8372f08656b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1op__interface.html#aae94dca351c07f61abc1a71fa7c054b9">equal</a> (const <a class="el" href="classviennamath_1_1op__interface.html">op_interface</a> *other) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if 'other' is the same operation as the respective object.  <a href="#aae94dca351c07f61abc1a71fa7c054b9"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename InterfaceType&gt;<br/>
 class viennamath::op_interface&lt; InterfaceType &gt;</h3>

<p>The abstract runtime interface for all operations (unary and binary). </p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InterfaceType</em>&nbsp;</td><td>The expression runtime interface. Usually <a class="el" href="classviennamath_1_1rt__expression__interface.html" title="Abstract interface for all ViennaMath runtime expressions.">rt_expression_interface</a>, but extensions are possible. </td></tr>
  </table>
  </dd>
</dl>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="afb5ce2ac2be0c7efb30e536b8edd4c30"></a><!-- doxytag: member="viennamath::op_interface::numeric_type" ref="afb5ce2ac2be0c7efb30e536b8edd4c30" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InterfaceType::numeric_type <a class="el" href="classviennamath_1_1op__interface.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classviennamath_1_1op__binary.html#afb5ce2ac2be0c7efb30e536b8edd4c30">op_binary&lt; BinaryOperation, InterfaceType &gt;</a>, and <a class="el" href="classviennamath_1_1op__unary.html#afb5ce2ac2be0c7efb30e536b8edd4c30">op_unary&lt; UnaryOperation, InterfaceType &gt;</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a35cba5468afea7dd1390c85665a00850"></a><!-- doxytag: member="viennamath::op_interface::~op_interface" ref="a35cba5468afea7dd1390c85665a00850" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="classviennamath_1_1op__interface.html">op_interface</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aea3fb95031a66329766379367a8cf2f0"></a><!-- doxytag: member="viennamath::op_interface::apply" ref="aea3fb95031a66329766379367a8cf2f0" args="(numeric_type value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classviennamath_1_1op__interface.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1op__interface.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applys the operator to the provided value. Unary operators must overwrite this function. </p>

<p>Reimplemented in <a class="el" href="classviennamath_1_1op__unary.html#a3c4ec5c18829e3c01c393f4a66a93aef">op_unary&lt; UnaryOperation, InterfaceType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ac4685fd21ebfc57933427ce28f185521"></a><!-- doxytag: member="viennamath::op_interface::apply" ref="ac4685fd21ebfc57933427ce28f185521" args="(numeric_type lhs, numeric_type rhs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classviennamath_1_1op__interface.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1op__interface.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1op__interface.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applys the operator to the left hand side 'lhs' and the right hand side 'rhs'. Binary operators must overwrite this function. </p>

</div>
</div>
<a class="anchor" id="ac82e4adc666e7f9cc09cd2f0bfbe238d"></a><!-- doxytag: member="viennamath::op_interface::can_simplify" ref="ac82e4adc666e7f9cc09cd2f0bfbe238d" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool can_simplify </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the unary expression can be simplified. </p>

<p>Implemented in <a class="el" href="classviennamath_1_1op__binary.html#a753df58aef455c024be3bd466ef3ff04">op_binary&lt; BinaryOperation, InterfaceType &gt;</a>, and <a class="el" href="classviennamath_1_1op__unary.html#a753df58aef455c024be3bd466ef3ff04">op_unary&lt; UnaryOperation, InterfaceType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aeb190de6dd6fb0c4ea1bc8372f08656b"></a><!-- doxytag: member="viennamath::op_interface::can_simplify" ref="aeb190de6dd6fb0c4ea1bc8372f08656b" args="(const InterfaceType *lhs, const InterfaceType *rhs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool can_simplify </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the binary expression can be simplified. </p>

<p>Reimplemented in <a class="el" href="classviennamath_1_1op__binary.html#ae105b0c2a1d0a71adde7d947d7921efd">op_binary&lt; BinaryOperation, InterfaceType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="acb42de0ac93a04c69b872d6dcf0645ca"></a><!-- doxytag: member="viennamath::op_interface::clone" ref="acb42de0ac93a04c69b872d6dcf0645ca" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classviennamath_1_1op__interface.html">op_interface</a>* clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The operator returns a pointer to a copy of itself. </p>

<p>Implemented in <a class="el" href="classviennamath_1_1op__binary.html#a467e646e0e729dd088b864c1e31e465b">op_binary&lt; BinaryOperation, InterfaceType &gt;</a>, and <a class="el" href="classviennamath_1_1op__unary.html#a467e646e0e729dd088b864c1e31e465b">op_unary&lt; UnaryOperation, InterfaceType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a0c62ce4d4c629fe8e2191fc9e711c959"></a><!-- doxytag: member="viennamath::op_interface::diff" ref="a0c62ce4d4c629fe8e2191fc9e711c959" args="(const InterfaceType *lhs, const InterfaceType *rhs, const InterfaceType *diff_var) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual InterfaceType* diff </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>diff_var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interface for differentation of a binary expression. </p>

<p>Reimplemented in <a class="el" href="classviennamath_1_1op__binary.html#a4da2878c5159b17e7383d22b2e11aada">op_binary&lt; BinaryOperation, InterfaceType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a824f3bdf40476278afc17b57c726cf83"></a><!-- doxytag: member="viennamath::op_interface::diff" ref="a824f3bdf40476278afc17b57c726cf83" args="(const InterfaceType *e, const InterfaceType *diff_var) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual InterfaceType* diff </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>diff_var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interface for differentation of a unary expression. </p>

<p>Reimplemented in <a class="el" href="classviennamath_1_1op__unary.html#aafd479cbf657f40f13cb9922585ab22f">op_unary&lt; UnaryOperation, InterfaceType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aae94dca351c07f61abc1a71fa7c054b9"></a><!-- doxytag: member="viennamath::op_interface::equal" ref="aae94dca351c07f61abc1a71fa7c054b9" args="(const op_interface *other) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennamath_1_1op__interface.html">op_interface</a>&lt; InterfaceType &gt; *&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if 'other' is the same operation as the respective object. </p>

</div>
</div>
<a class="anchor" id="af625108815456e0f5b28b6e05f0aefee"></a><!-- doxytag: member="viennamath::op_interface::is_unary" ref="af625108815456e0f5b28b6e05f0aefee" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool is_unary </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A boolean flag that specifies whether the operator is an unary operator, i.e. taking one argument only. </p>

<p>Reimplemented in <a class="el" href="classviennamath_1_1op__binary.html#a2766177608ec8c79c1dff193e9b6e2cb">op_binary&lt; BinaryOperation, InterfaceType &gt;</a>, and <a class="el" href="classviennamath_1_1op__unary.html#a2766177608ec8c79c1dff193e9b6e2cb">op_unary&lt; UnaryOperation, InterfaceType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a977a47ff2a042403c0754b5de837a905"></a><!-- doxytag: member="viennamath::op_interface::simplify" ref="a977a47ff2a042403c0754b5de837a905" args="(const InterfaceType *lhs, const InterfaceType *rhs) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual InterfaceType* simplify </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interface for the simplification of a binary expression by passing the two operands. </p>

<p>Implemented in <a class="el" href="classviennamath_1_1op__binary.html#a96b2467f46f5560fb8af80c454cbab69">op_binary&lt; BinaryOperation, InterfaceType &gt;</a>, and <a class="el" href="classviennamath_1_1op__unary.html#ad4dd059b7b3b4193590e5ac77b82e1d7">op_unary&lt; UnaryOperation, InterfaceType &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a6522bc65bd97a6b1ef6cdfe78462a919"></a><!-- doxytag: member="viennamath::op_interface::str" ref="a6522bc65bd97a6b1ef6cdfe78462a919" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string str </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an identification string describing the operator, e.g. exp, sin, cos, ... </p>

<p>Implemented in <a class="el" href="classviennamath_1_1op__binary.html#a1b9b8885b0880fc4ddf9a2c7d1ca3dc4">op_binary&lt; BinaryOperation, InterfaceType &gt;</a>, and <a class="el" href="classviennamath_1_1op__unary.html#a1b9b8885b0880fc4ddf9a2c7d1ca3dc4">op_unary&lt; UnaryOperation, InterfaceType &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/export/development/ViennaMath/viennamath/runtime/<a class="el" href="op__interface_8hpp_source.html">op_interface.hpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Feb 29 2012 21:50:44 for ViennaMath by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
