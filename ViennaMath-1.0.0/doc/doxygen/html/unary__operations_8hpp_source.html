<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ViennaMath: /export/development/ViennaMath/viennamath/manipulation/detail/unary_operations.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>/export/development/ViennaMath/viennamath/manipulation/detail/unary_operations.hpp</h1>  </div>
</div>
<div class="contents">
<a href="unary__operations_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef VIENNAMATH_UNARY_OPERATORS_MANIPULATION_HPP</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define VIENNAMATH_UNARY_OPERATORS_MANIPULATION_HPP</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="comment">/* =======================================================================</span>
<a name="l00005"></a>00005 <span class="comment">   Copyright (c) 2012, Institute for Microelectronics,</span>
<a name="l00006"></a>00006 <span class="comment">                       Institute for Analysis and Scientific Computing,</span>
<a name="l00007"></a>00007 <span class="comment">                       TU Wien.</span>
<a name="l00008"></a>00008 <span class="comment">                             -----------------</span>
<a name="l00009"></a>00009 <span class="comment">               ViennaMath - Symbolic and Numerical Math in C++</span>
<a name="l00010"></a>00010 <span class="comment">                             -----------------</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">   Author:     Karl Rupp                          rupp@iue.tuwien.ac.at</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">   License:    MIT (X11), see file LICENSE in the ViennaMath base directory</span>
<a name="l00015"></a>00015 <span class="comment">======================================================================= */</span>
<a name="l00016"></a>00016 
<a name="l00017"></a>00017 
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="forwards_8h.html" title="Contains forward declarations and definition of small classes/metafunctions required to be defined at...">viennamath/forwards.h</a>&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;<a class="code" href="exception_8hpp.html" title="Defines all the exceptions thrown within ViennaMath.">viennamath/exception.hpp</a>&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="unary__op__tags_8hpp.html" title="Defines the tags for unary operations.">viennamath/compiletime/unary_op_tags.hpp</a>&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="unary__expr_8hpp.html" title="Defines a class representing an unary expression, i.e. an expression a unary manipulator (e...">viennamath/runtime/unary_expr.hpp</a>&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;<a class="code" href="binary__expr_8hpp.html" title="Defines the binary expression class.">viennamath/runtime/binary_expr.hpp</a>&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="integral_8hpp.html" title="Defines concrete and symbolic interval operations at runtime.">viennamath/runtime/integral.hpp</a>&quot;</span>
<a name="l00029"></a>00029 
<a name="l00034"></a>00034 <span class="keyword">namespace </span>viennamath
<a name="l00035"></a>00035 {
<a name="l00036"></a>00036   
<a name="l00037"></a>00037   <span class="comment">//</span>
<a name="l00038"></a>00038   <span class="comment">// identity</span>
<a name="l00039"></a>00039   <span class="comment">//</span>
<a name="l00041"></a>00041 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType, <span class="keyword">typename</span> NumericT&gt;
<a name="l00042"></a>00042   InterfaceType * <a class="code" href="namespaceviennamath.html#ab2aded2fd0a5e180147b4e571389ae0a" title="Implementation of the differentation of e1 + e1, where e1 and e2 are expressions.">diff_impl</a>(<span class="keyword">const</span> InterfaceType * e, op_id&lt;NumericT&gt;, <span class="keyword">const</span> InterfaceType * diff_var)
<a name="l00043"></a>00043   {
<a name="l00044"></a>00044     <span class="keywordflow">return</span> e-&gt;diff(diff_var); 
<a name="l00045"></a>00045   }
<a name="l00046"></a>00046   
<a name="l00047"></a>00047   <span class="comment">//</span>
<a name="l00048"></a>00048   <span class="comment">// exponential</span>
<a name="l00049"></a>00049   <span class="comment">//</span>
<a name="l00051"></a>00051 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType, <span class="keyword">typename</span> NumericT&gt;
<a name="l00052"></a>00052   InterfaceType * <a class="code" href="namespaceviennamath.html#ab2aded2fd0a5e180147b4e571389ae0a" title="Implementation of the differentation of e1 + e1, where e1 and e2 are expressions.">diff_impl</a>(<span class="keyword">const</span> InterfaceType * e, op_exp&lt;NumericT&gt;, <span class="keyword">const</span> InterfaceType * diff_var)
<a name="l00053"></a>00053   {
<a name="l00054"></a>00054     <span class="keywordflow">return</span> <span class="keyword">new</span> rt_binary_expr&lt;InterfaceType&gt;( <span class="keyword">new</span> rt_unary_expr&lt;InterfaceType&gt;(e-&gt;clone(), <span class="keyword">new</span> op_unary&lt;op_exp&lt;NumericT&gt;, InterfaceType&gt;()),
<a name="l00055"></a>00055                                            <span class="keyword">new</span> op_binary&lt;op_mult&lt;typename InterfaceType::numeric_type&gt;, InterfaceType&gt;(),
<a name="l00056"></a>00056                                            e-&gt;diff(diff_var)); 
<a name="l00057"></a>00057   }
<a name="l00058"></a>00058 
<a name="l00060"></a>00060   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> InterfaceType&gt;
<a name="l00061"></a><a class="code" href="namespaceviennamath.html#aebc9979a5a89c77c58d3648a2dbb218e">00061</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#aebc9979a5a89c77c58d3648a2dbb218e" title="Overload of the exponential function for a ViennaMath runtime constant.">exp</a>(<a class="code" href="classviennamath_1_1rt__constant.html" title="Representation of a constant within the expression setting of ViennaMath.">rt_constant&lt;NumericT, InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00062"></a>00062   {
<a name="l00063"></a>00063     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__constant.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the constant. The object referred by the pointer is not automatically deleted...">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_exp&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00064"></a>00064   }
<a name="l00065"></a>00065 
<a name="l00067"></a>00067   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00068"></a><a class="code" href="namespaceviennamath.html#a987cd95708aed4f6ac167110874d4a2c">00068</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#aebc9979a5a89c77c58d3648a2dbb218e" title="Overload of the exponential function for a ViennaMath runtime constant.">exp</a>(<a class="code" href="classviennamath_1_1rt__variable.html" title="Representation of an variable (a variable). If the supplied argument is some vector type...">rt_variable&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00069"></a>00069   {
<a name="l00070"></a>00070     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__variable.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the variable. The returned pointer is not automatically deleted, thus the caller needs to ensure deletion.">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_exp&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00071"></a>00071   }
<a name="l00072"></a>00072 
<a name="l00074"></a>00074   <span class="keyword">template</span> &lt;<span class="keywordtype">id</span>_type <span class="keywordtype">id</span>&gt;
<a name="l00075"></a><a class="code" href="namespaceviennamath.html#ad90b3035ce745a93c453bbb7d96ae46b">00075</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a> <a class="code" href="namespaceviennamath.html#aebc9979a5a89c77c58d3648a2dbb218e" title="Overload of the exponential function for a ViennaMath runtime constant.">exp</a>(<a class="code" href="structviennamath_1_1ct__variable.html" title="Representation of a mathematical variable. If the supplied argument is some vector type...">ct_variable&lt;id&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00076"></a>00076   {
<a name="l00077"></a>00077     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(<span class="keyword">new</span> <a class="code" href="classviennamath_1_1rt__variable.html" title="Representation of an variable (a variable). If the supplied argument is some vector type...">rt_variable&lt;&gt;</a>(id), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary</a>&lt;<a class="code" href="structviennamath_1_1op__exp.html" title="Exponential mapping: x |--&amp;gt; exp(x).">op_exp&lt;default_numeric_type&gt;</a> &gt;()); 
<a name="l00078"></a>00078   }
<a name="l00079"></a>00079 
<a name="l00081"></a>00081   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00082"></a><a class="code" href="namespaceviennamath.html#a61b858b450e456302f721b4ff282d9e3">00082</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#aebc9979a5a89c77c58d3648a2dbb218e" title="Overload of the exponential function for a ViennaMath runtime constant.">exp</a>(<a class="code" href="classviennamath_1_1rt__binary__expr.html" title="Runtime representation of a binary expression F(x,y), where F is a function of two argument (e...">rt_binary_expr&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00083"></a>00083   {
<a name="l00084"></a>00084     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__binary__expr.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the binary expression. The caller is responsible for deleting the returned object...">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_exp&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00085"></a>00085   }
<a name="l00086"></a>00086 
<a name="l00088"></a>00088   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> OP, <span class="keyword">typename</span> RHS&gt;
<a name="l00089"></a><a class="code" href="namespaceviennamath.html#ab026d3b9ba9bcd69872a1344b1deb337">00089</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a> <a class="code" href="namespaceviennamath.html#aebc9979a5a89c77c58d3648a2dbb218e" title="Overload of the exponential function for a ViennaMath runtime constant.">exp</a>(<a class="code" href="classviennamath_1_1ct__binary__expr.html" title="A compile time expression consisting of two operands and one operation (taking two arguments)...">ct_binary_expr&lt;LHS, OP, RHS&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00090"></a>00090   {
<a name="l00091"></a>00091     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(<span class="keyword">new</span> <a class="code" href="classviennamath_1_1rt__binary__expr.html" title="Runtime representation of a binary expression F(x,y), where F is a function of two argument (e...">rt_binary_expr&lt;&gt;</a>(other),
<a name="l00092"></a>00092                         <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary</a>&lt;<a class="code" href="structviennamath_1_1op__exp.html" title="Exponential mapping: x |--&amp;gt; exp(x).">op_exp&lt;default_numeric_type&gt;</a> &gt;()); 
<a name="l00093"></a>00093   }
<a name="l00094"></a>00094 
<a name="l00096"></a>00096   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> OP&gt;
<a name="l00097"></a><a class="code" href="namespaceviennamath.html#a2c32cb661a87fef8e39deeb0e925bc0b">00097</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a> <a class="code" href="namespaceviennamath.html#aebc9979a5a89c77c58d3648a2dbb218e" title="Overload of the exponential function for a ViennaMath runtime constant.">exp</a>(<a class="code" href="classviennamath_1_1ct__unary__expr.html" title="Defines a unary expression f(e), where f is function and &amp;#39;e&amp;#39; is an expression.">ct_unary_expr&lt;LHS, OP&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00098"></a>00098   {
<a name="l00099"></a>00099     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(<span class="keyword">new</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(other),
<a name="l00100"></a>00100                            <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary</a>&lt;<a class="code" href="structviennamath_1_1op__exp.html" title="Exponential mapping: x |--&amp;gt; exp(x).">op_exp&lt;default_numeric_type&gt;</a> &gt;()); 
<a name="l00101"></a>00101   }
<a name="l00102"></a>00102 
<a name="l00104"></a>00104   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00105"></a><a class="code" href="namespaceviennamath.html#a1a9b4ef02365b4587acb152fd08d6da6">00105</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#aebc9979a5a89c77c58d3648a2dbb218e" title="Overload of the exponential function for a ViennaMath runtime constant.">exp</a>(<a class="code" href="classviennamath_1_1rt__expr.html" title="This class represents a smart pointer to all types expressions.">rt_expr&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00106"></a>00106   {
<a name="l00107"></a>00107     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__expr.html#ae5d07bc2f397dcb72329c0c3ed9d99e5">get</a>()-&gt;clone(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_exp&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00108"></a>00108   }
<a name="l00109"></a>00109 
<a name="l00110"></a>00110   
<a name="l00111"></a>00111   <span class="comment">//</span>
<a name="l00112"></a>00112   <span class="comment">// sinus</span>
<a name="l00113"></a>00113   <span class="comment">//</span>
<a name="l00114"></a>00114   
<a name="l00116"></a>00116   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType, <span class="keyword">typename</span> NumericT&gt;
<a name="l00117"></a>00117   InterfaceType * <a class="code" href="namespaceviennamath.html#ab2aded2fd0a5e180147b4e571389ae0a" title="Implementation of the differentation of e1 + e1, where e1 and e2 are expressions.">diff_impl</a>(<span class="keyword">const</span> InterfaceType * e, op_sin&lt;NumericT&gt;, <span class="keyword">const</span> InterfaceType * diff_var)
<a name="l00118"></a>00118   {
<a name="l00119"></a>00119     <span class="keywordflow">return</span> <span class="keyword">new</span> rt_binary_expr&lt;InterfaceType&gt;( <span class="keyword">new</span> rt_unary_expr&lt;InterfaceType&gt;(e-&gt;clone(), <span class="keyword">new</span> op_unary&lt;op_cos&lt;NumericT&gt;, InterfaceType&gt;()),
<a name="l00120"></a>00120                                            <span class="keyword">new</span> op_binary&lt;op_mult&lt;typename InterfaceType::numeric_type&gt;, InterfaceType&gt;(),
<a name="l00121"></a>00121                                            e-&gt;diff(diff_var) );
<a name="l00122"></a>00122   }
<a name="l00123"></a>00123 
<a name="l00125"></a>00125   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> InterfaceType&gt;
<a name="l00126"></a><a class="code" href="namespaceviennamath.html#adb139682031d58c74f3251482c912a65">00126</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#adb139682031d58c74f3251482c912a65" title="Overload of the sine function for a ViennaMath runtime constant.">sin</a>(<a class="code" href="classviennamath_1_1rt__constant.html" title="Representation of a constant within the expression setting of ViennaMath.">rt_constant&lt;NumericT, InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00127"></a>00127   {
<a name="l00128"></a>00128     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__constant.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the constant. The object referred by the pointer is not automatically deleted...">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_sin&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00129"></a>00129   }
<a name="l00130"></a>00130 
<a name="l00132"></a>00132   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00133"></a><a class="code" href="namespaceviennamath.html#a0e90789fe641f5b4a081e56b08fc9291">00133</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#adb139682031d58c74f3251482c912a65" title="Overload of the sine function for a ViennaMath runtime constant.">sin</a>(<a class="code" href="classviennamath_1_1rt__variable.html" title="Representation of an variable (a variable). If the supplied argument is some vector type...">rt_variable&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00134"></a>00134   {
<a name="l00135"></a>00135     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__variable.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the variable. The returned pointer is not automatically deleted, thus the caller needs to ensure deletion.">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_sin&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00136"></a>00136   }
<a name="l00137"></a>00137 
<a name="l00139"></a>00139   <span class="keyword">template</span> &lt;<span class="keywordtype">id</span>_type <span class="keywordtype">id</span>&gt;
<a name="l00140"></a><a class="code" href="namespaceviennamath.html#ae4fd81949da2c40ee2d5a0078460e177">00140</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a> <a class="code" href="namespaceviennamath.html#adb139682031d58c74f3251482c912a65" title="Overload of the sine function for a ViennaMath runtime constant.">sin</a>(<a class="code" href="structviennamath_1_1ct__variable.html" title="Representation of a mathematical variable. If the supplied argument is some vector type...">ct_variable&lt;id&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00141"></a>00141   {
<a name="l00142"></a>00142     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(<span class="keyword">new</span> <a class="code" href="classviennamath_1_1rt__variable.html" title="Representation of an variable (a variable). If the supplied argument is some vector type...">rt_variable&lt;&gt;</a>(id), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary</a>&lt;<a class="code" href="structviennamath_1_1op__sin.html" title="Sine function: x |--&amp;gt; sin(x).">op_sin&lt;default_numeric_type&gt;</a> &gt;()); 
<a name="l00143"></a>00143   }
<a name="l00144"></a>00144 
<a name="l00146"></a>00146   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> OP, <span class="keyword">typename</span> RHS&gt;
<a name="l00147"></a><a class="code" href="namespaceviennamath.html#a063eb151d24c03cf9179918b5c312af4">00147</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a> <a class="code" href="namespaceviennamath.html#adb139682031d58c74f3251482c912a65" title="Overload of the sine function for a ViennaMath runtime constant.">sin</a>(<a class="code" href="classviennamath_1_1ct__binary__expr.html" title="A compile time expression consisting of two operands and one operation (taking two arguments)...">ct_binary_expr&lt;LHS, OP, RHS&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00148"></a>00148   {
<a name="l00149"></a>00149     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(<span class="keyword">new</span> <a class="code" href="classviennamath_1_1rt__binary__expr.html" title="Runtime representation of a binary expression F(x,y), where F is a function of two argument (e...">rt_binary_expr&lt;&gt;</a>(other),
<a name="l00150"></a>00150                            <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary</a>&lt;<a class="code" href="structviennamath_1_1op__sin.html" title="Sine function: x |--&amp;gt; sin(x).">op_sin&lt;default_numeric_type&gt;</a> &gt;()); 
<a name="l00151"></a>00151   }
<a name="l00152"></a>00152 
<a name="l00154"></a>00154   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> OP&gt;
<a name="l00155"></a><a class="code" href="namespaceviennamath.html#a6e7edbb3417d17155fe81a296aac16ee">00155</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a> <a class="code" href="namespaceviennamath.html#adb139682031d58c74f3251482c912a65" title="Overload of the sine function for a ViennaMath runtime constant.">sin</a>(<a class="code" href="classviennamath_1_1ct__unary__expr.html" title="Defines a unary expression f(e), where f is function and &amp;#39;e&amp;#39; is an expression.">ct_unary_expr&lt;LHS, OP&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00156"></a>00156   {
<a name="l00157"></a>00157     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(<span class="keyword">new</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(other),
<a name="l00158"></a>00158                            <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary</a>&lt;<a class="code" href="structviennamath_1_1op__sin.html" title="Sine function: x |--&amp;gt; sin(x).">op_sin&lt;default_numeric_type&gt;</a> &gt;()); 
<a name="l00159"></a>00159   }
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 
<a name="l00163"></a>00163   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00164"></a><a class="code" href="namespaceviennamath.html#ad9542d9a32538308ca47867384f0001e">00164</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#adb139682031d58c74f3251482c912a65" title="Overload of the sine function for a ViennaMath runtime constant.">sin</a>(<a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00165"></a>00165   {
<a name="l00166"></a>00166     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__unary__expr.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the unary expression. The caller is responsible for deleting the returned object...">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_sin&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00167"></a>00167   }
<a name="l00168"></a>00168 
<a name="l00170"></a>00170   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00171"></a><a class="code" href="namespaceviennamath.html#a01828a35cd515c72e5631c690cc9d661">00171</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#adb139682031d58c74f3251482c912a65" title="Overload of the sine function for a ViennaMath runtime constant.">sin</a>(<a class="code" href="classviennamath_1_1rt__binary__expr.html" title="Runtime representation of a binary expression F(x,y), where F is a function of two argument (e...">rt_binary_expr&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00172"></a>00172   {
<a name="l00173"></a>00173     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__binary__expr.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the binary expression. The caller is responsible for deleting the returned object...">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_sin&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00174"></a>00174   }
<a name="l00175"></a>00175 
<a name="l00177"></a>00177   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00178"></a><a class="code" href="namespaceviennamath.html#a87a291b8cd5e8810deb3aa173a6e31c7">00178</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#adb139682031d58c74f3251482c912a65" title="Overload of the sine function for a ViennaMath runtime constant.">sin</a>(<a class="code" href="classviennamath_1_1rt__expr.html" title="This class represents a smart pointer to all types expressions.">rt_expr&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00179"></a>00179   {
<a name="l00180"></a>00180     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__expr.html#ae5d07bc2f397dcb72329c0c3ed9d99e5">get</a>()-&gt;clone(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_sin&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00181"></a>00181   }
<a name="l00182"></a>00182   
<a name="l00183"></a>00183   
<a name="l00184"></a>00184   
<a name="l00185"></a>00185   <span class="comment">//</span>
<a name="l00186"></a>00186   <span class="comment">// cosinus</span>
<a name="l00187"></a>00187   <span class="comment">//</span>
<a name="l00189"></a>00189 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType, <span class="keyword">typename</span> NumericT&gt;
<a name="l00190"></a>00190   InterfaceType * <a class="code" href="namespaceviennamath.html#ab2aded2fd0a5e180147b4e571389ae0a" title="Implementation of the differentation of e1 + e1, where e1 and e2 are expressions.">diff_impl</a>(<span class="keyword">const</span> InterfaceType * e, op_cos&lt;NumericT&gt;, <span class="keyword">const</span> InterfaceType * diff_var)
<a name="l00191"></a>00191   {
<a name="l00192"></a>00192     <span class="keywordflow">return</span> <span class="keyword">new</span> rt_binary_expr&lt;InterfaceType&gt;( <span class="keyword">new</span> rt_unary_expr&lt;InterfaceType&gt;(e-&gt;clone(), <span class="keyword">new</span> op_unary&lt;op_sin&lt;NumericT&gt;, InterfaceType&gt;()),
<a name="l00193"></a>00193                                            <span class="keyword">new</span> op_binary&lt;op_mult&lt;typename InterfaceType::numeric_type&gt;, InterfaceType&gt;(),
<a name="l00194"></a>00194                                            <span class="keyword">new</span> rt_binary_expr&lt;InterfaceType&gt;( <span class="keyword">new</span> rt_constant&lt;NumericT, InterfaceType&gt;(-1),
<a name="l00195"></a>00195                                                                               <span class="keyword">new</span> op_binary&lt;op_mult&lt;typename InterfaceType::numeric_type&gt;, InterfaceType&gt;(),
<a name="l00196"></a>00196                                                                               e-&gt;diff(diff_var) )
<a name="l00197"></a>00197                                           );
<a name="l00198"></a>00198   }
<a name="l00199"></a>00199 
<a name="l00201"></a>00201   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> InterfaceType&gt;
<a name="l00202"></a><a class="code" href="namespaceviennamath.html#ab34c1026105a04eef6e8433cc228893c">00202</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#ab34c1026105a04eef6e8433cc228893c" title="Overload of the cosine function for a ViennaMath runtime constant.">cos</a>(<a class="code" href="classviennamath_1_1rt__constant.html" title="Representation of a constant within the expression setting of ViennaMath.">rt_constant&lt;NumericT, InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00203"></a>00203   {
<a name="l00204"></a>00204     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__constant.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the constant. The object referred by the pointer is not automatically deleted...">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_cos&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00205"></a>00205   }
<a name="l00206"></a>00206 
<a name="l00208"></a>00208   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00209"></a><a class="code" href="namespaceviennamath.html#a5f9160049c00d26edcbf7223c9a9cc92">00209</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#ab34c1026105a04eef6e8433cc228893c" title="Overload of the cosine function for a ViennaMath runtime constant.">cos</a>(<a class="code" href="classviennamath_1_1rt__variable.html" title="Representation of an variable (a variable). If the supplied argument is some vector type...">rt_variable&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00210"></a>00210   {
<a name="l00211"></a>00211     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__variable.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the variable. The returned pointer is not automatically deleted, thus the caller needs to ensure deletion.">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_cos&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00212"></a>00212   }
<a name="l00213"></a>00213 
<a name="l00215"></a>00215   <span class="keyword">template</span> &lt;<span class="keywordtype">id</span>_type <span class="keywordtype">id</span>&gt;
<a name="l00216"></a><a class="code" href="namespaceviennamath.html#a0252e9b79684a885babceb416c0f7eeb">00216</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a> <a class="code" href="namespaceviennamath.html#ab34c1026105a04eef6e8433cc228893c" title="Overload of the cosine function for a ViennaMath runtime constant.">cos</a>(<a class="code" href="structviennamath_1_1ct__variable.html" title="Representation of a mathematical variable. If the supplied argument is some vector type...">ct_variable&lt;id&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00217"></a>00217   {
<a name="l00218"></a>00218     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(<span class="keyword">new</span> <a class="code" href="classviennamath_1_1rt__variable.html" title="Representation of an variable (a variable). If the supplied argument is some vector type...">rt_variable&lt;&gt;</a>(id), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary</a>&lt;<a class="code" href="structviennamath_1_1op__cos.html" title="Cosine function: x |--&amp;gt; cos(x).">op_cos&lt;default_numeric_type&gt;</a> &gt;()); 
<a name="l00219"></a>00219   }
<a name="l00220"></a>00220   
<a name="l00222"></a>00222   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> OP, <span class="keyword">typename</span> RHS&gt;
<a name="l00223"></a><a class="code" href="namespaceviennamath.html#abd11bddf2d5ea29cd6dc432ae84f0691">00223</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a> <a class="code" href="namespaceviennamath.html#ab34c1026105a04eef6e8433cc228893c" title="Overload of the cosine function for a ViennaMath runtime constant.">cos</a>(<a class="code" href="classviennamath_1_1ct__binary__expr.html" title="A compile time expression consisting of two operands and one operation (taking two arguments)...">ct_binary_expr&lt;LHS, OP, RHS&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00224"></a>00224   {
<a name="l00225"></a>00225     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(<span class="keyword">new</span> <a class="code" href="classviennamath_1_1rt__binary__expr.html" title="Runtime representation of a binary expression F(x,y), where F is a function of two argument (e...">rt_binary_expr&lt;&gt;</a>(other),
<a name="l00226"></a>00226                         <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary</a>&lt;<a class="code" href="structviennamath_1_1op__cos.html" title="Cosine function: x |--&amp;gt; cos(x).">op_cos&lt;default_numeric_type&gt;</a> &gt;()); 
<a name="l00227"></a>00227   }
<a name="l00228"></a>00228 
<a name="l00230"></a>00230   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> OP&gt;
<a name="l00231"></a><a class="code" href="namespaceviennamath.html#a241e81bac772871f95061481fe5a912c">00231</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a> <a class="code" href="namespaceviennamath.html#ab34c1026105a04eef6e8433cc228893c" title="Overload of the cosine function for a ViennaMath runtime constant.">cos</a>(<a class="code" href="classviennamath_1_1ct__unary__expr.html" title="Defines a unary expression f(e), where f is function and &amp;#39;e&amp;#39; is an expression.">ct_unary_expr&lt;LHS, OP&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00232"></a>00232   {
<a name="l00233"></a>00233     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(<span class="keyword">new</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(other),
<a name="l00234"></a>00234                            <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary</a>&lt;<a class="code" href="structviennamath_1_1op__cos.html" title="Cosine function: x |--&amp;gt; cos(x).">op_cos&lt;default_numeric_type&gt;</a> &gt;()); 
<a name="l00235"></a>00235   }
<a name="l00236"></a>00236 
<a name="l00237"></a>00237 
<a name="l00239"></a>00239   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00240"></a><a class="code" href="namespaceviennamath.html#abfdb31cae3e8b1958e19aff8d8caf240">00240</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#ab34c1026105a04eef6e8433cc228893c" title="Overload of the cosine function for a ViennaMath runtime constant.">cos</a>(<a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00241"></a>00241   {
<a name="l00242"></a>00242     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__unary__expr.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the unary expression. The caller is responsible for deleting the returned object...">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_cos&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00243"></a>00243   }
<a name="l00244"></a>00244 
<a name="l00246"></a>00246   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00247"></a><a class="code" href="namespaceviennamath.html#a6760f76e92b43f668ca0aadfa6f0bde0">00247</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#ab34c1026105a04eef6e8433cc228893c" title="Overload of the cosine function for a ViennaMath runtime constant.">cos</a>(<a class="code" href="classviennamath_1_1rt__binary__expr.html" title="Runtime representation of a binary expression F(x,y), where F is a function of two argument (e...">rt_binary_expr&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00248"></a>00248   {
<a name="l00249"></a>00249     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__binary__expr.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the binary expression. The caller is responsible for deleting the returned object...">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_cos&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00250"></a>00250   }
<a name="l00251"></a>00251 
<a name="l00253"></a>00253   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00254"></a><a class="code" href="namespaceviennamath.html#a20397bef45df45443e7fd1e9627ad12e">00254</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#ab34c1026105a04eef6e8433cc228893c" title="Overload of the cosine function for a ViennaMath runtime constant.">cos</a>(<a class="code" href="classviennamath_1_1rt__expr.html" title="This class represents a smart pointer to all types expressions.">rt_expr&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00255"></a>00255   {
<a name="l00256"></a>00256     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__expr.html#ae5d07bc2f397dcb72329c0c3ed9d99e5">get</a>()-&gt;clone(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_cos&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00257"></a>00257   }
<a name="l00258"></a>00258 
<a name="l00259"></a>00259   <span class="comment">//</span>
<a name="l00260"></a>00260   <span class="comment">// tangens</span>
<a name="l00261"></a>00261   <span class="comment">//</span>
<a name="l00263"></a>00263 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType, <span class="keyword">typename</span> NumericT&gt;
<a name="l00264"></a>00264   InterfaceType * <a class="code" href="namespaceviennamath.html#ab2aded2fd0a5e180147b4e571389ae0a" title="Implementation of the differentation of e1 + e1, where e1 and e2 are expressions.">diff_impl</a>(<span class="keyword">const</span> InterfaceType * e, op_tan&lt;NumericT&gt;, <span class="keyword">const</span> InterfaceType * diff_var)
<a name="l00265"></a>00265   {
<a name="l00266"></a>00266     <span class="comment">// 1/cos^2(e):</span>
<a name="l00267"></a>00267     <span class="keywordflow">return</span> <span class="keyword">new</span> rt_binary_expr&lt;InterfaceType&gt;( e-&gt;diff(diff_var),
<a name="l00268"></a>00268                                               <span class="keyword">new</span> op_binary&lt;op_div&lt;typename InterfaceType::numeric_type&gt;, InterfaceType&gt;(),
<a name="l00269"></a>00269                                               <span class="keyword">new</span> rt_binary_expr&lt;InterfaceType&gt;( <span class="keyword">new</span> rt_unary_expr&lt;InterfaceType&gt;(e-&gt;clone(),
<a name="l00270"></a>00270                                                                                                                   <span class="keyword">new</span> op_unary&lt;op_cos&lt;NumericT&gt;, InterfaceType&gt;()),
<a name="l00271"></a>00271                                                                                  <span class="keyword">new</span> op_binary&lt;op_mult&lt;typename InterfaceType::numeric_type&gt;, InterfaceType&gt;(),
<a name="l00272"></a>00272                                                                                  <span class="keyword">new</span> rt_unary_expr&lt;InterfaceType&gt;(e-&gt;clone(),
<a name="l00273"></a>00273                                                                                                                   <span class="keyword">new</span> op_unary&lt;op_cos&lt;NumericT&gt;, InterfaceType&gt;()) )
<a name="l00274"></a>00274                                             );
<a name="l00275"></a>00275   }
<a name="l00276"></a>00276 
<a name="l00278"></a>00278   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> InterfaceType&gt;
<a name="l00279"></a><a class="code" href="namespaceviennamath.html#a6466850318e6dcc1a0997af207ccde57">00279</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#a6466850318e6dcc1a0997af207ccde57" title="Overload of the tangent function for a ViennaMath runtime constant.">tan</a>(<a class="code" href="classviennamath_1_1rt__constant.html" title="Representation of a constant within the expression setting of ViennaMath.">rt_constant&lt;NumericT, InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00280"></a>00280   {
<a name="l00281"></a>00281     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__constant.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the constant. The object referred by the pointer is not automatically deleted...">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_tan&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00282"></a>00282   }
<a name="l00283"></a>00283 
<a name="l00285"></a>00285   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00286"></a><a class="code" href="namespaceviennamath.html#a8b481f3d63879c2978f03653e6153d37">00286</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#a6466850318e6dcc1a0997af207ccde57" title="Overload of the tangent function for a ViennaMath runtime constant.">tan</a>(<a class="code" href="classviennamath_1_1rt__variable.html" title="Representation of an variable (a variable). If the supplied argument is some vector type...">rt_variable&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00287"></a>00287   {
<a name="l00288"></a>00288     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__variable.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the variable. The returned pointer is not automatically deleted, thus the caller needs to ensure deletion.">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_tan&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00289"></a>00289   }
<a name="l00290"></a>00290 
<a name="l00292"></a>00292   <span class="keyword">template</span> &lt;<span class="keywordtype">id</span>_type <span class="keywordtype">id</span>&gt;
<a name="l00293"></a><a class="code" href="namespaceviennamath.html#ac8bd49e99dc88986d1fc3273c0e36fc2">00293</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a> <a class="code" href="namespaceviennamath.html#a6466850318e6dcc1a0997af207ccde57" title="Overload of the tangent function for a ViennaMath runtime constant.">tan</a>(<a class="code" href="structviennamath_1_1ct__variable.html" title="Representation of a mathematical variable. If the supplied argument is some vector type...">ct_variable&lt;id&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00294"></a>00294   {
<a name="l00295"></a>00295     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(<span class="keyword">new</span> <a class="code" href="classviennamath_1_1rt__variable.html" title="Representation of an variable (a variable). If the supplied argument is some vector type...">rt_variable&lt;&gt;</a>(id), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary</a>&lt;<a class="code" href="structviennamath_1_1op__tan.html" title="Tangent function: x |--&amp;gt; tan(x).">op_tan&lt;default_numeric_type&gt;</a> &gt;()); 
<a name="l00296"></a>00296   }
<a name="l00297"></a>00297   
<a name="l00299"></a>00299   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> OP, <span class="keyword">typename</span> RHS&gt;
<a name="l00300"></a><a class="code" href="namespaceviennamath.html#a6dad9a86aa4baf42aa2458dc87643c61">00300</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a> <a class="code" href="namespaceviennamath.html#a6466850318e6dcc1a0997af207ccde57" title="Overload of the tangent function for a ViennaMath runtime constant.">tan</a>(<a class="code" href="classviennamath_1_1ct__binary__expr.html" title="A compile time expression consisting of two operands and one operation (taking two arguments)...">ct_binary_expr&lt;LHS, OP, RHS&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00301"></a>00301   {
<a name="l00302"></a>00302     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(<span class="keyword">new</span> <a class="code" href="classviennamath_1_1rt__binary__expr.html" title="Runtime representation of a binary expression F(x,y), where F is a function of two argument (e...">rt_binary_expr&lt;&gt;</a>(other),
<a name="l00303"></a>00303                            <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary</a>&lt;<a class="code" href="structviennamath_1_1op__tan.html" title="Tangent function: x |--&amp;gt; tan(x).">op_tan&lt;default_numeric_type&gt;</a> &gt;()); 
<a name="l00304"></a>00304   }
<a name="l00305"></a>00305 
<a name="l00307"></a>00307   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> OP&gt;
<a name="l00308"></a><a class="code" href="namespaceviennamath.html#a12c45b179f539b54bf24141d4c10ad37">00308</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a> <a class="code" href="namespaceviennamath.html#a6466850318e6dcc1a0997af207ccde57" title="Overload of the tangent function for a ViennaMath runtime constant.">tan</a>(<a class="code" href="classviennamath_1_1ct__unary__expr.html" title="Defines a unary expression f(e), where f is function and &amp;#39;e&amp;#39; is an expression.">ct_unary_expr&lt;LHS, OP&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00309"></a>00309   {
<a name="l00310"></a>00310     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(<span class="keyword">new</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(other),
<a name="l00311"></a>00311                            <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary</a>&lt;<a class="code" href="structviennamath_1_1op__tan.html" title="Tangent function: x |--&amp;gt; tan(x).">op_tan&lt;default_numeric_type&gt;</a> &gt;()); 
<a name="l00312"></a>00312   }
<a name="l00313"></a>00313 
<a name="l00315"></a>00315   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00316"></a><a class="code" href="namespaceviennamath.html#ad62dadb75a7676cdb66e793783e27da5">00316</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#a6466850318e6dcc1a0997af207ccde57" title="Overload of the tangent function for a ViennaMath runtime constant.">tan</a>(<a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00317"></a>00317   {
<a name="l00318"></a>00318     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__unary__expr.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the unary expression. The caller is responsible for deleting the returned object...">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_tan&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00319"></a>00319   }
<a name="l00320"></a>00320 
<a name="l00322"></a>00322   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00323"></a><a class="code" href="namespaceviennamath.html#ad8126ebb56c187caf6a1ba56914a70e8">00323</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#a6466850318e6dcc1a0997af207ccde57" title="Overload of the tangent function for a ViennaMath runtime constant.">tan</a>(<a class="code" href="classviennamath_1_1rt__binary__expr.html" title="Runtime representation of a binary expression F(x,y), where F is a function of two argument (e...">rt_binary_expr&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00324"></a>00324   {
<a name="l00325"></a>00325     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__binary__expr.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the binary expression. The caller is responsible for deleting the returned object...">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_tan&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00326"></a>00326   }
<a name="l00327"></a>00327 
<a name="l00329"></a>00329   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00330"></a><a class="code" href="namespaceviennamath.html#a71505792183df693d76ff36342e9ac09">00330</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#a6466850318e6dcc1a0997af207ccde57" title="Overload of the tangent function for a ViennaMath runtime constant.">tan</a>(<a class="code" href="classviennamath_1_1rt__expr.html" title="This class represents a smart pointer to all types expressions.">rt_expr&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00331"></a>00331   {
<a name="l00332"></a>00332     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__expr.html#ae5d07bc2f397dcb72329c0c3ed9d99e5">get</a>()-&gt;clone(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_tan&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00333"></a>00333   }
<a name="l00334"></a>00334   
<a name="l00335"></a>00335 
<a name="l00336"></a>00336   <span class="comment">//</span>
<a name="l00337"></a>00337   <span class="comment">// absolute value</span>
<a name="l00338"></a>00338   <span class="comment">//</span>
<a name="l00340"></a>00340 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType, <span class="keyword">typename</span> NumericT&gt;
<a name="l00341"></a>00341   InterfaceType * <a class="code" href="namespaceviennamath.html#ab2aded2fd0a5e180147b4e571389ae0a" title="Implementation of the differentation of e1 + e1, where e1 and e2 are expressions.">diff_impl</a>(<span class="keyword">const</span> InterfaceType * e, op_fabs&lt;NumericT&gt;, <span class="keyword">const</span> InterfaceType * diff_var)
<a name="l00342"></a>00342   {
<a name="l00343"></a>00343     <span class="keywordflow">throw</span> expression_not_differentiable_exception(<span class="stringliteral">&quot;modulus operation not differentiable!&quot;</span>);
<a name="l00344"></a>00344     <span class="keywordflow">return</span> NULL;  <span class="comment">//TODO: Think about returning a piecewise function here?</span>
<a name="l00345"></a>00345   }
<a name="l00346"></a>00346 
<a name="l00348"></a>00348   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> InterfaceType&gt;
<a name="l00349"></a><a class="code" href="namespaceviennamath.html#aa3594f0a2c482ac86fd8ec8873d3c3e7">00349</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#aa3594f0a2c482ac86fd8ec8873d3c3e7" title="Overload of the modulus function for a ViennaMath runtime constant.">fabs</a>(<a class="code" href="classviennamath_1_1rt__constant.html" title="Representation of a constant within the expression setting of ViennaMath.">rt_constant&lt;NumericT, InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00350"></a>00350   {
<a name="l00351"></a>00351     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__constant.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the constant. The object referred by the pointer is not automatically deleted...">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_fabs&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00352"></a>00352   }
<a name="l00353"></a>00353 
<a name="l00355"></a>00355   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00356"></a><a class="code" href="namespaceviennamath.html#a2ede41bcefb44408201a88dbcbe0cfb2">00356</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#aa3594f0a2c482ac86fd8ec8873d3c3e7" title="Overload of the modulus function for a ViennaMath runtime constant.">fabs</a>(<a class="code" href="classviennamath_1_1rt__variable.html" title="Representation of an variable (a variable). If the supplied argument is some vector type...">rt_variable&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00357"></a>00357   {
<a name="l00358"></a>00358     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__variable.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the variable. The returned pointer is not automatically deleted, thus the caller needs to ensure deletion.">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_fabs&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00359"></a>00359   }
<a name="l00360"></a>00360 
<a name="l00362"></a>00362   <span class="keyword">template</span> &lt;<span class="keywordtype">id</span>_type <span class="keywordtype">id</span>&gt;
<a name="l00363"></a><a class="code" href="namespaceviennamath.html#a6f44a9f96dd780601ea180516815f502">00363</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a> <a class="code" href="namespaceviennamath.html#aa3594f0a2c482ac86fd8ec8873d3c3e7" title="Overload of the modulus function for a ViennaMath runtime constant.">fabs</a>(<a class="code" href="structviennamath_1_1ct__variable.html" title="Representation of a mathematical variable. If the supplied argument is some vector type...">ct_variable&lt;id&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00364"></a>00364   {
<a name="l00365"></a>00365     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(<span class="keyword">new</span> <a class="code" href="classviennamath_1_1rt__variable.html" title="Representation of an variable (a variable). If the supplied argument is some vector type...">rt_variable&lt;&gt;</a>(id), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary</a>&lt;<a class="code" href="structviennamath_1_1op__fabs.html" title="Modulus: x |--&amp;gt; |x|.">op_fabs&lt;default_numeric_type&gt;</a> &gt;()); 
<a name="l00366"></a>00366   }
<a name="l00367"></a>00367   
<a name="l00369"></a>00369   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> OP, <span class="keyword">typename</span> RHS&gt;
<a name="l00370"></a><a class="code" href="namespaceviennamath.html#ae076c0df57cbd72ce3bdfee7e6a7d213">00370</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a> <a class="code" href="namespaceviennamath.html#aa3594f0a2c482ac86fd8ec8873d3c3e7" title="Overload of the modulus function for a ViennaMath runtime constant.">fabs</a>(<a class="code" href="classviennamath_1_1ct__binary__expr.html" title="A compile time expression consisting of two operands and one operation (taking two arguments)...">ct_binary_expr&lt;LHS, OP, RHS&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00371"></a>00371   {
<a name="l00372"></a>00372     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(<span class="keyword">new</span> <a class="code" href="classviennamath_1_1rt__binary__expr.html" title="Runtime representation of a binary expression F(x,y), where F is a function of two argument (e...">rt_binary_expr&lt;&gt;</a>(other),
<a name="l00373"></a>00373                            <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary</a>&lt;<a class="code" href="structviennamath_1_1op__fabs.html" title="Modulus: x |--&amp;gt; |x|.">op_fabs&lt;default_numeric_type&gt;</a> &gt;()); 
<a name="l00374"></a>00374   }
<a name="l00375"></a>00375 
<a name="l00377"></a>00377   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> OP&gt;
<a name="l00378"></a><a class="code" href="namespaceviennamath.html#a7a237c3e4d8c86f74dedff3d35f20f4a">00378</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a> <a class="code" href="namespaceviennamath.html#aa3594f0a2c482ac86fd8ec8873d3c3e7" title="Overload of the modulus function for a ViennaMath runtime constant.">fabs</a>(<a class="code" href="classviennamath_1_1ct__unary__expr.html" title="Defines a unary expression f(e), where f is function and &amp;#39;e&amp;#39; is an expression.">ct_unary_expr&lt;LHS, OP&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00379"></a>00379   {
<a name="l00380"></a>00380     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(<span class="keyword">new</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(other),
<a name="l00381"></a>00381                            <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary</a>&lt;<a class="code" href="structviennamath_1_1op__fabs.html" title="Modulus: x |--&amp;gt; |x|.">op_fabs&lt;default_numeric_type&gt;</a> &gt;()); 
<a name="l00382"></a>00382   }
<a name="l00383"></a>00383 
<a name="l00384"></a>00384 
<a name="l00386"></a>00386   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00387"></a><a class="code" href="namespaceviennamath.html#a6a178d09db8cca450fb30c34e72d94e8">00387</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#aa3594f0a2c482ac86fd8ec8873d3c3e7" title="Overload of the modulus function for a ViennaMath runtime constant.">fabs</a>(<a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00388"></a>00388   {
<a name="l00389"></a>00389     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__unary__expr.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the unary expression. The caller is responsible for deleting the returned object...">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_fabs&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00390"></a>00390   }
<a name="l00391"></a>00391 
<a name="l00393"></a>00393   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00394"></a><a class="code" href="namespaceviennamath.html#afea99b6d77391cfb133b5453af718527">00394</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#aa3594f0a2c482ac86fd8ec8873d3c3e7" title="Overload of the modulus function for a ViennaMath runtime constant.">fabs</a>(<a class="code" href="classviennamath_1_1rt__binary__expr.html" title="Runtime representation of a binary expression F(x,y), where F is a function of two argument (e...">rt_binary_expr&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00395"></a>00395   {
<a name="l00396"></a>00396     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__binary__expr.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the binary expression. The caller is responsible for deleting the returned object...">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_fabs&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00397"></a>00397   }
<a name="l00398"></a>00398 
<a name="l00400"></a>00400   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00401"></a><a class="code" href="namespaceviennamath.html#a9b4616e8a2666125465ce772af757368">00401</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#aa3594f0a2c482ac86fd8ec8873d3c3e7" title="Overload of the modulus function for a ViennaMath runtime constant.">fabs</a>(<a class="code" href="classviennamath_1_1rt__expr.html" title="This class represents a smart pointer to all types expressions.">rt_expr&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00402"></a>00402   {
<a name="l00403"></a>00403     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__expr.html#ae5d07bc2f397dcb72329c0c3ed9d99e5">get</a>()-&gt;clone(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_fabs&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00404"></a>00404   }
<a name="l00405"></a>00405 
<a name="l00406"></a>00406 
<a name="l00407"></a>00407   <span class="comment">//</span>
<a name="l00408"></a>00408   <span class="comment">// square root</span>
<a name="l00409"></a>00409   <span class="comment">//</span>
<a name="l00411"></a>00411 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType, <span class="keyword">typename</span> NumericT&gt;
<a name="l00412"></a>00412   InterfaceType * <a class="code" href="namespaceviennamath.html#ab2aded2fd0a5e180147b4e571389ae0a" title="Implementation of the differentation of e1 + e1, where e1 and e2 are expressions.">diff_impl</a>(<span class="keyword">const</span> InterfaceType * e, op_sqrt&lt;NumericT&gt;, <span class="keyword">const</span> InterfaceType * diff_var)
<a name="l00413"></a>00413   {
<a name="l00414"></a>00414       <span class="keywordflow">return</span> <span class="keyword">new</span> rt_binary_expr&lt;InterfaceType&gt;( e-&gt;diff(diff_var),
<a name="l00415"></a>00415                                              <span class="keyword">new</span> op_binary&lt;op_div&lt;typename InterfaceType::numeric_type&gt;, InterfaceType&gt;(),
<a name="l00416"></a>00416                                              <span class="keyword">new</span> rt_binary_expr&lt;InterfaceType&gt;( <span class="keyword">new</span> rt_constant&lt;NumericT&gt;(2),
<a name="l00417"></a>00417                                                                              <span class="keyword">new</span> op_binary&lt;op_mult&lt;typename InterfaceType::numeric_type&gt;, InterfaceType&gt;(),
<a name="l00418"></a>00418                                                                              <span class="keyword">new</span> rt_unary_expr&lt;InterfaceType&gt;(e-&gt;clone(),
<a name="l00419"></a>00419                                                                                                            <span class="keyword">new</span> op_unary&lt;op_sqrt&lt;NumericT&gt;, InterfaceType&gt;())
<a name="l00420"></a>00420                                                                            )
<a name="l00421"></a>00421                                             );
<a name="l00422"></a>00422   }
<a name="l00423"></a>00423 
<a name="l00425"></a>00425   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> InterfaceType&gt;
<a name="l00426"></a><a class="code" href="namespaceviennamath.html#abfaab8e3dea4888fe01c6bd8e125431a">00426</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#abfaab8e3dea4888fe01c6bd8e125431a" title="Overload of the square-root function for a ViennaMath runtime constant.">sqrt</a>(<a class="code" href="classviennamath_1_1rt__constant.html" title="Representation of a constant within the expression setting of ViennaMath.">rt_constant&lt;NumericT, InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00427"></a>00427   {
<a name="l00428"></a>00428     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__constant.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the constant. The object referred by the pointer is not automatically deleted...">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_sqrt&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00429"></a>00429   }
<a name="l00430"></a>00430 
<a name="l00432"></a>00432   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00433"></a><a class="code" href="namespaceviennamath.html#a169cd852af6f99d1fafc6a02f872a69e">00433</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#abfaab8e3dea4888fe01c6bd8e125431a" title="Overload of the square-root function for a ViennaMath runtime constant.">sqrt</a>(<a class="code" href="classviennamath_1_1rt__variable.html" title="Representation of an variable (a variable). If the supplied argument is some vector type...">rt_variable&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00434"></a>00434   {
<a name="l00435"></a>00435     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__variable.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the variable. The returned pointer is not automatically deleted, thus the caller needs to ensure deletion.">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_sqrt&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00436"></a>00436   }
<a name="l00437"></a>00437 
<a name="l00439"></a>00439   <span class="keyword">template</span> &lt;<span class="keywordtype">id</span>_type <span class="keywordtype">id</span>&gt;
<a name="l00440"></a><a class="code" href="namespaceviennamath.html#a7a77c13989060743c6446ce7253d08f7">00440</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a> <a class="code" href="namespaceviennamath.html#abfaab8e3dea4888fe01c6bd8e125431a" title="Overload of the square-root function for a ViennaMath runtime constant.">sqrt</a>(<a class="code" href="structviennamath_1_1ct__variable.html" title="Representation of a mathematical variable. If the supplied argument is some vector type...">ct_variable&lt;id&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00441"></a>00441   {
<a name="l00442"></a>00442     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(<span class="keyword">new</span> <a class="code" href="classviennamath_1_1rt__variable.html" title="Representation of an variable (a variable). If the supplied argument is some vector type...">rt_variable&lt;&gt;</a>(id), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary</a>&lt;<a class="code" href="structviennamath_1_1op__sqrt.html" title="Square root: x |--&amp;gt; \sqrt{x}.">op_sqrt&lt;default_numeric_type&gt;</a> &gt;()); 
<a name="l00443"></a>00443   }
<a name="l00444"></a>00444   
<a name="l00446"></a>00446   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> OP, <span class="keyword">typename</span> RHS&gt;
<a name="l00447"></a><a class="code" href="namespaceviennamath.html#a36e1fb9ed0568a4913278d3456a28a37">00447</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a> <a class="code" href="namespaceviennamath.html#abfaab8e3dea4888fe01c6bd8e125431a" title="Overload of the square-root function for a ViennaMath runtime constant.">sqrt</a>(<a class="code" href="classviennamath_1_1ct__binary__expr.html" title="A compile time expression consisting of two operands and one operation (taking two arguments)...">ct_binary_expr&lt;LHS, OP, RHS&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00448"></a>00448   {
<a name="l00449"></a>00449     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(<span class="keyword">new</span> <a class="code" href="classviennamath_1_1rt__binary__expr.html" title="Runtime representation of a binary expression F(x,y), where F is a function of two argument (e...">rt_binary_expr&lt;&gt;</a>(other),
<a name="l00450"></a>00450                            <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary</a>&lt;<a class="code" href="structviennamath_1_1op__sqrt.html" title="Square root: x |--&amp;gt; \sqrt{x}.">op_sqrt&lt;default_numeric_type&gt;</a> &gt;()); 
<a name="l00451"></a>00451   }
<a name="l00452"></a>00452 
<a name="l00454"></a>00454   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> OP&gt;
<a name="l00455"></a><a class="code" href="namespaceviennamath.html#a465666c605b600b20acc607b4754abf8">00455</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a> <a class="code" href="namespaceviennamath.html#abfaab8e3dea4888fe01c6bd8e125431a" title="Overload of the square-root function for a ViennaMath runtime constant.">sqrt</a>(<a class="code" href="classviennamath_1_1ct__unary__expr.html" title="Defines a unary expression f(e), where f is function and &amp;#39;e&amp;#39; is an expression.">ct_unary_expr&lt;LHS, OP&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00456"></a>00456   {
<a name="l00457"></a>00457     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(<span class="keyword">new</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(other),
<a name="l00458"></a>00458                            <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary</a>&lt;<a class="code" href="structviennamath_1_1op__sqrt.html" title="Square root: x |--&amp;gt; \sqrt{x}.">op_sqrt&lt;default_numeric_type&gt;</a> &gt;()); 
<a name="l00459"></a>00459   }
<a name="l00460"></a>00460 
<a name="l00461"></a>00461 
<a name="l00463"></a>00463   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00464"></a><a class="code" href="namespaceviennamath.html#a133ebc258c5eb5062eed77b6b872e784">00464</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#abfaab8e3dea4888fe01c6bd8e125431a" title="Overload of the square-root function for a ViennaMath runtime constant.">sqrt</a>(<a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00465"></a>00465   {
<a name="l00466"></a>00466     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__unary__expr.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the unary expression. The caller is responsible for deleting the returned object...">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_sqrt&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00467"></a>00467   }
<a name="l00468"></a>00468 
<a name="l00470"></a>00470   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00471"></a><a class="code" href="namespaceviennamath.html#a30f229ea98616d7ef9f0497564119b84">00471</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#abfaab8e3dea4888fe01c6bd8e125431a" title="Overload of the square-root function for a ViennaMath runtime constant.">sqrt</a>(<a class="code" href="classviennamath_1_1rt__binary__expr.html" title="Runtime representation of a binary expression F(x,y), where F is a function of two argument (e...">rt_binary_expr&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00472"></a>00472   {
<a name="l00473"></a>00473     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__binary__expr.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the binary expression. The caller is responsible for deleting the returned object...">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_sqrt&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00474"></a>00474   }
<a name="l00475"></a>00475 
<a name="l00477"></a>00477   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00478"></a><a class="code" href="namespaceviennamath.html#a5ae7b8f5fb1d62a122860950bd34838e">00478</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#abfaab8e3dea4888fe01c6bd8e125431a" title="Overload of the square-root function for a ViennaMath runtime constant.">sqrt</a>(<a class="code" href="classviennamath_1_1rt__expr.html" title="This class represents a smart pointer to all types expressions.">rt_expr&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00479"></a>00479   {
<a name="l00480"></a>00480     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__expr.html#ae5d07bc2f397dcb72329c0c3ed9d99e5">get</a>()-&gt;clone(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_sqrt&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00481"></a>00481   }
<a name="l00482"></a>00482   
<a name="l00483"></a>00483   <span class="comment">//</span>
<a name="l00484"></a>00484   <span class="comment">// natural logarithm (aka ln())</span>
<a name="l00485"></a>00485   <span class="comment">//</span>
<a name="l00487"></a>00487 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType, <span class="keyword">typename</span> NumericT&gt;
<a name="l00488"></a>00488   InterfaceType * <a class="code" href="namespaceviennamath.html#ab2aded2fd0a5e180147b4e571389ae0a" title="Implementation of the differentation of e1 + e1, where e1 and e2 are expressions.">diff_impl</a>(<span class="keyword">const</span> InterfaceType * e, op_log&lt;NumericT&gt;, <span class="keyword">const</span> InterfaceType * diff_var)
<a name="l00489"></a>00489   {
<a name="l00490"></a>00490     <span class="keywordflow">return</span> <span class="keyword">new</span> rt_binary_expr&lt;InterfaceType&gt;( e-&gt;diff(diff_var),
<a name="l00491"></a>00491                                            <span class="keyword">new</span> op_binary&lt;op_div&lt;typename InterfaceType::numeric_type&gt;, InterfaceType&gt;(),
<a name="l00492"></a>00492                                            <span class="keyword">new</span> rt_unary_expr&lt;InterfaceType&gt;(e-&gt;clone())
<a name="l00493"></a>00493                                          );
<a name="l00494"></a>00494   }  
<a name="l00495"></a>00495 
<a name="l00497"></a>00497   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> InterfaceType&gt;
<a name="l00498"></a><a class="code" href="namespaceviennamath.html#aeb237d8f5686e7cddc50e8b2dc5a703e">00498</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#aeb237d8f5686e7cddc50e8b2dc5a703e" title="Overload of the natural logarithm function for a ViennaMath runtime constant.">log</a>(<a class="code" href="classviennamath_1_1rt__constant.html" title="Representation of a constant within the expression setting of ViennaMath.">rt_constant&lt;NumericT, InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00499"></a>00499   {
<a name="l00500"></a>00500     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__constant.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the constant. The object referred by the pointer is not automatically deleted...">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_log&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00501"></a>00501   }
<a name="l00502"></a>00502 
<a name="l00504"></a>00504   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00505"></a><a class="code" href="namespaceviennamath.html#a0ecd5f1586131782887cb1347a728eb0">00505</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#aeb237d8f5686e7cddc50e8b2dc5a703e" title="Overload of the natural logarithm function for a ViennaMath runtime constant.">log</a>(<a class="code" href="classviennamath_1_1rt__variable.html" title="Representation of an variable (a variable). If the supplied argument is some vector type...">rt_variable&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00506"></a>00506   {
<a name="l00507"></a>00507     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__variable.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the variable. The returned pointer is not automatically deleted, thus the caller needs to ensure deletion.">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_log&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00508"></a>00508   }
<a name="l00509"></a>00509 
<a name="l00511"></a>00511   <span class="keyword">template</span> &lt;<span class="keywordtype">id</span>_type <span class="keywordtype">id</span>&gt;
<a name="l00512"></a><a class="code" href="namespaceviennamath.html#a3e37b0e91fcd0ea5b307e4288a247aa4">00512</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a> <a class="code" href="namespaceviennamath.html#aeb237d8f5686e7cddc50e8b2dc5a703e" title="Overload of the natural logarithm function for a ViennaMath runtime constant.">log</a>(<a class="code" href="structviennamath_1_1ct__variable.html" title="Representation of a mathematical variable. If the supplied argument is some vector type...">ct_variable&lt;id&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00513"></a>00513   {
<a name="l00514"></a>00514     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(<span class="keyword">new</span> <a class="code" href="classviennamath_1_1rt__variable.html" title="Representation of an variable (a variable). If the supplied argument is some vector type...">rt_variable&lt;&gt;</a>(id), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary</a>&lt;<a class="code" href="structviennamath_1_1op__log.html" title="Natural logarithm function: x |--&amp;gt; ln(x).">op_log&lt;default_numeric_type&gt;</a> &gt;()); 
<a name="l00515"></a>00515   }
<a name="l00516"></a>00516   
<a name="l00518"></a>00518   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> OP, <span class="keyword">typename</span> RHS&gt;
<a name="l00519"></a><a class="code" href="namespaceviennamath.html#ad0422a93d2137caa7872f0be7a5a897c">00519</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a> <a class="code" href="namespaceviennamath.html#aeb237d8f5686e7cddc50e8b2dc5a703e" title="Overload of the natural logarithm function for a ViennaMath runtime constant.">log</a>(<a class="code" href="classviennamath_1_1ct__binary__expr.html" title="A compile time expression consisting of two operands and one operation (taking two arguments)...">ct_binary_expr&lt;LHS, OP, RHS&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00520"></a>00520   {
<a name="l00521"></a>00521     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(<span class="keyword">new</span> <a class="code" href="classviennamath_1_1rt__binary__expr.html" title="Runtime representation of a binary expression F(x,y), where F is a function of two argument (e...">rt_binary_expr&lt;&gt;</a>(other),
<a name="l00522"></a>00522                            <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary</a>&lt;<a class="code" href="structviennamath_1_1op__log.html" title="Natural logarithm function: x |--&amp;gt; ln(x).">op_log&lt;default_numeric_type&gt;</a> &gt;()); 
<a name="l00523"></a>00523   }
<a name="l00524"></a>00524 
<a name="l00526"></a>00526   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> OP&gt;
<a name="l00527"></a><a class="code" href="namespaceviennamath.html#a6e05131933e69d2974eb42c47908623d">00527</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a> <a class="code" href="namespaceviennamath.html#aeb237d8f5686e7cddc50e8b2dc5a703e" title="Overload of the natural logarithm function for a ViennaMath runtime constant.">log</a>(<a class="code" href="classviennamath_1_1ct__unary__expr.html" title="Defines a unary expression f(e), where f is function and &amp;#39;e&amp;#39; is an expression.">ct_unary_expr&lt;LHS, OP&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00528"></a>00528   {
<a name="l00529"></a>00529     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(<span class="keyword">new</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(other),
<a name="l00530"></a>00530                            <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary</a>&lt;<a class="code" href="structviennamath_1_1op__log.html" title="Natural logarithm function: x |--&amp;gt; ln(x).">op_log&lt;default_numeric_type&gt;</a> &gt;()); 
<a name="l00531"></a>00531   }
<a name="l00532"></a>00532 
<a name="l00534"></a>00534   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00535"></a><a class="code" href="namespaceviennamath.html#a93c8877c03a3a06b30c9204dd0d13e8e">00535</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#aeb237d8f5686e7cddc50e8b2dc5a703e" title="Overload of the natural logarithm function for a ViennaMath runtime constant.">log</a>(<a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00536"></a>00536   {
<a name="l00537"></a>00537     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__unary__expr.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the unary expression. The caller is responsible for deleting the returned object...">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_log&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00538"></a>00538   }
<a name="l00539"></a>00539 
<a name="l00541"></a>00541   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00542"></a><a class="code" href="namespaceviennamath.html#a63888ee558eaa93fd56a110b907f5669">00542</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#aeb237d8f5686e7cddc50e8b2dc5a703e" title="Overload of the natural logarithm function for a ViennaMath runtime constant.">log</a>(<a class="code" href="classviennamath_1_1rt__binary__expr.html" title="Runtime representation of a binary expression F(x,y), where F is a function of two argument (e...">rt_binary_expr&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00543"></a>00543   {
<a name="l00544"></a>00544     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__binary__expr.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the binary expression. The caller is responsible for deleting the returned object...">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_log&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00545"></a>00545   }
<a name="l00546"></a>00546 
<a name="l00548"></a>00548   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00549"></a><a class="code" href="namespaceviennamath.html#a34927e53ac2ea16e6a43d6e2fa71c808">00549</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#aeb237d8f5686e7cddc50e8b2dc5a703e" title="Overload of the natural logarithm function for a ViennaMath runtime constant.">log</a>(<a class="code" href="classviennamath_1_1rt__expr.html" title="This class represents a smart pointer to all types expressions.">rt_expr&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00550"></a>00550   {
<a name="l00551"></a>00551     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__expr.html#ae5d07bc2f397dcb72329c0c3ed9d99e5">get</a>()-&gt;clone(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_log&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00552"></a>00552   }
<a name="l00553"></a>00553   
<a name="l00554"></a>00554   
<a name="l00555"></a>00555   <span class="comment">//</span>
<a name="l00556"></a>00556   <span class="comment">// logarithm, base 10</span>
<a name="l00557"></a>00557   <span class="comment">//</span>
<a name="l00558"></a>00558   
<a name="l00559"></a>00559   <span class="comment">// </span>
<a name="l00564"></a>00564 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType, <span class="keyword">typename</span> NumericT&gt;
<a name="l00565"></a>00565   InterfaceType * <a class="code" href="namespaceviennamath.html#ab2aded2fd0a5e180147b4e571389ae0a" title="Implementation of the differentation of e1 + e1, where e1 and e2 are expressions.">diff_impl</a>(<span class="keyword">const</span> InterfaceType * e, op_log10&lt;NumericT&gt;, <span class="keyword">const</span> InterfaceType * diff_var)
<a name="l00566"></a>00566   {
<a name="l00567"></a>00567     <span class="keywordflow">return</span> <span class="keyword">new</span> rt_binary_expr&lt;InterfaceType&gt;( e-&gt;diff(diff_var),
<a name="l00568"></a>00568                                            <span class="keyword">new</span> op_binary&lt;op_div&lt;typename InterfaceType::numeric_type&gt;, InterfaceType&gt;(),
<a name="l00569"></a>00569                                            <span class="keyword">new</span> rt_binary_expr&lt;InterfaceType&gt;( <span class="keyword">new</span> rt_constant&lt;NumericT, InterfaceType&gt;( ::<a class="code" href="namespaceviennamath.html#aeb237d8f5686e7cddc50e8b2dc5a703e" title="Overload of the natural logarithm function for a ViennaMath runtime constant.">log</a>(10.0) ),
<a name="l00570"></a>00570                                                                            <span class="keyword">new</span> op_binary&lt;op_mult&lt;typename InterfaceType::numeric_type&gt;, InterfaceType&gt;(),
<a name="l00571"></a>00571                                                                            <span class="keyword">new</span> rt_unary_expr&lt;InterfaceType&gt;(e-&gt;clone())
<a name="l00572"></a>00572                                                                          )
<a name="l00573"></a>00573                                           );
<a name="l00574"></a>00574   }  
<a name="l00575"></a>00575 
<a name="l00577"></a>00577   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT, <span class="keyword">typename</span> InterfaceType&gt;
<a name="l00578"></a><a class="code" href="namespaceviennamath.html#ae4f69733aee4b9fc4265d02db6b5b7d1">00578</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#ae4f69733aee4b9fc4265d02db6b5b7d1" title="Overload of the logarithm with base 10 for a ViennaMath runtime constant.">log10</a>(<a class="code" href="classviennamath_1_1rt__constant.html" title="Representation of a constant within the expression setting of ViennaMath.">rt_constant&lt;NumericT, InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00579"></a>00579   {
<a name="l00580"></a>00580     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__constant.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the constant. The object referred by the pointer is not automatically deleted...">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_log10&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00581"></a>00581   }
<a name="l00582"></a>00582 
<a name="l00584"></a>00584   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00585"></a><a class="code" href="namespaceviennamath.html#a7e22a44799aa61baa2fa262f1a0045b8">00585</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#ae4f69733aee4b9fc4265d02db6b5b7d1" title="Overload of the logarithm with base 10 for a ViennaMath runtime constant.">log10</a>(<a class="code" href="classviennamath_1_1rt__variable.html" title="Representation of an variable (a variable). If the supplied argument is some vector type...">rt_variable&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00586"></a>00586   {
<a name="l00587"></a>00587     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__variable.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the variable. The returned pointer is not automatically deleted, thus the caller needs to ensure deletion.">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_log10&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00588"></a>00588   }
<a name="l00589"></a>00589 
<a name="l00591"></a>00591   <span class="keyword">template</span> &lt;<span class="keywordtype">id</span>_type <span class="keywordtype">id</span>&gt;
<a name="l00592"></a><a class="code" href="namespaceviennamath.html#a587bd0314a06e67fec06cc8330458c5f">00592</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a> <a class="code" href="namespaceviennamath.html#ae4f69733aee4b9fc4265d02db6b5b7d1" title="Overload of the logarithm with base 10 for a ViennaMath runtime constant.">log10</a>(<a class="code" href="structviennamath_1_1ct__variable.html" title="Representation of a mathematical variable. If the supplied argument is some vector type...">ct_variable&lt;id&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00593"></a>00593   {
<a name="l00594"></a>00594     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(<span class="keyword">new</span> <a class="code" href="classviennamath_1_1rt__variable.html" title="Representation of an variable (a variable). If the supplied argument is some vector type...">rt_variable&lt;&gt;</a>(id), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary</a>&lt;<a class="code" href="structviennamath_1_1op__log10.html" title="Logarithm with base 10: x |--&amp;gt; \log_{10}(x).">op_log10&lt;default_numeric_type&gt;</a> &gt;()); 
<a name="l00595"></a>00595   }
<a name="l00596"></a>00596   
<a name="l00598"></a>00598   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> OP, <span class="keyword">typename</span> RHS&gt;
<a name="l00599"></a><a class="code" href="namespaceviennamath.html#a5e79b5affd916aef44eb91595e9fe023">00599</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a> <a class="code" href="namespaceviennamath.html#ae4f69733aee4b9fc4265d02db6b5b7d1" title="Overload of the logarithm with base 10 for a ViennaMath runtime constant.">log10</a>(<a class="code" href="classviennamath_1_1ct__binary__expr.html" title="A compile time expression consisting of two operands and one operation (taking two arguments)...">ct_binary_expr&lt;LHS, OP, RHS&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00600"></a>00600   {
<a name="l00601"></a>00601     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(<span class="keyword">new</span> <a class="code" href="classviennamath_1_1rt__binary__expr.html" title="Runtime representation of a binary expression F(x,y), where F is a function of two argument (e...">rt_binary_expr&lt;&gt;</a>(other),
<a name="l00602"></a>00602                            <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary</a>&lt;<a class="code" href="structviennamath_1_1op__log10.html" title="Logarithm with base 10: x |--&amp;gt; \log_{10}(x).">op_log10&lt;default_numeric_type&gt;</a> &gt;()); 
<a name="l00603"></a>00603   }
<a name="l00604"></a>00604 
<a name="l00606"></a>00606   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> OP&gt;
<a name="l00607"></a><a class="code" href="namespaceviennamath.html#a555f9270711b945f99226b3b7da95841">00607</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a> <a class="code" href="namespaceviennamath.html#ae4f69733aee4b9fc4265d02db6b5b7d1" title="Overload of the logarithm with base 10 for a ViennaMath runtime constant.">log10</a>(<a class="code" href="classviennamath_1_1ct__unary__expr.html" title="Defines a unary expression f(e), where f is function and &amp;#39;e&amp;#39; is an expression.">ct_unary_expr&lt;LHS, OP&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00608"></a>00608   {
<a name="l00609"></a>00609     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(<span class="keyword">new</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>(other),
<a name="l00610"></a>00610                            <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary</a>&lt;<a class="code" href="structviennamath_1_1op__log10.html" title="Logarithm with base 10: x |--&amp;gt; \log_{10}(x).">op_log10&lt;default_numeric_type&gt;</a> &gt;()); 
<a name="l00611"></a>00611   }
<a name="l00612"></a>00612 
<a name="l00614"></a>00614   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00615"></a><a class="code" href="namespaceviennamath.html#a214c73b75ed19e2123fb6d5f48ffa31a">00615</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#ae4f69733aee4b9fc4265d02db6b5b7d1" title="Overload of the logarithm with base 10 for a ViennaMath runtime constant.">log10</a>(<a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00616"></a>00616   {
<a name="l00617"></a>00617     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__unary__expr.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the unary expression. The caller is responsible for deleting the returned object...">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_log10&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00618"></a>00618   }
<a name="l00619"></a>00619 
<a name="l00621"></a>00621   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00622"></a><a class="code" href="namespaceviennamath.html#abba554e4ced71245733157ae0aa09a53">00622</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#ae4f69733aee4b9fc4265d02db6b5b7d1" title="Overload of the logarithm with base 10 for a ViennaMath runtime constant.">log10</a>(<a class="code" href="classviennamath_1_1rt__binary__expr.html" title="Runtime representation of a binary expression F(x,y), where F is a function of two argument (e...">rt_binary_expr&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00623"></a>00623   {
<a name="l00624"></a>00624     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__binary__expr.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the binary expression. The caller is responsible for deleting the returned object...">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_log10&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00625"></a>00625   }
<a name="l00626"></a>00626 
<a name="l00628"></a>00628   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00629"></a><a class="code" href="namespaceviennamath.html#ab0ec9dd80d7522b20ade837e4b181e20">00629</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#ae4f69733aee4b9fc4265d02db6b5b7d1" title="Overload of the logarithm with base 10 for a ViennaMath runtime constant.">log10</a>(<a class="code" href="classviennamath_1_1rt__expr.html" title="This class represents a smart pointer to all types expressions.">rt_expr&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00630"></a>00630   {
<a name="l00631"></a>00631     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__expr.html#ae5d07bc2f397dcb72329c0c3ed9d99e5">get</a>()-&gt;clone(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_log10&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00632"></a>00632   }
<a name="l00633"></a>00633   
<a name="l00634"></a>00634   
<a name="l00636"></a>00636 
<a name="l00637"></a>00637   <span class="comment">//</span>
<a name="l00638"></a>00638   <span class="comment">// gradient</span>
<a name="l00639"></a>00639   <span class="comment">//</span>
<a name="l00641"></a>00641 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType, <span class="keyword">typename</span> NumericT&gt;
<a name="l00642"></a><a class="code" href="namespaceviennamath.html#a1f335a870411768416d7711e16b11c30">00642</a>   InterfaceType * <a class="code" href="namespaceviennamath.html#ab2aded2fd0a5e180147b4e571389ae0a" title="Implementation of the differentation of e1 + e1, where e1 and e2 are expressions.">diff_impl</a>(<span class="keyword">const</span> InterfaceType * e, <a class="code" href="structviennamath_1_1op__gradient.html" title="Gradient operator: f |--&amp;gt; grad(x).">op_gradient&lt;NumericT&gt;</a>, <span class="keyword">const</span> InterfaceType * diff_var)
<a name="l00643"></a>00643   {
<a name="l00644"></a>00644     <span class="keywordflow">throw</span> <a class="code" href="classviennamath_1_1expression__not__differentiable__exception.html" title="An exception which is thrown if an expression should be differentiated, but at least one of the leave...">expression_not_differentiable_exception</a>(<span class="stringliteral">&quot;Cannot differentiate gradient operator!&quot;</span>);
<a name="l00645"></a>00645     <span class="keywordflow">return</span> NULL;
<a name="l00646"></a>00646   }  
<a name="l00647"></a>00647   
<a name="l00649"></a>00649   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00650"></a><a class="code" href="namespaceviennamath.html#a77e82fadba1cd6372147e8ae28082908">00650</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#a77e82fadba1cd6372147e8ae28082908" title="Overload of the gradient function for a ViennaMath runtime function symbol.">grad</a>(<a class="code" href="classviennamath_1_1rt__function__symbol.html" title="A function symbol. Can be used for unknown functions, test functions, etc. Cannot be evaluated...">rt_function_symbol&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00651"></a>00651   {
<a name="l00652"></a>00652     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__function__symbol.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the function symbol. The caller needs to ensure that the object the pointer is refe...">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_gradient&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00653"></a>00653   }
<a name="l00654"></a>00654 
<a name="l00656"></a>00656   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00657"></a><a class="code" href="namespaceviennamath.html#aa7a9cb779ba7c6e763d1a94cb3d04111">00657</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#a77e82fadba1cd6372147e8ae28082908" title="Overload of the gradient function for a ViennaMath runtime function symbol.">grad</a>(<a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00658"></a>00658   {
<a name="l00659"></a>00659     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__unary__expr.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the unary expression. The caller is responsible for deleting the returned object...">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_gradient&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00660"></a>00660   }
<a name="l00661"></a>00661 
<a name="l00662"></a>00662 
<a name="l00663"></a>00663   <span class="comment">//</span>
<a name="l00664"></a>00664   <span class="comment">// divergence </span>
<a name="l00665"></a>00665   <span class="comment">//</span>
<a name="l00667"></a>00667 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType, <span class="keyword">typename</span> NumericT&gt;
<a name="l00668"></a><a class="code" href="namespaceviennamath.html#aad557e872cac4a1385b7e6317f2bbc02">00668</a>   InterfaceType * <a class="code" href="namespaceviennamath.html#ab2aded2fd0a5e180147b4e571389ae0a" title="Implementation of the differentation of e1 + e1, where e1 and e2 are expressions.">diff_impl</a>(<span class="keyword">const</span> InterfaceType * e, <a class="code" href="structviennamath_1_1op__divergence.html" title="Divergence operator: f |--&amp;gt; div(f).">op_divergence&lt;NumericT&gt;</a>, <span class="keyword">const</span> InterfaceType * diff_var)
<a name="l00669"></a>00669   {
<a name="l00670"></a>00670     <span class="keywordflow">throw</span> <a class="code" href="classviennamath_1_1expression__not__differentiable__exception.html" title="An exception which is thrown if an expression should be differentiated, but at least one of the leave...">expression_not_differentiable_exception</a>(<span class="stringliteral">&quot;Cannot differentiate divergence operator!&quot;</span>);
<a name="l00671"></a>00671     <span class="keywordflow">return</span> NULL;
<a name="l00672"></a>00672   }  
<a name="l00673"></a>00673   
<a name="l00675"></a>00675   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00676"></a><a class="code" href="namespaceviennamath.html#a7aae8ad176b5963f7f09ca1316ee93e5">00676</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#a7aae8ad176b5963f7f09ca1316ee93e5" title="Overload of the divergence function for a ViennaMath runtime expression wrapper.">div</a>(<a class="code" href="classviennamath_1_1rt__expr.html" title="This class represents a smart pointer to all types expressions.">rt_expr&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00677"></a>00677   {
<a name="l00678"></a>00678     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__expr.html#ae5d07bc2f397dcb72329c0c3ed9d99e5">get</a>()-&gt;clone(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_divergence&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00679"></a>00679   }
<a name="l00680"></a>00680 
<a name="l00682"></a>00682   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00683"></a><a class="code" href="namespaceviennamath.html#a77d3b61ee7c51c9915eb9725acb977e5">00683</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#a7aae8ad176b5963f7f09ca1316ee93e5" title="Overload of the divergence function for a ViennaMath runtime expression wrapper.">div</a>(<a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00684"></a>00684   {
<a name="l00685"></a>00685     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__unary__expr.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the unary expression. The caller is responsible for deleting the returned object...">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_divergence&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00686"></a>00686   }
<a name="l00687"></a>00687 
<a name="l00689"></a>00689   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00690"></a><a class="code" href="namespaceviennamath.html#a3a7ffb1808fe0426557b7e89b8e2affc">00690</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#a7aae8ad176b5963f7f09ca1316ee93e5" title="Overload of the divergence function for a ViennaMath runtime expression wrapper.">div</a>(<a class="code" href="classviennamath_1_1rt__binary__expr.html" title="Runtime representation of a binary expression F(x,y), where F is a function of two argument (e...">rt_binary_expr&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00691"></a>00691   {
<a name="l00692"></a>00692     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__binary__expr.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the binary expression. The caller is responsible for deleting the returned object...">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_divergence&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00693"></a>00693   }
<a name="l00694"></a>00694   
<a name="l00696"></a>00696   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00697"></a><a class="code" href="namespaceviennamath.html#aa2c45c85d6f6c3b49926444879bb2655">00697</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#a7aae8ad176b5963f7f09ca1316ee93e5" title="Overload of the divergence function for a ViennaMath runtime expression wrapper.">div</a>(<a class="code" href="classviennamath_1_1rt__function__symbol.html" title="A function symbol. Can be used for unknown functions, test functions, etc. Cannot be evaluated...">rt_function_symbol&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00698"></a>00698   {
<a name="l00699"></a>00699     <span class="keywordflow">return</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a>(other.<a class="code" href="classviennamath_1_1rt__function__symbol.html#a0435646b1c18de1b989a2a77dcb2d616" title="Returns a copy of the function symbol. The caller needs to ensure that the object the pointer is refe...">clone</a>(), <span class="keyword">new</span> <a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary&lt;op_divergence&lt;typename InterfaceType::numeric_type&gt;</a>, InterfaceType&gt;()); 
<a name="l00700"></a>00700   }
<a name="l00701"></a>00701   
<a name="l00702"></a>00702   
<a name="l00703"></a>00703   
<a name="l00704"></a>00704   <span class="comment">//  </span>
<a name="l00705"></a>00705   <span class="comment">// Convenience Function: Laplace operator</span>
<a name="l00706"></a>00706   <span class="comment">//</span>
<a name="l00708"></a>00708 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00709"></a><a class="code" href="namespaceviennamath.html#a0c217094f61fa562b2f38d8d31bd236b">00709</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#a0c217094f61fa562b2f38d8d31bd236b" title="For convenience, the Laplace operator (divergence of the gradient) is provided as a separate function...">laplace</a>(<a class="code" href="classviennamath_1_1rt__expr.html" title="This class represents a smart pointer to all types expressions.">rt_expr&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00710"></a>00710   {
<a name="l00711"></a>00711     <span class="keywordflow">return</span> <a class="code" href="namespaceviennamath.html#a7aae8ad176b5963f7f09ca1316ee93e5" title="Overload of the divergence function for a ViennaMath runtime expression wrapper.">div</a>(<a class="code" href="namespaceviennamath.html#a77e82fadba1cd6372147e8ae28082908" title="Overload of the gradient function for a ViennaMath runtime function symbol.">grad</a>(other));
<a name="l00712"></a>00712   }
<a name="l00713"></a>00713   
<a name="l00715"></a>00715   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00716"></a><a class="code" href="namespaceviennamath.html#ad2b1b2c5a42ce2ff90216898f1c09697">00716</a>   <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;InterfaceType&gt;</a> <a class="code" href="namespaceviennamath.html#a0c217094f61fa562b2f38d8d31bd236b" title="For convenience, the Laplace operator (divergence of the gradient) is provided as a separate function...">laplace</a>(<a class="code" href="classviennamath_1_1rt__function__symbol.html" title="A function symbol. Can be used for unknown functions, test functions, etc. Cannot be evaluated...">rt_function_symbol&lt;InterfaceType&gt;</a> <span class="keyword">const</span> &amp; other)
<a name="l00717"></a>00717   {
<a name="l00718"></a>00718     <span class="keywordflow">return</span> <a class="code" href="namespaceviennamath.html#a7aae8ad176b5963f7f09ca1316ee93e5" title="Overload of the divergence function for a ViennaMath runtime expression wrapper.">div</a>(<a class="code" href="namespaceviennamath.html#a77e82fadba1cd6372147e8ae28082908" title="Overload of the gradient function for a ViennaMath runtime function symbol.">grad</a>(other));
<a name="l00719"></a>00719   }
<a name="l00720"></a>00720 
<a name="l00721"></a>00721 
<a name="l00722"></a>00722   <span class="comment">//</span>
<a name="l00723"></a>00723   <span class="comment">// partial derivative with respect to variable&lt;id&gt;:</span>
<a name="l00724"></a>00724   <span class="comment">//</span>
<a name="l00726"></a>00726 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType, <span class="keyword">typename</span> NumericT&gt;
<a name="l00727"></a><a class="code" href="namespaceviennamath.html#aa51eddfe0bc23018878703f5e5d0f622">00727</a>   InterfaceType * <a class="code" href="namespaceviennamath.html#ab2aded2fd0a5e180147b4e571389ae0a" title="Implementation of the differentation of e1 + e1, where e1 and e2 are expressions.">diff_impl</a>(<span class="keyword">const</span> InterfaceType * e, <a class="code" href="classviennamath_1_1op__partial__deriv.html" title="Divergence operator: f |--&amp;gt; d f / (d x_i).">op_partial_deriv&lt;NumericT&gt;</a>, <span class="keyword">const</span> InterfaceType * diff_var)
<a name="l00728"></a>00728   {
<a name="l00729"></a>00729     <span class="keywordflow">throw</span> <a class="code" href="classviennamath_1_1expression__not__differentiable__exception.html" title="An exception which is thrown if an expression should be differentiated, but at least one of the leave...">expression_not_differentiable_exception</a>(<span class="stringliteral">&quot;Cannot evaluate formal partial derivative. Use transformations first.&quot;</span>);
<a name="l00730"></a>00730     <span class="keywordflow">return</span> NULL;
<a name="l00731"></a>00731   }  
<a name="l00732"></a>00732   
<a name="l00733"></a>00733   <span class="comment">//</span>
<a name="l00734"></a>00734   <span class="comment">// integral:</span>
<a name="l00735"></a>00735   <span class="comment">//</span>
<a name="l00737"></a>00737 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00738"></a><a class="code" href="namespaceviennamath.html#a89e5e3980bfaf17936d92ada9594d611">00738</a>   InterfaceType * <a class="code" href="namespaceviennamath.html#ab2aded2fd0a5e180147b4e571389ae0a" title="Implementation of the differentation of e1 + e1, where e1 and e2 are expressions.">diff_impl</a>(<span class="keyword">const</span> InterfaceType * e, <a class="code" href="classviennamath_1_1op__rt__integral.html" title="A unary operation defining an integral over an interval.">op_rt_integral&lt;InterfaceType&gt;</a>, <span class="keyword">const</span> InterfaceType * diff_var)
<a name="l00739"></a>00739   {
<a name="l00740"></a>00740     <span class="keywordflow">throw</span> <a class="code" href="classviennamath_1_1expression__not__differentiable__exception.html" title="An exception which is thrown if an expression should be differentiated, but at least one of the leave...">expression_not_differentiable_exception</a>(<span class="stringliteral">&quot;Cannot differentiate runtime integration (yet)!&quot;</span>);
<a name="l00741"></a>00741     <span class="keywordflow">return</span> NULL;
<a name="l00742"></a>00742   }  
<a name="l00743"></a>00743 
<a name="l00745"></a>00745   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00746"></a><a class="code" href="namespaceviennamath.html#a664a62b90f283761c819f8cccc56c5ae">00746</a>   InterfaceType * <a class="code" href="namespaceviennamath.html#ab2aded2fd0a5e180147b4e571389ae0a" title="Implementation of the differentation of e1 + e1, where e1 and e2 are expressions.">diff_impl</a>(<span class="keyword">const</span> InterfaceType * e, <a class="code" href="classviennamath_1_1op__rt__symbolic__integral.html" title="A unary operation encoding a symbolic interval. Cannot be evaluated and is meant to be replaced by a ...">op_rt_symbolic_integral&lt;InterfaceType&gt;</a>, <span class="keyword">const</span> InterfaceType * diff_var)
<a name="l00747"></a>00747   {
<a name="l00748"></a>00748     <span class="keywordflow">throw</span> <a class="code" href="classviennamath_1_1expression__not__differentiable__exception.html" title="An exception which is thrown if an expression should be differentiated, but at least one of the leave...">expression_not_differentiable_exception</a>(<span class="stringliteral">&quot;Cannot differentiate runtime integration (yet)!&quot;</span>);
<a name="l00749"></a>00749     <span class="keywordflow">return</span> NULL;
<a name="l00750"></a>00750   }  
<a name="l00751"></a>00751 
<a name="l00752"></a>00752 }
<a name="l00753"></a>00753 
<a name="l00754"></a>00754 <span class="preprocessor">#endif</span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Feb 29 2012 21:50:43 for ViennaMath by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
