<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ViennaMath: rt_binary_expr&lt; InterfaceType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceviennamath.html">viennamath</a>      </li>
      <li><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr&lt; InterfaceType &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>rt_binary_expr&lt; InterfaceType &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="viennamath::rt_binary_expr" -->
<p>Runtime representation of a binary expression F(x,y), where F is a function of two argument (e.g. +) and x,y are expressions.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="binary__expr_8hpp_source.html">binary_expr.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef InterfaceType::numeric_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a6a9b83e8ad5b9cc529e95c3cf85f66a2">rt_binary_expr</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a163f6393ec0b5b7a368572c77a825828">rt_binary_expr</a> (InterfaceType *lhs, <a class="el" href="classviennamath_1_1op__interface.html">op_interface_type</a> *op, InterfaceType *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a610269699f2cf5748a3f28f712abd7d9">rt_binary_expr</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS, OP, RHS &gt; const &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP , long value&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a92db6c3f6e01a1aefb763d76eeceb897">rt_binary_expr</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS, OP, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; &gt; const &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value, typename OP , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#abfae8eb56f94c3fbdbe27094e5af3bf7">rt_binary_expr</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt;, OP, RHS &gt; const &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value1, typename OP , long value2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a51d3f0b2a34b15892f0a1b59bc4d3cf9">rt_binary_expr</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value1 &gt;, OP, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value2 &gt; &gt; const &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP , id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#ac000f5fb08797c2784672b694beb619b">rt_binary_expr</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS, OP, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; &gt; const &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id, typename OP , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a7078745ea0e7313066d3cd1de43a3a41">rt_binary_expr</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt;, OP, RHS &gt; const &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id1, typename OP , id_type id2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a26ca9e7d14c8055ec6789f37af528c0f">rt_binary_expr</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id1 &gt;, OP, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id2 &gt; &gt; const &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id, typename OP , long value&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#aad107d1012ed21387e272e393dd57c7c">rt_binary_expr</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt;, OP, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; &gt; const &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id, typename OP , long value&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#afdf25b1144f6f2469f021a0263b8a1dc">rt_binary_expr</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt;, OP, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; &gt; const &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a5133e78fc11df9831734ad70fde37529">rt_binary_expr</a> (<a class="el" href="classviennamath_1_1rt__binary__expr.html">binary_expr</a> const &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a8694408ab9f51c1d6d1f24a0d32a1f35">operator=</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS, OP, RHS &gt; const &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP , long value&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#aefe0fe766b9ed265780f3ea94744085e">operator=</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS, OP, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; &gt; const &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value, typename OP , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a20001eb9f8da9d7eff808c008261d8c9">operator=</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt;, OP, RHS &gt; const &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value1, typename OP , long value2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#ac5f85a424671fd277f4578b51726eb83">operator=</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value1 &gt;, OP, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value2 &gt; &gt; const &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#af16e0ba68e018fb57862453835dd3609">operator=</a> (<a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a> const &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#aa3a1ed6fc8f1390dfa1b4c29f8a4c740">operator=</a> (<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; ScalarType &gt; const &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a661a3f04a234fc9ba72d54f8e98b2234">operator=</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; const &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a0e2a63c72c5996846d26491a9e0b903d">operator=</a> (<a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const InterfaceType *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a3a96e11a960eada0d735489e0c8d8502">lhs</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classviennamath_1_1op__interface.html">op_interface_type</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#abfec25af46dbb1adc54d2ea82014091d">op</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const InterfaceType *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a8584e7a8bf3f3b872ac79a5457178f95">rhs</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a535b2cea005dd1f83b06574ac330b490">operator()</a> (<a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> val) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#ae8b3029ade284c73f25e13e29bed3fb0">operator()</a> (<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; ScalarType &gt; val) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a84045268ea59d8afd1ceea5f52212828">operator()</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; val) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#aca487724a49d673ada415f4fabf90396">operator()</a> (VectorType const &amp;v) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a1af492acb60f4c89f721786fe9e22500">operator()</a> (std::vector&lt; <a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> &gt; const &amp;stl_v) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T0 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a8657c5bfeb163487365fe4b4d32013ab">operator()</a> (<a class="el" href="classviennamath_1_1ct__vector__1.html">viennamath::ct_vector_1</a>&lt; T0 &gt; const &amp;v) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#aa69212f57caede7ab1c0924077a35c01">operator()</a> (<a class="el" href="classviennamath_1_1ct__vector__2.html">viennamath::ct_vector_2</a>&lt; T0, T1 &gt; const &amp;v) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a630dc569e5e70d8598c004ba17e40052">operator()</a> (<a class="el" href="classviennamath_1_1ct__vector__3.html">viennamath::ct_vector_3</a>&lt; T0, T1, T2 &gt; const &amp;v) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a2454285b42067b2aebb6464d97984b43">eval</a> (std::vector&lt; double &gt; const &amp;v) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a462af8a4a68e81745043afc5d85fa084">eval</a> (<a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> val) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#ac9ba83bd4006d2e828faefc2c589d388">simplify</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a simplified expression with trivial operations removed. The caller is responsible for deleting the object the returned pointer refers to.  <a href="#ac9ba83bd4006d2e828faefc2c589d388"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a753df58aef455c024be3bd466ef3ff04">can_simplify</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the expression can be simplified.  <a href="#a753df58aef455c024be3bd466ef3ff04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a0435646b1c18de1b989a2a77dcb2d616">clone</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a copy of the binary expression. The caller is responsible for deleting the returned object.  <a href="#a0435646b1c18de1b989a2a77dcb2d616"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a757539267b058a2d6754bf173e4a990a">deep_str</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a detailed string describing the binary expression. Acts recursively.  <a href="#a757539267b058a2d6754bf173e4a990a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a3e1ee39aae8ba0a136e5df3d1bcbafa9">shallow_str</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a short string describing the unary expression. Does not act recursively.  <a href="#a3e1ee39aae8ba0a136e5df3d1bcbafa9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a2766177608ec8c79c1dff193e9b6e2cb">is_unary</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the expression is a unary expression, which is not the case (-&gt; false).  <a href="#a2766177608ec8c79c1dff193e9b6e2cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a76dd43b43453913b05bec0ee2a388d9b">unwrap</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reduces the expression to a constant. If this is not possible, an <a class="el" href="classviennamath_1_1expression__not__unwrappable__exception.html" title="An exception which is thrown if an expression should be reduced to a floating point number using unwr...">expression_not_unwrappable_exception</a> is thrown.  <a href="#a76dd43b43453913b05bec0ee2a388d9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a4795bc2f88794e4cf96c4c27cc6ecbb4">is_constant</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the expression merely represents a constant value.  <a href="#a4795bc2f88794e4cf96c4c27cc6ecbb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a6a07aa38dede368e472cdb3d5d80e33a">substitute</a> (const InterfaceType *e, const InterfaceType *repl) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If 'e' equals to this binary expression, the replacement 'repl' is returned. Otherwise, the unary expression is cloned. Note that the caller must ensure proper deletion of the returned object.  <a href="#a6a07aa38dede368e472cdb3d5d80e33a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#aa3df2bf384f896088c5c88e8929aa0fe">substitute</a> (std::vector&lt; const InterfaceType * &gt; const &amp;e, std::vector&lt; const InterfaceType * &gt; const &amp;repl) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If one of the expressions in 'e' equals to this binary expression, the respective replacement 'repl' is returned. Otherwise, a copy of *this is returned. Note that the caller must ensure proper deletion of the returned object.  <a href="#aa3df2bf384f896088c5c88e8929aa0fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a745452704b3e9127ab1659a21364c5b2">deep_equal</a> (const InterfaceType *other) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a detailed comparison of the binary expression with the passed expression. Returns true if they represent the same expression (equal operands, equal operations, etc.).  <a href="#a745452704b3e9127ab1659a21364c5b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a1699a4075b9d4a0890169c568b251f47">shallow_equal</a> (const InterfaceType *other) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the passed expression is any binary expression.  <a href="#a1699a4075b9d4a0890169c568b251f47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a67776162d4107636e41aa74e04b86a8f">diff</a> (const InterfaceType *diff_var) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the derivative of this binary expression with respect to the variable 'diff_var'. The returned object must be deleted by the caller.  <a href="#a67776162d4107636e41aa74e04b86a8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a03c4b8cfffcfaeb90256612cb1847633">recursive_manipulation</a> (<a class="el" href="classviennamath_1_1rt__manipulation__wrapper.html">rt_manipulation_wrapper</a>&lt; InterfaceType &gt; const &amp;fw) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recursively manipulates the expression. If this expression is manipulated, the result is returned directly. Otherwise, the manipulator continues with the expression the unary operation is acting on. The returned object must be deleted by the caller.  <a href="#a03c4b8cfffcfaeb90256612cb1847633"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html#a57fa2f40f67c85f8f57a168d44a41e58">recursive_traversal</a> (<a class="el" href="classviennamath_1_1rt__traversal__wrapper.html">rt_traversal_wrapper</a>&lt; InterfaceType &gt; const &amp;fw) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recursively traverses the expression by calling the wrapper for each object without manipulating it.  <a href="#a57fa2f40f67c85f8f57a168d44a41e58"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename InterfaceType&gt;<br/>
 class viennamath::rt_binary_expr&lt; InterfaceType &gt;</h3>

<p>Runtime representation of a binary expression F(x,y), where F is a function of two argument (e.g. +) and x,y are expressions. </p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InterfaceType</em>&nbsp;</td><td>The expression runtime interface to inherit from. Usually <a class="el" href="classviennamath_1_1rt__expression__interface.html" title="Abstract interface for all ViennaMath runtime expressions.">rt_expression_interface</a>, but extensions are possible. </td></tr>
  </table>
  </dd>
</dl>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="afb5ce2ac2be0c7efb30e536b8edd4c30"></a><!-- doxytag: member="viennamath::rt_binary_expr::numeric_type" ref="afb5ce2ac2be0c7efb30e536b8edd4c30" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InterfaceType::numeric_type <a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6a9b83e8ad5b9cc529e95c3cf85f66a2"></a><!-- doxytag: member="viennamath::rt_binary_expr::rt_binary_expr" ref="a6a9b83e8ad5b9cc529e95c3cf85f66a2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a163f6393ec0b5b7a368572c77a825828"></a><!-- doxytag: member="viennamath::rt_binary_expr::rt_binary_expr" ref="a163f6393ec0b5b7a368572c77a825828" args="(InterfaceType *lhs, op_interface_type *op, InterfaceType *rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a> </td>
          <td>(</td>
          <td class="paramtype">InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1op__interface.html">op_interface_type</a> *&nbsp;</td>
          <td class="paramname"> <em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a610269699f2cf5748a3f28f712abd7d9"></a><!-- doxytag: member="viennamath::rt_binary_expr::rt_binary_expr" ref="a610269699f2cf5748a3f28f712abd7d9" args="(ct_binary_expr&lt; LHS, OP, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS, OP, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a92db6c3f6e01a1aefb763d76eeceb897"></a><!-- doxytag: member="viennamath::rt_binary_expr::rt_binary_expr" ref="a92db6c3f6e01a1aefb763d76eeceb897" args="(ct_binary_expr&lt; LHS, OP, ct_constant&lt; value &gt; &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS, OP, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abfae8eb56f94c3fbdbe27094e5af3bf7"></a><!-- doxytag: member="viennamath::rt_binary_expr::rt_binary_expr" ref="abfae8eb56f94c3fbdbe27094e5af3bf7" args="(ct_binary_expr&lt; ct_constant&lt; value &gt;, OP, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt;, OP, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a51d3f0b2a34b15892f0a1b59bc4d3cf9"></a><!-- doxytag: member="viennamath::rt_binary_expr::rt_binary_expr" ref="a51d3f0b2a34b15892f0a1b59bc4d3cf9" args="(ct_binary_expr&lt; ct_constant&lt; value1 &gt;, OP, ct_constant&lt; value2 &gt; &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value1 &gt;, OP, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value2 &gt; &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac000f5fb08797c2784672b694beb619b"></a><!-- doxytag: member="viennamath::rt_binary_expr::rt_binary_expr" ref="ac000f5fb08797c2784672b694beb619b" args="(ct_binary_expr&lt; LHS, OP, ct_variable&lt; id &gt; &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS, OP, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7078745ea0e7313066d3cd1de43a3a41"></a><!-- doxytag: member="viennamath::rt_binary_expr::rt_binary_expr" ref="a7078745ea0e7313066d3cd1de43a3a41" args="(ct_binary_expr&lt; ct_variable&lt; id &gt;, OP, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt;, OP, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a26ca9e7d14c8055ec6789f37af528c0f"></a><!-- doxytag: member="viennamath::rt_binary_expr::rt_binary_expr" ref="a26ca9e7d14c8055ec6789f37af528c0f" args="(ct_binary_expr&lt; ct_variable&lt; id1 &gt;, OP, ct_variable&lt; id2 &gt; &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id1 &gt;, OP, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id2 &gt; &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aad107d1012ed21387e272e393dd57c7c"></a><!-- doxytag: member="viennamath::rt_binary_expr::rt_binary_expr" ref="aad107d1012ed21387e272e393dd57c7c" args="(ct_binary_expr&lt; ct_variable&lt; id &gt;, OP, ct_constant&lt; value &gt; &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt;, OP, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afdf25b1144f6f2469f021a0263b8a1dc"></a><!-- doxytag: member="viennamath::rt_binary_expr::rt_binary_expr" ref="afdf25b1144f6f2469f021a0263b8a1dc" args="(ct_binary_expr&lt; ct_constant&lt; value &gt;, OP, ct_variable&lt; id &gt; &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt;, OP, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5133e78fc11df9831734ad70fde37529"></a><!-- doxytag: member="viennamath::rt_binary_expr::rt_binary_expr" ref="a5133e78fc11df9831734ad70fde37529" args="(binary_expr const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1rt__binary__expr.html">binary_expr</a> const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a753df58aef455c024be3bd466ef3ff04"></a><!-- doxytag: member="viennamath::rt_binary_expr::can_simplify" ref="a753df58aef455c024be3bd466ef3ff04" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool can_simplify </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the expression can be simplified. </p>

</div>
</div>
<a class="anchor" id="a0435646b1c18de1b989a2a77dcb2d616"></a><!-- doxytag: member="viennamath::rt_binary_expr::clone" ref="a0435646b1c18de1b989a2a77dcb2d616" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType* clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a copy of the binary expression. The caller is responsible for deleting the returned object. </p>

</div>
</div>
<a class="anchor" id="a745452704b3e9127ab1659a21364c5b2"></a><!-- doxytag: member="viennamath::rt_binary_expr::deep_equal" ref="a745452704b3e9127ab1659a21364c5b2" args="(const InterfaceType *other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool deep_equal </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a detailed comparison of the binary expression with the passed expression. Returns true if they represent the same expression (equal operands, equal operations, etc.). </p>

</div>
</div>
<a class="anchor" id="a757539267b058a2d6754bf173e4a990a"></a><!-- doxytag: member="viennamath::rt_binary_expr::deep_str" ref="a757539267b058a2d6754bf173e4a990a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string deep_str </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a detailed string describing the binary expression. Acts recursively. </p>

</div>
</div>
<a class="anchor" id="a67776162d4107636e41aa74e04b86a8f"></a><!-- doxytag: member="viennamath::rt_binary_expr::diff" ref="a67776162d4107636e41aa74e04b86a8f" args="(const InterfaceType *diff_var) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType* diff </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>diff_var</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the derivative of this binary expression with respect to the variable 'diff_var'. The returned object must be deleted by the caller. </p>

</div>
</div>
<a class="anchor" id="a2454285b42067b2aebb6464d97984b43"></a><!-- doxytag: member="viennamath::rt_binary_expr::eval" ref="a2454285b42067b2aebb6464d97984b43" args="(std::vector&lt; double &gt; const &amp;v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> eval </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a462af8a4a68e81745043afc5d85fa084"></a><!-- doxytag: member="viennamath::rt_binary_expr::eval" ref="a462af8a4a68e81745043afc5d85fa084" args="(numeric_type val) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> eval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4795bc2f88794e4cf96c4c27cc6ecbb4"></a><!-- doxytag: member="viennamath::rt_binary_expr::is_constant" ref="a4795bc2f88794e4cf96c4c27cc6ecbb4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_constant </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the expression merely represents a constant value. </p>

</div>
</div>
<a class="anchor" id="a2766177608ec8c79c1dff193e9b6e2cb"></a><!-- doxytag: member="viennamath::rt_binary_expr::is_unary" ref="a2766177608ec8c79c1dff193e9b6e2cb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_unary </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the expression is a unary expression, which is not the case (-&gt; false). </p>

</div>
</div>
<a class="anchor" id="a3a96e11a960eada0d735489e0c8d8502"></a><!-- doxytag: member="viennamath::rt_binary_expr::lhs" ref="a3a96e11a960eada0d735489e0c8d8502" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const InterfaceType* lhs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abfec25af46dbb1adc54d2ea82014091d"></a><!-- doxytag: member="viennamath::rt_binary_expr::op" ref="abfec25af46dbb1adc54d2ea82014091d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classviennamath_1_1op__interface.html">op_interface_type</a>* op </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8657c5bfeb163487365fe4b4d32013ab"></a><!-- doxytag: member="viennamath::rt_binary_expr::operator()" ref="a8657c5bfeb163487365fe4b4d32013ab" args="(viennamath::ct_vector_1&lt; T0 &gt; const &amp;v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1ct__vector__1.html">viennamath::ct_vector_1</a>&lt; T0 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1af492acb60f4c89f721786fe9e22500"></a><!-- doxytag: member="viennamath::rt_binary_expr::operator()" ref="a1af492acb60f4c89f721786fe9e22500" args="(std::vector&lt; numeric_type &gt; const &amp;stl_v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> operator() </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>stl_v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa69212f57caede7ab1c0924077a35c01"></a><!-- doxytag: member="viennamath::rt_binary_expr::operator()" ref="aa69212f57caede7ab1c0924077a35c01" args="(viennamath::ct_vector_2&lt; T0, T1 &gt; const &amp;v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1ct__vector__2.html">viennamath::ct_vector_2</a>&lt; T0, T1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a630dc569e5e70d8598c004ba17e40052"></a><!-- doxytag: member="viennamath::rt_binary_expr::operator()" ref="a630dc569e5e70d8598c004ba17e40052" args="(viennamath::ct_vector_3&lt; T0, T1, T2 &gt; const &amp;v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1ct__vector__3.html">viennamath::ct_vector_3</a>&lt; T0, T1, T2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a535b2cea005dd1f83b06574ac330b490"></a><!-- doxytag: member="viennamath::rt_binary_expr::operator()" ref="a535b2cea005dd1f83b06574ac330b490" args="(numeric_type val) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae8b3029ade284c73f25e13e29bed3fb0"></a><!-- doxytag: member="viennamath::rt_binary_expr::operator()" ref="ae8b3029ade284c73f25e13e29bed3fb0" args="(rt_constant&lt; ScalarType &gt; val) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; ScalarType &gt;&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a84045268ea59d8afd1ceea5f52212828"></a><!-- doxytag: member="viennamath::rt_binary_expr::operator()" ref="a84045268ea59d8afd1ceea5f52212828" args="(ct_constant&lt; value &gt; val) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt;&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aca487724a49d673ada415f4fabf90396"></a><!-- doxytag: member="viennamath::rt_binary_expr::operator()" ref="aca487724a49d673ada415f4fabf90396" args="(VectorType const &amp;v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> operator() </td>
          <td>(</td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa3a1ed6fc8f1390dfa1b4c29f8a4c740"></a><!-- doxytag: member="viennamath::rt_binary_expr::operator=" ref="aa3a1ed6fc8f1390dfa1b4c29f8a4c740" args="(rt_constant&lt; ScalarType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; ScalarType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0e2a63c72c5996846d26491a9e0b903d"></a><!-- doxytag: member="viennamath::rt_binary_expr::operator=" ref="a0e2a63c72c5996846d26491a9e0b903d" args="(numeric_type value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac5f85a424671fd277f4578b51726eb83"></a><!-- doxytag: member="viennamath::rt_binary_expr::operator=" ref="ac5f85a424671fd277f4578b51726eb83" args="(ct_binary_expr&lt; ct_constant&lt; value1 &gt;, OP, ct_constant&lt; value2 &gt; &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value1 &gt;, OP, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value2 &gt; &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af16e0ba68e018fb57862453835dd3609"></a><!-- doxytag: member="viennamath::rt_binary_expr::operator=" ref="af16e0ba68e018fb57862453835dd3609" args="(rt_binary_expr const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8694408ab9f51c1d6d1f24a0d32a1f35"></a><!-- doxytag: member="viennamath::rt_binary_expr::operator=" ref="a8694408ab9f51c1d6d1f24a0d32a1f35" args="(ct_binary_expr&lt; LHS, OP, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS, OP, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a661a3f04a234fc9ba72d54f8e98b2234"></a><!-- doxytag: member="viennamath::rt_binary_expr::operator=" ref="a661a3f04a234fc9ba72d54f8e98b2234" args="(ct_constant&lt; value &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a20001eb9f8da9d7eff808c008261d8c9"></a><!-- doxytag: member="viennamath::rt_binary_expr::operator=" ref="a20001eb9f8da9d7eff808c008261d8c9" args="(ct_binary_expr&lt; ct_constant&lt; value &gt;, OP, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt;, OP, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aefe0fe766b9ed265780f3ea94744085e"></a><!-- doxytag: member="viennamath::rt_binary_expr::operator=" ref="aefe0fe766b9ed265780f3ea94744085e" args="(ct_binary_expr&lt; LHS, OP, ct_constant&lt; value &gt; &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS, OP, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a03c4b8cfffcfaeb90256612cb1847633"></a><!-- doxytag: member="viennamath::rt_binary_expr::recursive_manipulation" ref="a03c4b8cfffcfaeb90256612cb1847633" args="(rt_manipulation_wrapper&lt; InterfaceType &gt; const &amp;fw) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType* recursive_manipulation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1rt__manipulation__wrapper.html">rt_manipulation_wrapper</a>&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>fw</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recursively manipulates the expression. If this expression is manipulated, the result is returned directly. Otherwise, the manipulator continues with the expression the unary operation is acting on. The returned object must be deleted by the caller. </p>

</div>
</div>
<a class="anchor" id="a57fa2f40f67c85f8f57a168d44a41e58"></a><!-- doxytag: member="viennamath::rt_binary_expr::recursive_traversal" ref="a57fa2f40f67c85f8f57a168d44a41e58" args="(rt_traversal_wrapper&lt; InterfaceType &gt; const &amp;fw) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void recursive_traversal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1rt__traversal__wrapper.html">rt_traversal_wrapper</a>&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>fw</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recursively traverses the expression by calling the wrapper for each object without manipulating it. </p>

</div>
</div>
<a class="anchor" id="a8584e7a8bf3f3b872ac79a5457178f95"></a><!-- doxytag: member="viennamath::rt_binary_expr::rhs" ref="a8584e7a8bf3f3b872ac79a5457178f95" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const InterfaceType* rhs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1699a4075b9d4a0890169c568b251f47"></a><!-- doxytag: member="viennamath::rt_binary_expr::shallow_equal" ref="a1699a4075b9d4a0890169c568b251f47" args="(const InterfaceType *other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool shallow_equal </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the passed expression is any binary expression. </p>

</div>
</div>
<a class="anchor" id="a3e1ee39aae8ba0a136e5df3d1bcbafa9"></a><!-- doxytag: member="viennamath::rt_binary_expr::shallow_str" ref="a3e1ee39aae8ba0a136e5df3d1bcbafa9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string shallow_str </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a short string describing the unary expression. Does not act recursively. </p>

</div>
</div>
<a class="anchor" id="ac9ba83bd4006d2e828faefc2c589d388"></a><!-- doxytag: member="viennamath::rt_binary_expr::simplify" ref="ac9ba83bd4006d2e828faefc2c589d388" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType* simplify </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a simplified expression with trivial operations removed. The caller is responsible for deleting the object the returned pointer refers to. </p>

</div>
</div>
<a class="anchor" id="a6a07aa38dede368e472cdb3d5d80e33a"></a><!-- doxytag: member="viennamath::rt_binary_expr::substitute" ref="a6a07aa38dede368e472cdb3d5d80e33a" args="(const InterfaceType *e, const InterfaceType *repl) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType* substitute </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>repl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If 'e' equals to this binary expression, the replacement 'repl' is returned. Otherwise, the unary expression is cloned. Note that the caller must ensure proper deletion of the returned object. </p>

</div>
</div>
<a class="anchor" id="aa3df2bf384f896088c5c88e8929aa0fe"></a><!-- doxytag: member="viennamath::rt_binary_expr::substitute" ref="aa3df2bf384f896088c5c88e8929aa0fe" args="(std::vector&lt; const InterfaceType * &gt; const &amp;e, std::vector&lt; const InterfaceType * &gt; const &amp;repl) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType* substitute </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const InterfaceType * &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const InterfaceType * &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>repl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If one of the expressions in 'e' equals to this binary expression, the respective replacement 'repl' is returned. Otherwise, a copy of *this is returned. Note that the caller must ensure proper deletion of the returned object. </p>

</div>
</div>
<a class="anchor" id="a76dd43b43453913b05bec0ee2a388d9b"></a><!-- doxytag: member="viennamath::rt_binary_expr::unwrap" ref="a76dd43b43453913b05bec0ee2a388d9b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> unwrap </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reduces the expression to a constant. If this is not possible, an <a class="el" href="classviennamath_1_1expression__not__unwrappable__exception.html" title="An exception which is thrown if an expression should be reduced to a floating point number using unwr...">expression_not_unwrappable_exception</a> is thrown. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/export/development/ViennaMath/viennamath/runtime/<a class="el" href="binary__expr_8hpp_source.html">binary_expr.hpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Feb 29 2012 21:50:44 for ViennaMath by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
