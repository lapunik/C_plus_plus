<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ViennaMath: /export/development/ViennaMath/viennamath/manipulation/substitute.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>/export/development/ViennaMath/viennamath/manipulation/substitute.hpp File Reference</h1>  </div>
</div>
<div class="contents">

<p>Defines routines for substituting (parts of) an expression by another expression.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="forwards_8h_source.html">viennamath/forwards.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="functor__wrapper_8hpp_source.html">viennamath/runtime/functor_wrapper.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="simplify_8hpp_source.html">viennamath/manipulation/simplify.hpp</a>&quot;</code><br/>
<code>#include &lt;assert.h&gt;</code><br/>

<p><a href="substitute_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1substitute.html">substitute&lt; SearchType, ReplacementType, ExpressionType &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default case for the compiletime substitution metafunction: Do not define any return type. This provides SFINAE for the interface function.  <a href="structviennamath_1_1result__of_1_1substitute.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01_search_type_00_01_replacement_type_00_01ct__bi8a26ae43012ec44e7b3eb1374af4669d.html">substitute&lt; SearchType, ReplacementType, ct_binary_expr&lt; LHS, OP, RHS &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For a binary expression, the substitution is performed for both operands.  <a href="structviennamath_1_1result__of_1_1substitute_3_01_search_type_00_01_replacement_type_00_01ct__bi8a26ae43012ec44e7b3eb1374af4669d.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01_search_type_00_01_replacement_type_00_01ct__un0dd76973b9488f668651aa73794c79b9.html">substitute&lt; SearchType, ReplacementType, ct_unary_expr&lt; LHS, OP &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For a unary expression, the substitution is performed for the operand.  <a href="structviennamath_1_1result__of_1_1substitute_3_01_search_type_00_01_replacement_type_00_01ct__un0dd76973b9488f668651aa73794c79b9.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01_search_type_00_01_replacement_type_00_01ct__constant_3_01value_01_4_01_4.html">substitute&lt; SearchType, ReplacementType, ct_constant&lt; value &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">By default, a compiletime constant is left unmodified (no match).  <a href="structviennamath_1_1result__of_1_1substitute_3_01_search_type_00_01_replacement_type_00_01ct__constant_3_01value_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01_search_type_00_01_replacement_type_00_01ct__fuc4542387a2938c39fb0805bb1220ae46.html">substitute&lt; SearchType, ReplacementType, ct_function_symbol&lt; TAG &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">By default, a compiletime function symbol is left unmodified (no match).  <a href="structviennamath_1_1result__of_1_1substitute_3_01_search_type_00_01_replacement_type_00_01ct__fuc4542387a2938c39fb0805bb1220ae46.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01_search_type_00_01_replacement_type_00_01ct__variable_3_01id_01_4_01_4.html">substitute&lt; SearchType, ReplacementType, ct_variable&lt; id &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">By default, a compiletime variable is left unmodified (no match).  <a href="structviennamath_1_1result__of_1_1substitute_3_01_search_type_00_01_replacement_type_00_01ct__variable_3_01id_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h0f87136a71f9c909af6daee650d850ae.html">substitute&lt; ct_binary_expr&lt; LHS, OP, RHS &gt;, ReplacementType, ct_binary_expr&lt; LHS, OP, RHS &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If there is a match for the binary expression, the replacement is returned.  <a href="structviennamath_1_1result__of_1_1substitute_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h0f87136a71f9c909af6daee650d850ae.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01ct__unary__expr_3_01_l_h_s_00_01_o_p_01_4_00_01cbe037ca3f825a32f06c7ffee55d38e2.html">substitute&lt; ct_unary_expr&lt; LHS, OP &gt;, ReplacementType, ct_unary_expr&lt; LHS, OP &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If there is a match for the unary expression, the replacement is returned.  <a href="structviennamath_1_1result__of_1_1substitute_3_01ct__unary__expr_3_01_l_h_s_00_01_o_p_01_4_00_01cbe037ca3f825a32f06c7ffee55d38e2.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01ct__constant_3_01value_01_4_00_01_replacement_t36a9dee6096d8d038c95b59e92d1fadc.html">substitute&lt; ct_constant&lt; value &gt;, ReplacementType, ct_constant&lt; value &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If there is a match for the compiletime constant, the replacement is returned.  <a href="structviennamath_1_1result__of_1_1substitute_3_01ct__constant_3_01value_01_4_00_01_replacement_t36a9dee6096d8d038c95b59e92d1fadc.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01ct__function__symbol_3_01_t_a_g_01_4_00_01_repl533efeac83c878388aa392e01e71cdbe.html">substitute&lt; ct_function_symbol&lt; TAG &gt;, ReplacementType, ct_function_symbol&lt; TAG &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If there is a match for the compiletime function symbol, the replacement is returned.  <a href="structviennamath_1_1result__of_1_1substitute_3_01ct__function__symbol_3_01_t_a_g_01_4_00_01_repl533efeac83c878388aa392e01e71cdbe.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01ct__variable_3_01id_01_4_00_01_replacement_typeddebcd8dd4169a510fb84cc21bdffaa5.html">substitute&lt; ct_variable&lt; id &gt;, ReplacementType, ct_variable&lt; id &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If there is a match for the compiletime variable, the replacement is returned.  <a href="structviennamath_1_1result__of_1_1substitute_3_01ct__variable_3_01id_01_4_00_01_replacement_typeddebcd8dd4169a510fb84cc21bdffaa5.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1detail_1_1integral__substitution__functor.html">integral_substitution_functor&lt; InterfaceType &gt;</a></td></tr>
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html">viennamath</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The main ViennaMath namespace. All types and functions for the user reside here. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath_1_1result__of.html">viennamath::result_of</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The namespace containing a set of metafunctions which can be used by the ViennaMath library user. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath_1_1detail.html">viennamath::detail</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Implementation details for functionality in ViennaMath. Not intended for direct use. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SearchType , typename ReplacementType , typename ExpressionType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">result_of::substitute<br class="typebreak"/>
&lt; SearchType, ReplacementType, <br class="typebreak"/>
ExpressionType &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a175715df224eeeaca505554906516230">substitute</a> (SearchType const &amp;, ReplacementType const &amp;, ExpressionType const &amp;ex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The generic interface function for compiletime substitution.  <a href="#a175715df224eeeaca505554906516230"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename ReplacementType , typename ExpressionType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">rt_expr&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aebf95ab660141cea0a1657e9d3ca29d7">substitute</a> (rt_variable&lt; InterfaceType &gt; const &amp;u, ReplacementType const &amp;repl, ExpressionType const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces all occurances of the variable 'u' in the expression 'e' with 'repl'.  <a href="#aebf95ab660141cea0a1657e9d3ca29d7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename ReplacementType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">rt_expr&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aa5add5eb3186740a97c9d02e9530b30e">substitute</a> (rt_variable&lt; InterfaceType &gt; const &amp;u, ReplacementType const &amp;repl, rt_expr&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces all occurances of the variable 'u' in the expression 'e' with 'repl'.  <a href="#aa5add5eb3186740a97c9d02e9530b30e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">rt_expr&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#af6c27a8c577b4d1a3a43160eee378a90">substitute</a> (rt_variable&lt; InterfaceType &gt; const &amp;u, default_numeric_type repl, rt_expr&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces all occurances of the variable 'u' in the expression 'e' with 'repl'.  <a href="#af6c27a8c577b4d1a3a43160eee378a90"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">rt_expr&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aa757a4af65d821d7023707a3308f20d4">substitute</a> (rt_function_symbol&lt; InterfaceType &gt; const &amp;u, default_numeric_type repl, rt_expr&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces all occurances of the function symbol 'u' in the expression 'e' with 'repl'.  <a href="#aa757a4af65d821d7023707a3308f20d4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">rt_expr&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a62df9bea306cfe3e5df84601d41e5afa">substitute</a> (rt_function_symbol&lt; InterfaceType &gt; const &amp;u, rt_expr&lt; InterfaceType &gt; const &amp;repl, rt_expr&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces all occurances of the function symbol 'u' in the expression 'e' with 'repl'.  <a href="#a62df9bea306cfe3e5df84601d41e5afa"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename ReplacementType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">rt_expr&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a7615a8e86229b78c6839dd562a7d5d65">substitute</a> (rt_unary_expr&lt; InterfaceType &gt; const &amp;search, ReplacementType const &amp;repl, rt_expr&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces all occurances of the unary expression 'search' in the expression 'e' with 'repl'.  <a href="#a7615a8e86229b78c6839dd562a7d5d65"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">rt_expr&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a3558dd9b9b06dd97f0593c90055bcd82">substitute</a> (rt_unary_expr&lt; InterfaceType &gt; const &amp;search, rt_expr&lt; InterfaceType &gt; const &amp;repl, rt_expr&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces all occurances of the unary expression 'search' in the expression 'e' with 'repl'.  <a href="#a3558dd9b9b06dd97f0593c90055bcd82"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename ReplacementType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">rt_expr&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a14a37e585c04587cbdd2b5bae45810f6">substitute</a> (rt_binary_expr&lt; InterfaceType &gt; const &amp;search, ReplacementType const &amp;repl, rt_expr&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces all occurances of the binary expression 'search' in the expression 'e' with 'repl'.  <a href="#a14a37e585c04587cbdd2b5bae45810f6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">rt_expr&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a62faa5f9c1dfff907b94060b54211a7f">substitute</a> (rt_expr&lt; InterfaceType &gt; const &amp;search, rt_expr&lt; InterfaceType &gt; const &amp;repl, rt_expr&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces all occurances of the expression 'search' in the expression 'e' with 'repl'.  <a href="#a62faa5f9c1dfff907b94060b54211a7f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">rt_expr&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ac9ee50377d9c6ac19e3e06cc07e40a91">substitute</a> (std::vector&lt; rt_expr&lt; InterfaceType &gt; &gt; const &amp;search, std::vector&lt; rt_expr&lt; InterfaceType &gt; &gt; const &amp;repl, rt_expr&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces all occurances of the the expressions in 'search' in the expression 'e' with the corresponding expressions in 'repl'.  <a href="#ac9ee50377d9c6ac19e3e06cc07e40a91"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename PairType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">rt_expr&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aa31d186e422de5b063d30a189107257c">substitute</a> (rt_symbolic_interval&lt; InterfaceType &gt; const &amp;search, PairType const &amp;repl, rt_expr&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Substitutes a symbolic interval with a concrete interval.  <a href="#aa31d186e422de5b063d30a189107257c"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Defines routines for substituting (parts of) an expression by another expression. </p>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Feb 29 2012 21:50:44 for ViennaMath by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
