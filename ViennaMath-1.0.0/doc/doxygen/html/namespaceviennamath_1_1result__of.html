<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ViennaMath: viennamath::result_of Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceviennamath.html">viennamath</a>      </li>
      <li><a class="el" href="namespaceviennamath_1_1result__of.html">result_of</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<h1>viennamath::result_of Namespace Reference</h1>  </div>
</div>
<div class="contents">

<p>The namespace containing a set of metafunctions which can be used by the ViennaMath library user.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath_1_1result__of_1_1detail.html">detail</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Implementation details for the metafunctions in ViennaMath. Not intended for direct use. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1add_3_01_l_h_s_00_01_r_h_s_00_01true_00_01true_01_4.html">add&lt; LHS, RHS, true, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Metafunction for adding two compiletime expressions.  <a href="structviennamath_1_1result__of_1_1add_3_01_l_h_s_00_01_r_h_s_00_01true_00_01true_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1subtract_3_01_l_h_s_00_01_r_h_s_00_01true_00_01true_01_4.html">subtract&lt; LHS, RHS, true, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Metafunction for subtracting two compiletime expressions.  <a href="structviennamath_1_1result__of_1_1subtract_3_01_l_h_s_00_01_r_h_s_00_01true_00_01true_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1mult_3_01_l_h_s_00_01_r_h_s_00_01true_00_01true_01_4.html">mult&lt; LHS, RHS, true, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Metafunction for multiplying two compiletime expressions.  <a href="structviennamath_1_1result__of_1_1mult_3_01_l_h_s_00_01_r_h_s_00_01true_00_01true_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1div_3_01_l_h_s_00_01_r_h_s_00_01true_00_01true_01_4.html">div&lt; LHS, RHS, true, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Metafunction for dividing two compiletime expressions.  <a href="structviennamath_1_1result__of_1_1div_3_01_l_h_s_00_01_r_h_s_00_01true_00_01true_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath.html">is_viennamath</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A metafunction with value 'true' if the provided argument is a ViennaMath expression type. Otherwise, false is returned.  <a href="structviennamath_1_1result__of_1_1is__viennamath.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__constant_3_01val_01_4_01_4.html">is_viennamath&lt; ct_constant&lt; val &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath compiletime constant.  <a href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__constant_3_01val_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__variable_3_01id_01_4_01_4.html">is_viennamath&lt; ct_variable&lt; id &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath compiletime variable.  <a href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__variable_3_01id_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__function__symbol_3_01_t_a_g_01_4_01_4.html">is_viennamath&lt; ct_function_symbol&lt; TAG &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath compiletime function symbol.  <a href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__function__symbol_3_01_t_a_g_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h_s_01_4_01_4.html">is_viennamath&lt; ct_binary_expr&lt; LHS, OP, RHS &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath compiletime binary expression.  <a href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h_s_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__unary__expr_3_01_l_h_s_00_01_o_p_01_4_01_4.html">is_viennamath&lt; ct_unary_expr&lt; LHS, OP &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath compiletime unary expression.  <a href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__unary__expr_3_01_l_h_s_00_01_o_p_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__constant_3_01_numeric_type_00_01_interface_type_01_4_01_4.html">is_viennamath&lt; rt_constant&lt; NumericType, InterfaceType &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath runtime constant.  <a href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__constant_3_01_numeric_type_00_01_interface_type_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__variable_3_01_interface_type_01_4_01_4.html">is_viennamath&lt; rt_variable&lt; InterfaceType &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath runtime variable.  <a href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__variable_3_01_interface_type_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__function__symbol_3_01_interface_type_01_4_01_4.html">is_viennamath&lt; rt_function_symbol&lt; InterfaceType &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath runtime function symbol.  <a href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__function__symbol_3_01_interface_type_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__unary__expr_3_01_interface_type_01_4_01_4.html">is_viennamath&lt; rt_unary_expr&lt; InterfaceType &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath runtime unary expression.  <a href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__unary__expr_3_01_interface_type_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__binary__expr_3_01_interface_type_01_4_01_4.html">is_viennamath&lt; rt_binary_expr&lt; InterfaceType &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath runtime binary expression.  <a href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__binary__expr_3_01_interface_type_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__expr_3_01_interface_type_01_4_01_4.html">is_viennamath&lt; rt_expr&lt; InterfaceType &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath runtime expression.  <a href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__expr_3_01_interface_type_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__compiletime.html">is_compiletime</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A metafunction returning a value 'true' if the provided argument is a ViennaMath compiletime expression type. Otherwise, false is returned.  <a href="structviennamath_1_1result__of_1_1is__compiletime.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__constant_3_01val_01_4_01_4.html">is_compiletime&lt; ct_constant&lt; val &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath compiletime constant.  <a href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__constant_3_01val_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__variable_3_01id_01_4_01_4.html">is_compiletime&lt; ct_variable&lt; id &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath compiletime variable.  <a href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__variable_3_01id_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__function__symbol_3_01_t_a_g_01_4_01_4.html">is_compiletime&lt; ct_function_symbol&lt; TAG &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath compiletime function symbol.  <a href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__function__symbol_3_01_t_a_g_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h_s_01_4_01_4.html">is_compiletime&lt; ct_binary_expr&lt; LHS, OP, RHS &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath compiletime binary expression.  <a href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h_s_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__unary__expr_3_01_l_h_s_00_01_o_p_01_4_01_4.html">is_compiletime&lt; ct_unary_expr&lt; LHS, OP &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath compiletime unary expression.  <a href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__unary__expr_3_01_l_h_s_00_01_o_p_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1interface.html">interface</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A metafunction deducing the ViennaMath runtime expression interface (base class) from two types. The first argument has priority.  <a href="structviennamath_1_1result__of_1_1interface.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1interface_3_01rt__constant_3_01_t_00_01_u_01_4_00_01_r_h_s_01_4.html">interface&lt; rt_constant&lt; T, U &gt;, RHS &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the runtime expression interface deduction for a ViennaMath runtime constant.  <a href="structviennamath_1_1result__of_1_1interface_3_01rt__constant_3_01_t_00_01_u_01_4_00_01_r_h_s_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1interface_3_01rt__variable_3_01_t_01_4_00_01_r_h_s_01_4.html">interface&lt; rt_variable&lt; T &gt;, RHS &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the runtime expression interface deduction for a ViennaMath runtime variable.  <a href="structviennamath_1_1result__of_1_1interface_3_01rt__variable_3_01_t_01_4_00_01_r_h_s_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1interface_3_01default__numeric__type_00_01rt__variable_3_01_t_01_4_01_4.html">interface&lt; default_numeric_type, rt_variable&lt; T &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the runtime expression interface deduction for a ViennaMath runtime variable.  <a href="structviennamath_1_1result__of_1_1interface_3_01default__numeric__type_00_01rt__variable_3_01_t_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1interface_3_01rt__binary__expr_3_01_t_01_4_00_01_r_h_s_01_4.html">interface&lt; rt_binary_expr&lt; T &gt;, RHS &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the runtime expression interface deduction for a ViennaMath runtime binary expression.  <a href="structviennamath_1_1result__of_1_1interface_3_01rt__binary__expr_3_01_t_01_4_00_01_r_h_s_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1interface_3_01default__numeric__type_00_01rt__binary__expr_3_01_t_01_4_01_4.html">interface&lt; default_numeric_type, rt_binary_expr&lt; T &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the runtime expression interface deduction for a ViennaMath runtime binary expression.  <a href="structviennamath_1_1result__of_1_1interface_3_01default__numeric__type_00_01rt__binary__expr_3_01_t_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1interface_3_01rt__unary__expr_3_01_t_01_4_00_01_r_h_s_01_4.html">interface&lt; rt_unary_expr&lt; T &gt;, RHS &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the runtime expression interface deduction for a ViennaMath runtime unary expression.  <a href="structviennamath_1_1result__of_1_1interface_3_01rt__unary__expr_3_01_t_01_4_00_01_r_h_s_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1interface_3_01rt__expr_3_01_t_01_4_00_01_r_h_s_01_4.html">interface&lt; rt_expr&lt; T &gt;, RHS &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the runtime expression interface deduction for the ViennaMath runtime expression wrapper.  <a href="structviennamath_1_1result__of_1_1interface_3_01rt__expr_3_01_t_01_4_00_01_r_h_s_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1interface_3_01double_00_01rt__expr_3_01_t_01_4_01_4.html">interface&lt; double, rt_expr&lt; T &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the runtime expression interface deduction for the ViennaMath runtime expression wrapper.  <a href="structviennamath_1_1result__of_1_1interface_3_01double_00_01rt__expr_3_01_t_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1gcd.html">gcd</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper metafunction for computing the greatest common divisor of two numbers.  <a href="structviennamath_1_1result__of_1_1gcd.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1gcd_3_01a_00_010_01_4.html">gcd&lt; a, 0 &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for the computation of the greatest common divisor of a and 0, which is a.  <a href="structviennamath_1_1result__of_1_1gcd_3_01a_00_010_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1gcd_3_010_00_010_01_4.html">gcd&lt; 0, 0 &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization forcing a compile time error, since the greatest common divisor of 0 and 0 is not defined.  <a href="structviennamath_1_1result__of_1_1gcd_3_010_00_010_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1coefficient.html">coefficient</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User metafunction for extracting the coefficient of a variable or sub-expression from an expression.  <a href="structviennamath_1_1result__of_1_1coefficient.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1diff.html">diff</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the type of the expression after differentiation of 'ARG' with respect to the variable 'VAR'.  <a href="structviennamath_1_1result__of_1_1diff.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1diff_3_01ct__binary__expr_3_01_l_h_s_00_01op__plus_3_01default35c76917fe8543b1779c6cfc35509a9b.html">diff&lt; ct_binary_expr&lt; LHS, op_plus&lt; default_numeric_type &gt;, RHS &gt;, ct_variable&lt; id &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization implementing the rule (u + v)' = u' + v'.  <a href="structviennamath_1_1result__of_1_1diff_3_01ct__binary__expr_3_01_l_h_s_00_01op__plus_3_01default35c76917fe8543b1779c6cfc35509a9b.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1diff_3_01ct__binary__expr_3_01_l_h_s_00_01op__minus_3_01defaule9db20293bc6e480bd470a0c3f79d2ff.html">diff&lt; ct_binary_expr&lt; LHS, op_minus&lt; default_numeric_type &gt;, RHS &gt;, ct_variable&lt; id &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization implementing the rule (u - v)' = u' - v'.  <a href="structviennamath_1_1result__of_1_1diff_3_01ct__binary__expr_3_01_l_h_s_00_01op__minus_3_01defaule9db20293bc6e480bd470a0c3f79d2ff.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1diff_3_01ct__binary__expr_3_01_l_h_s_00_01op__mult_3_01default16fc32b6df86c99bbf5b44a9c99a24a3.html">diff&lt; ct_binary_expr&lt; LHS, op_mult&lt; default_numeric_type &gt;, RHS &gt;, ct_variable&lt; id &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization implementing the rule (u * v)' = u'*v + u*v'.  <a href="structviennamath_1_1result__of_1_1diff_3_01ct__binary__expr_3_01_l_h_s_00_01op__mult_3_01default16fc32b6df86c99bbf5b44a9c99a24a3.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1diff_3_01ct__binary__expr_3_01_l_h_s_00_01op__div_3_01default_59039fed55e880846bd895a748cc6c13.html">diff&lt; ct_binary_expr&lt; LHS, op_div&lt; default_numeric_type &gt;, RHS &gt;, ct_variable&lt; id &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization implementing the rule (u/v)' = (u'*v - u*v') / v^2.  <a href="structviennamath_1_1result__of_1_1diff_3_01ct__binary__expr_3_01_l_h_s_00_01op__div_3_01default_59039fed55e880846bd895a748cc6c13.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1diff_3_01ct__variable_3_01other__id_01_4_00_01ct__variable_3_01id_01_4_01_4.html">diff&lt; ct_variable&lt; other_id &gt;, ct_variable&lt; id &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of (d x_i) / (d x_j) for i != j.  <a href="structviennamath_1_1result__of_1_1diff_3_01ct__variable_3_01other__id_01_4_00_01ct__variable_3_01id_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1diff_3_01ct__variable_3_01id_01_4_00_01ct__variable_3_01id_01_4_01_4.html">diff&lt; ct_variable&lt; id &gt;, ct_variable&lt; id &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for (d x) / (d x) = 1.  <a href="structviennamath_1_1result__of_1_1diff_3_01ct__variable_3_01id_01_4_00_01ct__variable_3_01id_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1diff_3_01ct__constant_3_01value_01_4_00_01ct__variable_3_01id_01_4_01_4.html">diff&lt; ct_constant&lt; value &gt;, ct_variable&lt; id &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization: The derivative of a constant is zero.  <a href="structviennamath_1_1result__of_1_1diff_3_01ct__constant_3_01value_01_4_00_01ct__variable_3_01id_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1drop__dependent__terms.html">drop_dependent_terms</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface metafunction for removing dependent terms from an expression.  <a href="structviennamath_1_1result__of_1_1drop__dependent__terms.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__ct__evaluable.html">is_ct_evaluable</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns nonzero if supplied expression can be evaluated at compile time.  <a href="structviennamath_1_1result__of_1_1is__ct__evaluable.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__ct__evaluable_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h_s_01_4_01_4.html">is_ct_evaluable&lt; ct_binary_expr&lt; LHS, OP, RHS &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization: Determines whether a binary expression is compiletime evaluable by recursively acting on the operands.  <a href="structviennamath_1_1result__of_1_1is__ct__evaluable_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h_s_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__ct__evaluable_3_01ct__constant_3_01val_01_4_01_4.html">is_ct_evaluable&lt; ct_constant&lt; val &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization: A constant is compiletime evaluable.  <a href="structviennamath_1_1result__of_1_1is__ct__evaluable_3_01ct__constant_3_01val_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__ct__evaluable_3_01ct__variable_3_01id_01_4_01_4.html">is_ct_evaluable&lt; ct_variable&lt; id &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization: A variable is compiletime evaluable.  <a href="structviennamath_1_1result__of_1_1is__ct__evaluable_3_01ct__variable_3_01id_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__ct__vector.html">is_ct_vector</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns nonzero if the supplied vector type is a compile-time vector.  <a href="structviennamath_1_1result__of_1_1is__ct__vector.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__ct__vector_3_01ct__vector__1_3_01_t0_01_4_01_4.html">is_ct_vector&lt; ct_vector_1&lt; T0 &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the helper function for the determination of whether a vector is a compiletime type.  <a href="structviennamath_1_1result__of_1_1is__ct__vector_3_01ct__vector__1_3_01_t0_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__ct__vector_3_01ct__vector__2_3_01_t0_00_01_t1_01_4_01_4.html">is_ct_vector&lt; ct_vector_2&lt; T0, T1 &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the helper function for the determination of whether a vector is a compiletime type.  <a href="structviennamath_1_1result__of_1_1is__ct__vector_3_01ct__vector__2_3_01_t0_00_01_t1_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__ct__vector_3_01ct__vector__3_3_01_t0_00_01_t1_00_01_t2_01_4_01_4.html">is_ct_vector&lt; ct_vector_3&lt; T0, T1, T2 &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the helper function for the determination of whether a vector is a compiletime type.  <a href="structviennamath_1_1result__of_1_1is__ct__vector_3_01ct__vector__3_3_01_t0_00_01_t1_00_01_t2_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1eval.html">eval</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Main metafunction for compiletime evaluation.  <a href="structviennamath_1_1result__of_1_1eval.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1eval_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h_s_01_db90f7eb7bd2b096d615bcfeb42df358.html">eval&lt; ct_binary_expr&lt; LHS, OP, RHS &gt;, VectorType, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for the evaluation of a binary expression at compile time.  <a href="structviennamath_1_1result__of_1_1eval_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h_s_01_db90f7eb7bd2b096d615bcfeb42df358.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1eval_3_01ct__constant_3_01value_01_4_00_01_vector_type_00_01true_01_4.html">eval&lt; ct_constant&lt; value &gt;, VectorType, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for the evaluation of a constant at compile time.  <a href="structviennamath_1_1result__of_1_1eval_3_01ct__constant_3_01value_01_4_00_01_vector_type_00_01true_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1eval_3_01ct__variable_3_01id_01_4_00_01_vector_type_00_01true_01_4.html">eval&lt; ct_variable&lt; id &gt;, VectorType, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for the evaluation of a variable at compile time.  <a href="structviennamath_1_1result__of_1_1eval_3_01ct__variable_3_01id_01_4_00_01_vector_type_00_01true_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1eval_3_01ct__variable_3_010_01_4_00_01ct__constant_3_01value_01_4_00_01true_01_4.html">eval&lt; ct_variable&lt; 0 &gt;, ct_constant&lt; value &gt;, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for the evaluation of a variable at compile time.  <a href="structviennamath_1_1result__of_1_1eval_3_01ct__variable_3_010_01_4_00_01ct__constant_3_01value_01_4_00_01true_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1expand.html">expand</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The main metafunction for expanding a compiletime expression.  <a href="structviennamath_1_1result__of_1_1expand.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1expand_3_01ct__binary__expr_3_01_l_h_s_00_01op__plus_3_01_numebb7e1f9fd45ab94339a2f0531c5f695c.html">expand&lt; ct_binary_expr&lt; LHS, op_plus&lt; NumericT &gt;, RHS &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for a binary expression (addition): Expand both addends.  <a href="structviennamath_1_1result__of_1_1expand_3_01ct__binary__expr_3_01_l_h_s_00_01op__plus_3_01_numebb7e1f9fd45ab94339a2f0531c5f695c.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1expand_3_01ct__binary__expr_3_01_l_h_s_00_01op__minus_3_01_numeea9524141404cff40a860ffa58b8ffa.html">expand&lt; ct_binary_expr&lt; LHS, op_minus&lt; NumericT &gt;, RHS &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for a binary expression (subtraction): Expand both operands.  <a href="structviennamath_1_1result__of_1_1expand_3_01ct__binary__expr_3_01_l_h_s_00_01op__minus_3_01_numeea9524141404cff40a860ffa58b8ffa.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1expand_3_01ct__binary__expr_3_01_l_h_s_00_01op__mult_3_01_nume1224f84215ff3684f7a545ed2488e312.html">expand&lt; ct_binary_expr&lt; LHS, op_mult&lt; NumericT &gt;, RHS &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for a binary expression (product): Redirect to helper metafunction.  <a href="structviennamath_1_1result__of_1_1expand_3_01ct__binary__expr_3_01_l_h_s_00_01op__mult_3_01_nume1224f84215ff3684f7a545ed2488e312.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1expand_3_01ct__binary__expr_3_01_l_h_s_00_01op__div_3_01_numeric_t_01_4_00_01_r_h_s_01_4_01_4.html">expand&lt; ct_binary_expr&lt; LHS, op_div&lt; NumericT &gt;, RHS &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for a binary expression (division): Expand numerator and denominator of fractional expressions separately.  <a href="structviennamath_1_1result__of_1_1expand_3_01ct__binary__expr_3_01_l_h_s_00_01op__div_3_01_numeric_t_01_4_00_01_r_h_s_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1expand_3_01ct__unary__expr_3_01_l_h_s_00_01_o_p_01_4_01_4.html">expand&lt; ct_unary_expr&lt; LHS, OP &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A unary expression is not expanded further, since the operator is typically nonlinear.  <a href="structviennamath_1_1result__of_1_1expand_3_01ct__unary__expr_3_01_l_h_s_00_01_o_p_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1expand_3_01ct__function__symbol_3_01_t_a_g_01_4_01_4.html">expand&lt; ct_function_symbol&lt; TAG &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A function symbol cannot be further expanded, thus it is returned unmodified.  <a href="structviennamath_1_1result__of_1_1expand_3_01ct__function__symbol_3_01_t_a_g_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1expand_3_01ct__constant_3_01value_01_4_01_4.html">expand&lt; ct_constant&lt; value &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A constant cannot be further expanded, thus it is returned unmodified.  <a href="structviennamath_1_1result__of_1_1expand_3_01ct__constant_3_01value_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1expand_3_01ct__variable_3_01id_01_4_01_4.html">expand&lt; ct_variable&lt; id &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A variable cannot be further expanded, thus it is returned unmodified.  <a href="structviennamath_1_1result__of_1_1expand_3_01ct__variable_3_01id_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1polynomial__degree.html">polynomial_degree</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the power of ct_variable&lt;id&gt; inside an expression.  <a href="structviennamath_1_1result__of_1_1polynomial__degree.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1polynomial__degree_3_01_variable_type_00_01_variable_type_01_4.html">polynomial_degree&lt; VariableType, VariableType &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for the power of a single variable, which is known to be 1.  <a href="structviennamath_1_1result__of_1_1polynomial__degree_3_01_variable_type_00_01_variable_type_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1polynomial__degree_3_01_variable_type_00_01ct__binary__expr_3_c3665fc8f61c26fe040a2219edb47c23.html">polynomial_degree&lt; VariableType, ct_binary_expr&lt; LHS, op_plus&lt; NumericT &gt;, RHS &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for forcing a compile time error if a sum of expressions is encountered.  <a href="structviennamath_1_1result__of_1_1polynomial__degree_3_01_variable_type_00_01ct__binary__expr_3_c3665fc8f61c26fe040a2219edb47c23.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1polynomial__degree_3_01_variable_type_00_01ct__binary__expr_3_fdbaf8c21bf2ae3e8daff8a1f4ebbc70.html">polynomial_degree&lt; VariableType, ct_binary_expr&lt; LHS, op_minus&lt; NumericT &gt;, RHS &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for forcing a compile time error if a difference of expressions is encountered.  <a href="structviennamath_1_1result__of_1_1polynomial__degree_3_01_variable_type_00_01ct__binary__expr_3_fdbaf8c21bf2ae3e8daff8a1f4ebbc70.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1polynomial__degree_3_01_variable_type_00_01ct__binary__expr_3_4297520c494f4bda043f15dd68a7c9c2.html">polynomial_degree&lt; VariableType, ct_binary_expr&lt; LHS, op_mult&lt; NumericT &gt;, RHS &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for a product: The polynomial degree is given by the sum of the polynomial degree of each factor.  <a href="structviennamath_1_1result__of_1_1polynomial__degree_3_01_variable_type_00_01ct__binary__expr_3_4297520c494f4bda043f15dd68a7c9c2.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1polynomial__degree_3_01_variable_type_00_01ct__binary__expr_3_b20424c975b4dadc767ddf0fc1d6c56e.html">polynomial_degree&lt; VariableType, ct_binary_expr&lt; LHS, op_div&lt; NumericT &gt;, RHS &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for a division: The polynomial degree is given by the difference of the polynomial degree of the numerator and the denominator.  <a href="structviennamath_1_1result__of_1_1polynomial__degree_3_01_variable_type_00_01ct__binary__expr_3_b20424c975b4dadc767ddf0fc1d6c56e.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1pow.html">pow</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Metafunction returning the power of an expression. Tries to balance the generated expression tree.  <a href="structviennamath_1_1result__of_1_1pow.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1pow_3_01_t_00_010_01_4.html">pow&lt; T, 0 &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for the zeroth power of an expression.  <a href="structviennamath_1_1result__of_1_1pow_3_01_t_00_010_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1pow_3_01_t_00_011_01_4.html">pow&lt; T, 1 &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for the first power of an expression.  <a href="structviennamath_1_1result__of_1_1pow_3_01_t_00_011_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1pow_3_01_t_00_012_01_4.html">pow&lt; T, 2 &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for the square of an expression.  <a href="structviennamath_1_1result__of_1_1pow_3_01_t_00_012_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1integrate__monomial.html">integrate_monomial</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Metafunction for the integration of a monomial consisting of a single variable.  <a href="structviennamath_1_1result__of_1_1integrate__monomial.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1integrate__monomial_3_01_variable_type_00_010_01_4.html">integrate_monomial&lt; VariableType, 0 &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for the integration of a constant: Return the variable directly.  <a href="structviennamath_1_1result__of_1_1integrate__monomial_3_01_variable_type_00_010_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1integrate.html">integrate</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The main metafunction for the integration of a compiletime expression.  <a href="structviennamath_1_1result__of_1_1integrate.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1integrate_3_01_lower_bound_00_01_upper_bound_00_01ct__binary__c4222aa27a8f7b17f5140ee52a07e1c4.html">integrate&lt; LowerBound, UpperBound, ct_binary_expr&lt; LHS, OP, RHS &gt;, VariableType &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for the integration of a compiletime binary expression.  <a href="structviennamath_1_1result__of_1_1integrate_3_01_lower_bound_00_01_upper_bound_00_01ct__binary__c4222aa27a8f7b17f5140ee52a07e1c4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1integrate_3_01_lower_bound_00_01_upper_bound_00_01ct__unary__efaee4c5ac766cbccfefa4176f3dee264.html">integrate&lt; LowerBound, UpperBound, ct_unary_expr&lt; LHS, OP &gt;, VariableType &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for the integration of a compiletime unary expression. Not supported at the moment, thus a compile time error is forced.  <a href="structviennamath_1_1result__of_1_1integrate_3_01_lower_bound_00_01_upper_bound_00_01ct__unary__efaee4c5ac766cbccfefa4176f3dee264.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1integrate_3_01_lower_bound_00_01_upper_bound_00_01ct__constant02b081c2f089a06c586708c4b92c875a.html">integrate&lt; LowerBound, UpperBound, ct_constant&lt; value &gt;, VariableType &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for the integration of a compile time constant. Forwards the integration to the worker metafunction integrate_impl.  <a href="structviennamath_1_1result__of_1_1integrate_3_01_lower_bound_00_01_upper_bound_00_01ct__constant02b081c2f089a06c586708c4b92c875a.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1integrate_3_01_lower_bound_00_01_upper_bound_00_01ct__function139534101d1214c10af6b9693c6cbd3f.html">integrate&lt; LowerBound, UpperBound, ct_function_symbol&lt; TAG &gt;, VariableType &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for the integration of a compiletime function symbol. This is a user error, since a function symbol should have been replaced already by another expression. Thus, a compile time error is forced.  <a href="structviennamath_1_1result__of_1_1integrate_3_01_lower_bound_00_01_upper_bound_00_01ct__function139534101d1214c10af6b9693c6cbd3f.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1integrate_3_01_lower_bound_00_01_upper_bound_00_01ct__variablea894654a1d801866c901af7b510b4946.html">integrate&lt; LowerBound, UpperBound, ct_variable&lt; id &gt;, VariableType &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for the integration of a compile time variable. Forwards the integration to the worker metafunction integrate_impl.  <a href="structviennamath_1_1result__of_1_1integrate_3_01_lower_bound_00_01_upper_bound_00_01ct__variablea894654a1d801866c901af7b510b4946.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1simplify.html">simplify</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Top-level metafunction for the simplification of expressions. Loops over simplification rules until no more simplifications can be applied.  <a href="structviennamath_1_1result__of_1_1simplify.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1simplify_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h_s_01_4_00_01true_01_4.html">simplify&lt; ct_binary_expr&lt; LHS, OP, RHS &gt;, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for a binary expression, for which optimizations can be applied.  <a href="structviennamath_1_1result__of_1_1simplify_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h_s_01_4_00_01true_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1simplify_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h_s_01_4_00_01false_01_4.html">simplify&lt; ct_binary_expr&lt; LHS, OP, RHS &gt;, false &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for a binary expression, for which no optimizations can be applied: Return the unmodified expression.  <a href="structviennamath_1_1result__of_1_1simplify_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h_s_01_4_00_01false_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1simplify_3_01ct__unary__expr_3_01_l_h_s_00_01_o_p_01_4_00_01true_01_4.html">simplify&lt; ct_unary_expr&lt; LHS, OP &gt;, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for a unary expression, for which optimizations can be applied.  <a href="structviennamath_1_1result__of_1_1simplify_3_01ct__unary__expr_3_01_l_h_s_00_01_o_p_01_4_00_01true_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1simplify_3_01ct__unary__expr_3_01_l_h_s_00_01_o_p_01_4_00_01false_01_4.html">simplify&lt; ct_unary_expr&lt; LHS, OP &gt;, false &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for a unary expression, for which no optimizations can be applied: Return the unmodified expression.  <a href="structviennamath_1_1result__of_1_1simplify_3_01ct__unary__expr_3_01_l_h_s_00_01_o_p_01_4_00_01false_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1simplify_3_01ct__constant_3_01value_01_4_00_01true_01_4.html">simplify&lt; ct_constant&lt; value &gt;, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for a constant, for which optimizations can be applied.  <a href="structviennamath_1_1result__of_1_1simplify_3_01ct__constant_3_01value_01_4_00_01true_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1simplify_3_01ct__constant_3_01value_01_4_00_01false_01_4.html">simplify&lt; ct_constant&lt; value &gt;, false &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for a constant, for which no optimizations can be applied: Return the unmodified constant.  <a href="structviennamath_1_1result__of_1_1simplify_3_01ct__constant_3_01value_01_4_00_01false_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1simplify_3_01ct__function__symbol_3_01_t_a_g_01_4_00_01true_01_4.html">simplify&lt; ct_function_symbol&lt; TAG &gt;, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for a function symbol, for which optimizations can be applied.  <a href="structviennamath_1_1result__of_1_1simplify_3_01ct__function__symbol_3_01_t_a_g_01_4_00_01true_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1simplify_3_01ct__function__symbol_3_01_t_a_g_01_4_00_01false_01_4.html">simplify&lt; ct_function_symbol&lt; TAG &gt;, false &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for a function symbol, for which no optimizations can be applied: Return the unmodified constant.  <a href="structviennamath_1_1result__of_1_1simplify_3_01ct__function__symbol_3_01_t_a_g_01_4_00_01false_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1simplify_3_01ct__variable_3_01id_01_4_00_01true_01_4.html">simplify&lt; ct_variable&lt; id &gt;, true &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for a variable, for which optimizations can be applied.  <a href="structviennamath_1_1result__of_1_1simplify_3_01ct__variable_3_01id_01_4_00_01true_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1simplify_3_01ct__variable_3_01id_01_4_00_01false_01_4.html">simplify&lt; ct_variable&lt; id &gt;, false &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for a compiletime variable, for which no optimizations can be applied: Return the unmodified constant.  <a href="structviennamath_1_1result__of_1_1simplify_3_01ct__variable_3_01id_01_4_00_01false_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1substitute.html">substitute</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default case for the compiletime substitution metafunction: Do not define any return type. This provides SFINAE for the interface function.  <a href="structviennamath_1_1result__of_1_1substitute.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01_search_type_00_01_replacement_type_00_01ct__bi8a26ae43012ec44e7b3eb1374af4669d.html">substitute&lt; SearchType, ReplacementType, ct_binary_expr&lt; LHS, OP, RHS &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For a binary expression, the substitution is performed for both operands.  <a href="structviennamath_1_1result__of_1_1substitute_3_01_search_type_00_01_replacement_type_00_01ct__bi8a26ae43012ec44e7b3eb1374af4669d.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01_search_type_00_01_replacement_type_00_01ct__un0dd76973b9488f668651aa73794c79b9.html">substitute&lt; SearchType, ReplacementType, ct_unary_expr&lt; LHS, OP &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For a unary expression, the substitution is performed for the operand.  <a href="structviennamath_1_1result__of_1_1substitute_3_01_search_type_00_01_replacement_type_00_01ct__un0dd76973b9488f668651aa73794c79b9.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01_search_type_00_01_replacement_type_00_01ct__constant_3_01value_01_4_01_4.html">substitute&lt; SearchType, ReplacementType, ct_constant&lt; value &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">By default, a compiletime constant is left unmodified (no match).  <a href="structviennamath_1_1result__of_1_1substitute_3_01_search_type_00_01_replacement_type_00_01ct__constant_3_01value_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01_search_type_00_01_replacement_type_00_01ct__fuc4542387a2938c39fb0805bb1220ae46.html">substitute&lt; SearchType, ReplacementType, ct_function_symbol&lt; TAG &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">By default, a compiletime function symbol is left unmodified (no match).  <a href="structviennamath_1_1result__of_1_1substitute_3_01_search_type_00_01_replacement_type_00_01ct__fuc4542387a2938c39fb0805bb1220ae46.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01_search_type_00_01_replacement_type_00_01ct__variable_3_01id_01_4_01_4.html">substitute&lt; SearchType, ReplacementType, ct_variable&lt; id &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">By default, a compiletime variable is left unmodified (no match).  <a href="structviennamath_1_1result__of_1_1substitute_3_01_search_type_00_01_replacement_type_00_01ct__variable_3_01id_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h0f87136a71f9c909af6daee650d850ae.html">substitute&lt; ct_binary_expr&lt; LHS, OP, RHS &gt;, ReplacementType, ct_binary_expr&lt; LHS, OP, RHS &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If there is a match for the binary expression, the replacement is returned.  <a href="structviennamath_1_1result__of_1_1substitute_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h0f87136a71f9c909af6daee650d850ae.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01ct__unary__expr_3_01_l_h_s_00_01_o_p_01_4_00_01cbe037ca3f825a32f06c7ffee55d38e2.html">substitute&lt; ct_unary_expr&lt; LHS, OP &gt;, ReplacementType, ct_unary_expr&lt; LHS, OP &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If there is a match for the unary expression, the replacement is returned.  <a href="structviennamath_1_1result__of_1_1substitute_3_01ct__unary__expr_3_01_l_h_s_00_01_o_p_01_4_00_01cbe037ca3f825a32f06c7ffee55d38e2.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01ct__constant_3_01value_01_4_00_01_replacement_t36a9dee6096d8d038c95b59e92d1fadc.html">substitute&lt; ct_constant&lt; value &gt;, ReplacementType, ct_constant&lt; value &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If there is a match for the compiletime constant, the replacement is returned.  <a href="structviennamath_1_1result__of_1_1substitute_3_01ct__constant_3_01value_01_4_00_01_replacement_t36a9dee6096d8d038c95b59e92d1fadc.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01ct__function__symbol_3_01_t_a_g_01_4_00_01_repl533efeac83c878388aa392e01e71cdbe.html">substitute&lt; ct_function_symbol&lt; TAG &gt;, ReplacementType, ct_function_symbol&lt; TAG &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If there is a match for the compiletime function symbol, the replacement is returned.  <a href="structviennamath_1_1result__of_1_1substitute_3_01ct__function__symbol_3_01_t_a_g_01_4_00_01_repl533efeac83c878388aa392e01e71cdbe.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1substitute_3_01ct__variable_3_01id_01_4_00_01_replacement_typeddebcd8dd4169a510fb84cc21bdffaa5.html">substitute&lt; ct_variable&lt; id &gt;, ReplacementType, ct_variable&lt; id &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If there is a match for the compiletime variable, the replacement is returned.  <a href="structviennamath_1_1result__of_1_1substitute_3_01ct__variable_3_01id_01_4_00_01_replacement_typeddebcd8dd4169a510fb84cc21bdffaa5.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1add.html">add</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the type of adding two expressions together. Default case: both types are runtime expressions.  <a href="structviennamath_1_1result__of_1_1add.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1subtract.html">subtract</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the type when subtracting two expressions. Default case: both types are runtime expressions.  <a href="structviennamath_1_1result__of_1_1subtract.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1mult.html">mult</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the type when multiplying two expressions. Default case: both types are runtime expressions.  <a href="structviennamath_1_1result__of_1_1mult.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1div.html">div</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the type when dividing two expressions. Default case: both types are runtime expressions.  <a href="structviennamath_1_1result__of_1_1div.html#_details">More...</a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The namespace containing a set of metafunctions which can be used by the ViennaMath library user. </p>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Feb 29 2012 21:50:44 for ViennaMath by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
