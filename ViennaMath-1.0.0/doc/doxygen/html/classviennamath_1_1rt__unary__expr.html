<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ViennaMath: rt_unary_expr&lt; InterfaceType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceviennamath.html">viennamath</a>      </li>
      <li><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr&lt; InterfaceType &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>rt_unary_expr&lt; InterfaceType &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="viennamath::rt_unary_expr" -->
<p>Runtime representation of a unary expression F(e), where F is a function of one argument (e.g. <a class="el" href="namespaceviennamath.html#aeb237d8f5686e7cddc50e8b2dc5a703e" title="Overload of the natural logarithm function for a ViennaMath runtime constant.">log()</a>) and e is an expression.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="unary__expr_8hpp_source.html">unary_expr.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef InterfaceType::numeric_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#a9a3ec54998d3fed8c0bfab252e6c8743">rt_unary_expr</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#a70ddd7aa6c3760de1225e52df95b676f">rt_unary_expr</a> (InterfaceType *lhs, <a class="el" href="classviennamath_1_1op__interface.html">op_interface_type</a> *op)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#a12c363266dfcd5734ffc37a3f9e0b067">rt_unary_expr</a> (InterfaceType *lhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#adb4284e485c72f0595c8b6add7484482">rt_unary_expr</a> (<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS, OP &gt; const &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#a105dbf7c2b093d721a31995284590734">rt_unary_expr</a> (<a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#adcd53168b2d2ee55afecac641cc15771">rt_unary_expr</a> (<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; T, InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#ad9ac9830017ff2b6db4bd90c09f7a2ec">rt_unary_expr</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; const &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#a8e2808a1968ce6d398e9af6364d7cb3a">rt_unary_expr</a> (<a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> const &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#a501ca64c8c691b2c8be34cc8a85d5189">operator=</a> (<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS, OP &gt; const &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#a434d9f91227becc38fe469082cc2a542">operator=</a> (<a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> const &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#a1927aa56de66f4231205954f53014882">operator=</a> (<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; ScalarType &gt; const &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#a492dca3509df256b004fcbb3b5280a5a">operator=</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; const &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#ace5d7ce59957527ac6dfc861a0ea1e98">operator=</a> (<a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const InterfaceType *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#a3a96e11a960eada0d735489e0c8d8502">lhs</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the expression the unary function is acting on.  <a href="#a3a96e11a960eada0d735489e0c8d8502"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classviennamath_1_1op__interface.html">op_interface_type</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#abfec25af46dbb1adc54d2ea82014091d">op</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the operation.  <a href="#abfec25af46dbb1adc54d2ea82014091d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#a535b2cea005dd1f83b06574ac330b490">operator()</a> (<a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> val) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation of the unary expression at val (i.e. all variables with ID 0 replaced by 'val').  <a href="#a535b2cea005dd1f83b06574ac330b490"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#ae8b3029ade284c73f25e13e29bed3fb0">operator()</a> (<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; ScalarType &gt; val) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation of the unary expression at the ViennaMath runtime constant val.  <a href="#ae8b3029ade284c73f25e13e29bed3fb0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#a84045268ea59d8afd1ceea5f52212828">operator()</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; val) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation of the unary expression at the ViennaMath compiletime constant val.  <a href="#a84045268ea59d8afd1ceea5f52212828"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#aca487724a49d673ada415f4fabf90396">operator()</a> (VectorType const &amp;v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation of the unary expression at the vector v.  <a href="#aca487724a49d673ada415f4fabf90396"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#a1af492acb60f4c89f721786fe9e22500">operator()</a> (std::vector&lt; <a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> &gt; const &amp;stl_v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation of the unary expression at the STL vector v.  <a href="#a1af492acb60f4c89f721786fe9e22500"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T0 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#a8657c5bfeb163487365fe4b4d32013ab">operator()</a> (<a class="el" href="classviennamath_1_1ct__vector__1.html">viennamath::ct_vector_1</a>&lt; T0 &gt; const &amp;v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation of the unary expression at a ViennaMath compiletime vector with one entry.  <a href="#a8657c5bfeb163487365fe4b4d32013ab"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#aa69212f57caede7ab1c0924077a35c01">operator()</a> (<a class="el" href="classviennamath_1_1ct__vector__2.html">viennamath::ct_vector_2</a>&lt; T0, T1 &gt; const &amp;v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation of the unary expression at a ViennaMath compiletime vector with two entries.  <a href="#aa69212f57caede7ab1c0924077a35c01"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#a630dc569e5e70d8598c004ba17e40052">operator()</a> (<a class="el" href="classviennamath_1_1ct__vector__3.html">viennamath::ct_vector_3</a>&lt; T0, T1, T2 &gt; const &amp;v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation of the unary expression at a ViennaMath compiletime vector with three entries.  <a href="#a630dc569e5e70d8598c004ba17e40052"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#a2454285b42067b2aebb6464d97984b43">eval</a> (std::vector&lt; double &gt; const &amp;v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation of the unary expression at an STL vector. Interface requirement.  <a href="#a2454285b42067b2aebb6464d97984b43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#a462af8a4a68e81745043afc5d85fa084">eval</a> (<a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> val) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation of the unary expression for a numerical constant. Interface requirement.  <a href="#a462af8a4a68e81745043afc5d85fa084"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#ac9ba83bd4006d2e828faefc2c589d388">simplify</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a simplified expression with trivial operations removed. The caller is responsible for deleting the object the returned pointer refers to.  <a href="#ac9ba83bd4006d2e828faefc2c589d388"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#a753df58aef455c024be3bd466ef3ff04">can_simplify</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the expression can be simplified.  <a href="#a753df58aef455c024be3bd466ef3ff04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#a0435646b1c18de1b989a2a77dcb2d616">clone</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a copy of the unary expression. The caller is responsible for deleting the returned object.  <a href="#a0435646b1c18de1b989a2a77dcb2d616"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#a757539267b058a2d6754bf173e4a990a">deep_str</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a detailed string describing the unary expression. Acts recursively.  <a href="#a757539267b058a2d6754bf173e4a990a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#a3e1ee39aae8ba0a136e5df3d1bcbafa9">shallow_str</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a short string describing the unary expression. Does not act recursively.  <a href="#a3e1ee39aae8ba0a136e5df3d1bcbafa9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#a76dd43b43453913b05bec0ee2a388d9b">unwrap</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reduces the expression to a constant. If this is not possible, an <a class="el" href="classviennamath_1_1expression__not__unwrappable__exception.html" title="An exception which is thrown if an expression should be reduced to a floating point number using unwr...">expression_not_unwrappable_exception</a> is thrown.  <a href="#a76dd43b43453913b05bec0ee2a388d9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#a6a07aa38dede368e472cdb3d5d80e33a">substitute</a> (const InterfaceType *e, const InterfaceType *repl) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If 'e' equals to this unary expression, the replacement 'repl' is returned. Otherwise, the unary expression is cloned. Note that the caller must ensure proper deletion of the returned object.  <a href="#a6a07aa38dede368e472cdb3d5d80e33a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#aa3df2bf384f896088c5c88e8929aa0fe">substitute</a> (std::vector&lt; const InterfaceType * &gt; const &amp;e, std::vector&lt; const InterfaceType * &gt; const &amp;repl) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If one of the expressions in 'e' equals to this unary expression, the respective replacement 'repl' is returned. Otherwise, a copy of *this is returned. Note that the caller must ensure proper deletion of the returned object.  <a href="#aa3df2bf384f896088c5c88e8929aa0fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#a745452704b3e9127ab1659a21364c5b2">deep_equal</a> (const InterfaceType *other) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a detailed comparison of the unary expression with the passed expression. Returns true if they represent the same expression (equal IDs, etc.).  <a href="#a745452704b3e9127ab1659a21364c5b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#a1699a4075b9d4a0890169c568b251f47">shallow_equal</a> (const InterfaceType *other) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the passed expression is of the same type as this expression.  <a href="#a1699a4075b9d4a0890169c568b251f47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#a67776162d4107636e41aa74e04b86a8f">diff</a> (const InterfaceType *diff_var) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the derivative of this unary expression with respect to the variable 'diff_var'. The returned object must be deleted by the caller.  <a href="#a67776162d4107636e41aa74e04b86a8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#a03c4b8cfffcfaeb90256612cb1847633">recursive_manipulation</a> (<a class="el" href="classviennamath_1_1rt__manipulation__wrapper.html">rt_manipulation_wrapper</a>&lt; InterfaceType &gt; const &amp;fw) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recursively manipulates the expression. If this expression is manipulated, the result is returned directly. Otherwise, the manipulator continues with the expression the unary operation is acting on. The returned object must be deleted by the caller.  <a href="#a03c4b8cfffcfaeb90256612cb1847633"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html#a57fa2f40f67c85f8f57a168d44a41e58">recursive_traversal</a> (<a class="el" href="classviennamath_1_1rt__traversal__wrapper.html">rt_traversal_wrapper</a>&lt; InterfaceType &gt; const &amp;fw) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recursively traverses the expression by calling the wrapper for each object without manipulating it.  <a href="#a57fa2f40f67c85f8f57a168d44a41e58"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename InterfaceType&gt;<br/>
 class viennamath::rt_unary_expr&lt; InterfaceType &gt;</h3>

<p>Runtime representation of a unary expression F(e), where F is a function of one argument (e.g. <a class="el" href="namespaceviennamath.html#aeb237d8f5686e7cddc50e8b2dc5a703e" title="Overload of the natural logarithm function for a ViennaMath runtime constant.">log()</a>) and e is an expression. </p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InterfaceType</em>&nbsp;</td><td>The expression runtime interface to inherit from. Usually <a class="el" href="classviennamath_1_1rt__expression__interface.html" title="Abstract interface for all ViennaMath runtime expressions.">rt_expression_interface</a>, but extensions are possible. </td></tr>
  </table>
  </dd>
</dl>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="afb5ce2ac2be0c7efb30e536b8edd4c30"></a><!-- doxytag: member="viennamath::rt_unary_expr::numeric_type" ref="afb5ce2ac2be0c7efb30e536b8edd4c30" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InterfaceType::numeric_type <a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9a3ec54998d3fed8c0bfab252e6c8743"></a><!-- doxytag: member="viennamath::rt_unary_expr::rt_unary_expr" ref="a9a3ec54998d3fed8c0bfab252e6c8743" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a70ddd7aa6c3760de1225e52df95b676f"></a><!-- doxytag: member="viennamath::rt_unary_expr::rt_unary_expr" ref="a70ddd7aa6c3760de1225e52df95b676f" args="(InterfaceType *lhs, op_interface_type *op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> </td>
          <td>(</td>
          <td class="paramtype">InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1op__interface.html">op_interface_type</a> *&nbsp;</td>
          <td class="paramname"> <em>op</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a12c363266dfcd5734ffc37a3f9e0b067"></a><!-- doxytag: member="viennamath::rt_unary_expr::rt_unary_expr" ref="a12c363266dfcd5734ffc37a3f9e0b067" args="(InterfaceType *lhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> </td>
          <td>(</td>
          <td class="paramtype">InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>lhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adb4284e485c72f0595c8b6add7484482"></a><!-- doxytag: member="viennamath::rt_unary_expr::rt_unary_expr" ref="adb4284e485c72f0595c8b6add7484482" args="(ct_unary_expr&lt; LHS, OP &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS, OP &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a105dbf7c2b093d721a31995284590734"></a><!-- doxytag: member="viennamath::rt_unary_expr::rt_unary_expr" ref="a105dbf7c2b093d721a31995284590734" args="(rt_variable&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adcd53168b2d2ee55afecac641cc15771"></a><!-- doxytag: member="viennamath::rt_unary_expr::rt_unary_expr" ref="adcd53168b2d2ee55afecac641cc15771" args="(rt_constant&lt; T, InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; T, InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad9ac9830017ff2b6db4bd90c09f7a2ec"></a><!-- doxytag: member="viennamath::rt_unary_expr::rt_unary_expr" ref="ad9ac9830017ff2b6db4bd90c09f7a2ec" args="(ct_constant&lt; value &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8e2808a1968ce6d398e9af6364d7cb3a"></a><!-- doxytag: member="viennamath::rt_unary_expr::rt_unary_expr" ref="a8e2808a1968ce6d398e9af6364d7cb3a" args="(rt_unary_expr const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a753df58aef455c024be3bd466ef3ff04"></a><!-- doxytag: member="viennamath::rt_unary_expr::can_simplify" ref="a753df58aef455c024be3bd466ef3ff04" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool can_simplify </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the expression can be simplified. </p>

</div>
</div>
<a class="anchor" id="a0435646b1c18de1b989a2a77dcb2d616"></a><!-- doxytag: member="viennamath::rt_unary_expr::clone" ref="a0435646b1c18de1b989a2a77dcb2d616" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType* clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a copy of the unary expression. The caller is responsible for deleting the returned object. </p>

</div>
</div>
<a class="anchor" id="a745452704b3e9127ab1659a21364c5b2"></a><!-- doxytag: member="viennamath::rt_unary_expr::deep_equal" ref="a745452704b3e9127ab1659a21364c5b2" args="(const InterfaceType *other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool deep_equal </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a detailed comparison of the unary expression with the passed expression. Returns true if they represent the same expression (equal IDs, etc.). </p>

</div>
</div>
<a class="anchor" id="a757539267b058a2d6754bf173e4a990a"></a><!-- doxytag: member="viennamath::rt_unary_expr::deep_str" ref="a757539267b058a2d6754bf173e4a990a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string deep_str </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a detailed string describing the unary expression. Acts recursively. </p>

</div>
</div>
<a class="anchor" id="a67776162d4107636e41aa74e04b86a8f"></a><!-- doxytag: member="viennamath::rt_unary_expr::diff" ref="a67776162d4107636e41aa74e04b86a8f" args="(const InterfaceType *diff_var) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType* diff </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>diff_var</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the derivative of this unary expression with respect to the variable 'diff_var'. The returned object must be deleted by the caller. </p>

</div>
</div>
<a class="anchor" id="a462af8a4a68e81745043afc5d85fa084"></a><!-- doxytag: member="viennamath::rt_unary_expr::eval" ref="a462af8a4a68e81745043afc5d85fa084" args="(numeric_type val) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> eval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluation of the unary expression for a numerical constant. Interface requirement. </p>

</div>
</div>
<a class="anchor" id="a2454285b42067b2aebb6464d97984b43"></a><!-- doxytag: member="viennamath::rt_unary_expr::eval" ref="a2454285b42067b2aebb6464d97984b43" args="(std::vector&lt; double &gt; const &amp;v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> eval </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluation of the unary expression at an STL vector. Interface requirement. </p>

</div>
</div>
<a class="anchor" id="a3a96e11a960eada0d735489e0c8d8502"></a><!-- doxytag: member="viennamath::rt_unary_expr::lhs" ref="a3a96e11a960eada0d735489e0c8d8502" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const InterfaceType* lhs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the expression the unary function is acting on. </p>

</div>
</div>
<a class="anchor" id="abfec25af46dbb1adc54d2ea82014091d"></a><!-- doxytag: member="viennamath::rt_unary_expr::op" ref="abfec25af46dbb1adc54d2ea82014091d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classviennamath_1_1op__interface.html">op_interface_type</a>* op </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the operation. </p>

</div>
</div>
<a class="anchor" id="a535b2cea005dd1f83b06574ac330b490"></a><!-- doxytag: member="viennamath::rt_unary_expr::operator()" ref="a535b2cea005dd1f83b06574ac330b490" args="(numeric_type val) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluation of the unary expression at val (i.e. all variables with ID 0 replaced by 'val'). </p>

</div>
</div>
<a class="anchor" id="ae8b3029ade284c73f25e13e29bed3fb0"></a><!-- doxytag: member="viennamath::rt_unary_expr::operator()" ref="ae8b3029ade284c73f25e13e29bed3fb0" args="(rt_constant&lt; ScalarType &gt; val) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; ScalarType &gt;&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluation of the unary expression at the ViennaMath runtime constant val. </p>

</div>
</div>
<a class="anchor" id="a84045268ea59d8afd1ceea5f52212828"></a><!-- doxytag: member="viennamath::rt_unary_expr::operator()" ref="a84045268ea59d8afd1ceea5f52212828" args="(ct_constant&lt; value &gt; val) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt;&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluation of the unary expression at the ViennaMath compiletime constant val. </p>

</div>
</div>
<a class="anchor" id="aca487724a49d673ada415f4fabf90396"></a><!-- doxytag: member="viennamath::rt_unary_expr::operator()" ref="aca487724a49d673ada415f4fabf90396" args="(VectorType const &amp;v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> operator() </td>
          <td>(</td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluation of the unary expression at the vector v. </p>

</div>
</div>
<a class="anchor" id="a1af492acb60f4c89f721786fe9e22500"></a><!-- doxytag: member="viennamath::rt_unary_expr::operator()" ref="a1af492acb60f4c89f721786fe9e22500" args="(std::vector&lt; numeric_type &gt; const &amp;stl_v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> operator() </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>stl_v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluation of the unary expression at the STL vector v. </p>

</div>
</div>
<a class="anchor" id="a8657c5bfeb163487365fe4b4d32013ab"></a><!-- doxytag: member="viennamath::rt_unary_expr::operator()" ref="a8657c5bfeb163487365fe4b4d32013ab" args="(viennamath::ct_vector_1&lt; T0 &gt; const &amp;v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1ct__vector__1.html">viennamath::ct_vector_1</a>&lt; T0 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluation of the unary expression at a ViennaMath compiletime vector with one entry. </p>

</div>
</div>
<a class="anchor" id="aa69212f57caede7ab1c0924077a35c01"></a><!-- doxytag: member="viennamath::rt_unary_expr::operator()" ref="aa69212f57caede7ab1c0924077a35c01" args="(viennamath::ct_vector_2&lt; T0, T1 &gt; const &amp;v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1ct__vector__2.html">viennamath::ct_vector_2</a>&lt; T0, T1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluation of the unary expression at a ViennaMath compiletime vector with two entries. </p>

</div>
</div>
<a class="anchor" id="a630dc569e5e70d8598c004ba17e40052"></a><!-- doxytag: member="viennamath::rt_unary_expr::operator()" ref="a630dc569e5e70d8598c004ba17e40052" args="(viennamath::ct_vector_3&lt; T0, T1, T2 &gt; const &amp;v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1ct__vector__3.html">viennamath::ct_vector_3</a>&lt; T0, T1, T2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluation of the unary expression at a ViennaMath compiletime vector with three entries. </p>

</div>
</div>
<a class="anchor" id="a492dca3509df256b004fcbb3b5280a5a"></a><!-- doxytag: member="viennamath::rt_unary_expr::operator=" ref="a492dca3509df256b004fcbb3b5280a5a" args="(ct_constant&lt; value &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a434d9f91227becc38fe469082cc2a542"></a><!-- doxytag: member="viennamath::rt_unary_expr::operator=" ref="a434d9f91227becc38fe469082cc2a542" args="(rt_unary_expr const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ace5d7ce59957527ac6dfc861a0ea1e98"></a><!-- doxytag: member="viennamath::rt_unary_expr::operator=" ref="ace5d7ce59957527ac6dfc861a0ea1e98" args="(numeric_type value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1927aa56de66f4231205954f53014882"></a><!-- doxytag: member="viennamath::rt_unary_expr::operator=" ref="a1927aa56de66f4231205954f53014882" args="(rt_constant&lt; ScalarType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; ScalarType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a501ca64c8c691b2c8be34cc8a85d5189"></a><!-- doxytag: member="viennamath::rt_unary_expr::operator=" ref="a501ca64c8c691b2c8be34cc8a85d5189" args="(ct_unary_expr&lt; LHS, OP &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS, OP &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a03c4b8cfffcfaeb90256612cb1847633"></a><!-- doxytag: member="viennamath::rt_unary_expr::recursive_manipulation" ref="a03c4b8cfffcfaeb90256612cb1847633" args="(rt_manipulation_wrapper&lt; InterfaceType &gt; const &amp;fw) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType* recursive_manipulation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1rt__manipulation__wrapper.html">rt_manipulation_wrapper</a>&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>fw</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recursively manipulates the expression. If this expression is manipulated, the result is returned directly. Otherwise, the manipulator continues with the expression the unary operation is acting on. The returned object must be deleted by the caller. </p>

</div>
</div>
<a class="anchor" id="a57fa2f40f67c85f8f57a168d44a41e58"></a><!-- doxytag: member="viennamath::rt_unary_expr::recursive_traversal" ref="a57fa2f40f67c85f8f57a168d44a41e58" args="(rt_traversal_wrapper&lt; InterfaceType &gt; const &amp;fw) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void recursive_traversal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1rt__traversal__wrapper.html">rt_traversal_wrapper</a>&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>fw</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recursively traverses the expression by calling the wrapper for each object without manipulating it. </p>

</div>
</div>
<a class="anchor" id="a1699a4075b9d4a0890169c568b251f47"></a><!-- doxytag: member="viennamath::rt_unary_expr::shallow_equal" ref="a1699a4075b9d4a0890169c568b251f47" args="(const InterfaceType *other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool shallow_equal </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the passed expression is of the same type as this expression. </p>

</div>
</div>
<a class="anchor" id="a3e1ee39aae8ba0a136e5df3d1bcbafa9"></a><!-- doxytag: member="viennamath::rt_unary_expr::shallow_str" ref="a3e1ee39aae8ba0a136e5df3d1bcbafa9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string shallow_str </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a short string describing the unary expression. Does not act recursively. </p>

</div>
</div>
<a class="anchor" id="ac9ba83bd4006d2e828faefc2c589d388"></a><!-- doxytag: member="viennamath::rt_unary_expr::simplify" ref="ac9ba83bd4006d2e828faefc2c589d388" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType* simplify </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a simplified expression with trivial operations removed. The caller is responsible for deleting the object the returned pointer refers to. </p>

</div>
</div>
<a class="anchor" id="aa3df2bf384f896088c5c88e8929aa0fe"></a><!-- doxytag: member="viennamath::rt_unary_expr::substitute" ref="aa3df2bf384f896088c5c88e8929aa0fe" args="(std::vector&lt; const InterfaceType * &gt; const &amp;e, std::vector&lt; const InterfaceType * &gt; const &amp;repl) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType* substitute </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const InterfaceType * &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const InterfaceType * &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>repl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If one of the expressions in 'e' equals to this unary expression, the respective replacement 'repl' is returned. Otherwise, a copy of *this is returned. Note that the caller must ensure proper deletion of the returned object. </p>

</div>
</div>
<a class="anchor" id="a6a07aa38dede368e472cdb3d5d80e33a"></a><!-- doxytag: member="viennamath::rt_unary_expr::substitute" ref="a6a07aa38dede368e472cdb3d5d80e33a" args="(const InterfaceType *e, const InterfaceType *repl) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType* substitute </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>repl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If 'e' equals to this unary expression, the replacement 'repl' is returned. Otherwise, the unary expression is cloned. Note that the caller must ensure proper deletion of the returned object. </p>

</div>
</div>
<a class="anchor" id="a76dd43b43453913b05bec0ee2a388d9b"></a><!-- doxytag: member="viennamath::rt_unary_expr::unwrap" ref="a76dd43b43453913b05bec0ee2a388d9b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html#afb5ce2ac2be0c7efb30e536b8edd4c30">numeric_type</a> unwrap </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reduces the expression to a constant. If this is not possible, an <a class="el" href="classviennamath_1_1expression__not__unwrappable__exception.html" title="An exception which is thrown if an expression should be reduced to a floating point number using unwr...">expression_not_unwrappable_exception</a> is thrown. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/export/development/ViennaMath/viennamath/runtime/<a class="el" href="unary__expr_8hpp_source.html">unary_expr.hpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Feb 29 2012 21:50:44 for ViennaMath by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
