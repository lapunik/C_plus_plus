<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ViennaMath: rt_expression_interface&lt; NumericT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceviennamath.html">viennamath</a>      </li>
      <li><a class="el" href="classviennamath_1_1rt__expression__interface.html">rt_expression_interface&lt; NumericT &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>rt_expression_interface&lt; NumericT &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="viennamath::rt_expression_interface" -->
<p>Abstract interface for all ViennaMath runtime expressions.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="expression__interface_8hpp_source.html">expression_interface.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef NumericT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__expression__interface.html#abae98c4a1262fc472e91a6261416c3b9">numeric_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The underlying numeric type of all arithmetical operations (typically 'double').  <a href="#abae98c4a1262fc472e91a6261416c3b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classviennamath_1_1rt__expression__interface.html">rt_expression_interface</a><br class="typebreak"/>
&lt; NumericT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__expression__interface.html#a95af5658c095b07f86124d8370f9e484">interface_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The interface type of the respective expression.  <a href="#a95af5658c095b07f86124d8370f9e484"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__expression__interface.html#a51d046767319fa18f83b65cd9bc330dd">~rt_expression_interface</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__expression__interface.html#a7c145828afb07651e43183af4bb19fb4">clone</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to a copy of the expression. The caller must ensure the deletion of the returned copy.  <a href="#a7c145828afb07651e43183af4bb19fb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__expression__interface.html#ad7ff9550791a1d70662cb062ba4b3ea0">deep_str</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a detailed string fully identifying the expression.  <a href="#ad7ff9550791a1d70662cb062ba4b3ea0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__expression__interface.html#a55058da3e0c9d61661c0943f77723d21">shallow_str</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a short string identifying just the type of the expression.  <a href="#a55058da3e0c9d61661c0943f77723d21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual NumericT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__expression__interface.html#a70fea3313429e6e70d8071335ccf8d7d">eval</a> (std::vector&lt; NumericT &gt; const &amp;v) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluates the expression at the given vector.  <a href="#a70fea3313429e6e70d8071335ccf8d7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual NumericT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__expression__interface.html#a8f5ce9c582414d43e56584c0caa42c8f">eval</a> (NumericT val) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluates an expression taking one variable only.  <a href="#a8f5ce9c582414d43e56584c0caa42c8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__expression__interface.html#af625108815456e0f5b28b6e05f0aefee">is_unary</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true, if the expression is a unary expression.  <a href="#af625108815456e0f5b28b6e05f0aefee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__expression__interface.html#a52978a447ae55b7ab3511159ac6b224b">is_constant</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true, if the expression can be evaluated without providing values for variables (i.e. the expression is a constant).  <a href="#a52978a447ae55b7ab3511159ac6b224b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual NumericT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__expression__interface.html#a05289afe5f76f1d6612817d15a5732ce">unwrap</a> () const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the numeric value of the expression.  <a href="#a05289afe5f76f1d6612817d15a5732ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__expression__interface.html#a9d4f54ff84607bb3cb46b2f60790f644">shallow_equal</a> (const <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a> *other) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks the current expression for being equal to 'other'. Checks for same type only, does not check members.  <a href="#a9d4f54ff84607bb3cb46b2f60790f644"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__expression__interface.html#ad73755b4034a3a508100e72a19abb455">deep_equal</a> (const <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a> *other) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks the current expression for being equal to 'other'. Performs a deep check for equality of members.  <a href="#ad73755b4034a3a508100e72a19abb455"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__expression__interface.html#ac35f8679be9e98493b22ccbfc1419043">recursive_manipulation</a> (<a class="el" href="classviennamath_1_1rt__manipulation__wrapper.html">rt_manipulation_wrapper</a>&lt; <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a> &gt; const &amp;fw) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides a common interface for top-down manipulations of the expression.  <a href="#ac35f8679be9e98493b22ccbfc1419043"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__expression__interface.html#a30d3b69da65e719adb77e9b652d6a213">recursive_traversal</a> (<a class="el" href="classviennamath_1_1rt__traversal__wrapper.html">rt_traversal_wrapper</a>&lt; <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a> &gt; const &amp;fw) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides a common interface for all top-down traversals of the expression.  <a href="#a30d3b69da65e719adb77e9b652d6a213"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__expression__interface.html#aa9ff08fde6da6835f852b22edb2b55b5">substitute</a> (const <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a> *e, const <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a> *repl) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a new expression with all occurrences of 'e' replaced by 'repl'. The caller must ensure the deletion of the object the returned pointer is referring to.  <a href="#aa9ff08fde6da6835f852b22edb2b55b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__expression__interface.html#a6ced643d1963182684b9dcf683d761c5">substitute</a> (std::vector&lt; const <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a> * &gt; const &amp;e, std::vector&lt; const <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a> * &gt; const &amp;repl) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a expression with all occurrances of 'e' in the expression substituted by the respective replacement in 'repl'. The caller must ensure the deletion of the object the returned pointer is referring to.  <a href="#a6ced643d1963182684b9dcf683d761c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__expression__interface.html#a1c1e3470e3246cf855fb3dcdbdf554ec">simplify</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an optimized expression, where trivial operations such as multiplications by unity are removed. The caller must ensure the deletion of the object the returned pointer is referring to.  <a href="#a1c1e3470e3246cf855fb3dcdbdf554ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__expression__interface.html#ac3a9020749ab22597ce846b3038b8318">can_simplify</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the experssion can be further optimized.  <a href="#ac3a9020749ab22597ce846b3038b8318"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__expression__interface.html#aad3fb5b121f9a522473e479d06219781">diff</a> (const <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a> *diff_var) const =0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the expression differentiated with respect to the provided variable. The caller must ensure the deletion of the object the returned pointer is referring to.  <a href="#aad3fb5b121f9a522473e479d06219781"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename NumericT&gt;<br/>
 class viennamath::rt_expression_interface&lt; NumericT &gt;</h3>

<p>Abstract interface for all ViennaMath runtime expressions. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a95af5658c095b07f86124d8370f9e484"></a><!-- doxytag: member="viennamath::rt_expression_interface::interface_type" ref="a95af5658c095b07f86124d8370f9e484" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennamath_1_1rt__expression__interface.html">rt_expression_interface</a>&lt;NumericT&gt; <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The interface type of the respective expression. </p>

</div>
</div>
<a class="anchor" id="abae98c4a1262fc472e91a6261416c3b9"></a><!-- doxytag: member="viennamath::rt_expression_interface::numeric_type" ref="abae98c4a1262fc472e91a6261416c3b9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef NumericT <a class="el" href="classviennamath_1_1rt__expression__interface.html#abae98c4a1262fc472e91a6261416c3b9">numeric_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The underlying numeric type of all arithmetical operations (typically 'double'). </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a51d046767319fa18f83b65cd9bc330dd"></a><!-- doxytag: member="viennamath::rt_expression_interface::~rt_expression_interface" ref="a51d046767319fa18f83b65cd9bc330dd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="classviennamath_1_1rt__expression__interface.html">rt_expression_interface</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac3a9020749ab22597ce846b3038b8318"></a><!-- doxytag: member="viennamath::rt_expression_interface::can_simplify" ref="ac3a9020749ab22597ce846b3038b8318" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool can_simplify </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the experssion can be further optimized. </p>

</div>
</div>
<a class="anchor" id="a7c145828afb07651e43183af4bb19fb4"></a><!-- doxytag: member="viennamath::rt_expression_interface::clone" ref="a7c145828afb07651e43183af4bb19fb4" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a>* clone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a pointer to a copy of the expression. The caller must ensure the deletion of the returned copy. </p>

</div>
</div>
<a class="anchor" id="ad73755b4034a3a508100e72a19abb455"></a><!-- doxytag: member="viennamath::rt_expression_interface::deep_equal" ref="ad73755b4034a3a508100e72a19abb455" args="(const interface_type *other) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool deep_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a> *&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks the current expression for being equal to 'other'. Performs a deep check for equality of members. </p>

</div>
</div>
<a class="anchor" id="ad7ff9550791a1d70662cb062ba4b3ea0"></a><!-- doxytag: member="viennamath::rt_expression_interface::deep_str" ref="ad7ff9550791a1d70662cb062ba4b3ea0" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string deep_str </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a detailed string fully identifying the expression. </p>

</div>
</div>
<a class="anchor" id="aad3fb5b121f9a522473e479d06219781"></a><!-- doxytag: member="viennamath::rt_expression_interface::diff" ref="aad3fb5b121f9a522473e479d06219781" args="(const interface_type *diff_var) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a>* diff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a> *&nbsp;</td>
          <td class="paramname"> <em>diff_var</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the expression differentiated with respect to the provided variable. The caller must ensure the deletion of the object the returned pointer is referring to. </p>

</div>
</div>
<a class="anchor" id="a70fea3313429e6e70d8071335ccf8d7d"></a><!-- doxytag: member="viennamath::rt_expression_interface::eval" ref="a70fea3313429e6e70d8071335ccf8d7d" args="(std::vector&lt; NumericT &gt; const &amp;v) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual NumericT eval </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; NumericT &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluates the expression at the given vector. </p>

</div>
</div>
<a class="anchor" id="a8f5ce9c582414d43e56584c0caa42c8f"></a><!-- doxytag: member="viennamath::rt_expression_interface::eval" ref="a8f5ce9c582414d43e56584c0caa42c8f" args="(NumericT val) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual NumericT eval </td>
          <td>(</td>
          <td class="paramtype">NumericT&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluates an expression taking one variable only. </p>

</div>
</div>
<a class="anchor" id="a52978a447ae55b7ab3511159ac6b224b"></a><!-- doxytag: member="viennamath::rt_expression_interface::is_constant" ref="a52978a447ae55b7ab3511159ac6b224b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool is_constant </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true, if the expression can be evaluated without providing values for variables (i.e. the expression is a constant). </p>

</div>
</div>
<a class="anchor" id="af625108815456e0f5b28b6e05f0aefee"></a><!-- doxytag: member="viennamath::rt_expression_interface::is_unary" ref="af625108815456e0f5b28b6e05f0aefee" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool is_unary </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true, if the expression is a unary expression. </p>

</div>
</div>
<a class="anchor" id="ac35f8679be9e98493b22ccbfc1419043"></a><!-- doxytag: member="viennamath::rt_expression_interface::recursive_manipulation" ref="ac35f8679be9e98493b22ccbfc1419043" args="(rt_manipulation_wrapper&lt; interface_type &gt; const &amp;fw) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a>* recursive_manipulation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1rt__manipulation__wrapper.html">rt_manipulation_wrapper</a>&lt; <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a> &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>fw</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides a common interface for top-down manipulations of the expression. </p>

</div>
</div>
<a class="anchor" id="a30d3b69da65e719adb77e9b652d6a213"></a><!-- doxytag: member="viennamath::rt_expression_interface::recursive_traversal" ref="a30d3b69da65e719adb77e9b652d6a213" args="(rt_traversal_wrapper&lt; interface_type &gt; const &amp;fw) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void recursive_traversal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classviennamath_1_1rt__traversal__wrapper.html">rt_traversal_wrapper</a>&lt; <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a> &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>fw</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides a common interface for all top-down traversals of the expression. </p>

</div>
</div>
<a class="anchor" id="a9d4f54ff84607bb3cb46b2f60790f644"></a><!-- doxytag: member="viennamath::rt_expression_interface::shallow_equal" ref="a9d4f54ff84607bb3cb46b2f60790f644" args="(const interface_type *other) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool shallow_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a> *&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks the current expression for being equal to 'other'. Checks for same type only, does not check members. </p>

</div>
</div>
<a class="anchor" id="a55058da3e0c9d61661c0943f77723d21"></a><!-- doxytag: member="viennamath::rt_expression_interface::shallow_str" ref="a55058da3e0c9d61661c0943f77723d21" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string shallow_str </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a short string identifying just the type of the expression. </p>

</div>
</div>
<a class="anchor" id="a1c1e3470e3246cf855fb3dcdbdf554ec"></a><!-- doxytag: member="viennamath::rt_expression_interface::simplify" ref="a1c1e3470e3246cf855fb3dcdbdf554ec" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a>* simplify </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an optimized expression, where trivial operations such as multiplications by unity are removed. The caller must ensure the deletion of the object the returned pointer is referring to. </p>

</div>
</div>
<a class="anchor" id="aa9ff08fde6da6835f852b22edb2b55b5"></a><!-- doxytag: member="viennamath::rt_expression_interface::substitute" ref="aa9ff08fde6da6835f852b22edb2b55b5" args="(const interface_type *e, const interface_type *repl) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a>* substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a> *&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a> *&nbsp;</td>
          <td class="paramname"> <em>repl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a new expression with all occurrences of 'e' replaced by 'repl'. The caller must ensure the deletion of the object the returned pointer is referring to. </p>

</div>
</div>
<a class="anchor" id="a6ced643d1963182684b9dcf683d761c5"></a><!-- doxytag: member="viennamath::rt_expression_interface::substitute" ref="a6ced643d1963182684b9dcf683d761c5" args="(std::vector&lt; const interface_type * &gt; const &amp;e, std::vector&lt; const interface_type * &gt; const &amp;repl) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a>* substitute </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a> * &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="classviennamath_1_1rt__expression__interface.html">interface_type</a> * &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>repl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a expression with all occurrances of 'e' in the expression substituted by the respective replacement in 'repl'. The caller must ensure the deletion of the object the returned pointer is referring to. </p>

</div>
</div>
<a class="anchor" id="a05289afe5f76f1d6612817d15a5732ce"></a><!-- doxytag: member="viennamath::rt_expression_interface::unwrap" ref="a05289afe5f76f1d6612817d15a5732ce" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual NumericT unwrap </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the numeric value of the expression. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/export/development/ViennaMath/viennamath/runtime/<a class="el" href="expression__interface_8hpp_source.html">expression_interface.hpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Feb 29 2012 21:50:44 for ViennaMath by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
