<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ViennaMath: /export/development/ViennaMath/viennamath/forwards.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>/export/development/ViennaMath/viennamath/forwards.h</h1>  </div>
</div>
<div class="contents">
<a href="forwards_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef VIENNAMATH_FORWARDS_H</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define VIENNAMATH_FORWARDS_H</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="comment">/* =======================================================================</span>
<a name="l00005"></a>00005 <span class="comment">   Copyright (c) 2012, Institute for Microelectronics,</span>
<a name="l00006"></a>00006 <span class="comment">                       Institute for Analysis and Scientific Computing,</span>
<a name="l00007"></a>00007 <span class="comment">                       TU Wien.</span>
<a name="l00008"></a>00008 <span class="comment">                             -----------------</span>
<a name="l00009"></a>00009 <span class="comment">               ViennaMath - Symbolic and Numerical Math in C++</span>
<a name="l00010"></a>00010 <span class="comment">                             -----------------</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">   Author:     Karl Rupp                          rupp@iue.tuwien.ac.at</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">   License:    MIT (X11), see file LICENSE in the ViennaMath base directory</span>
<a name="l00015"></a>00015 <span class="comment">======================================================================= */</span>
<a name="l00016"></a>00016 
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;exception&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;sstream&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;memory&gt;</span>
<a name="l00033"></a>00033 
<a name="l00039"></a>00039 <span class="keyword">namespace </span>viennamath
<a name="l00040"></a>00040 {
<a name="l00041"></a>00041   <span class="comment">//basic numeric type (customize to your needs)</span>
<a name="l00043"></a><a class="code" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">00043</a> <span class="comment"></span>  <span class="keyword">typedef</span> <span class="keywordtype">double</span>              default_numeric_type;
<a name="l00044"></a>00044   
<a name="l00046"></a><a class="code" href="namespaceviennamath.html#acff9357d27786ad0c1d9ae2e78ab83d2">00046</a>   <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>       id_type;
<a name="l00047"></a>00047   
<a name="l00049"></a>00049 
<a name="l00050"></a>00050   <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> b, <span class="keyword">class</span> T = <span class="keywordtype">void</span>&gt; 
<a name="l00051"></a><a class="code" href="structviennamath_1_1enable__if.html">00051</a>   <span class="keyword">struct </span><a class="code" href="structviennamath_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">enable_if</a>
<a name="l00052"></a>00052   {
<a name="l00053"></a><a class="code" href="structviennamath_1_1enable__if.html#a565429e62c1d4fd084335146ba778e17">00053</a>     <span class="keyword">typedef</span> T   type;
<a name="l00054"></a>00054   };
<a name="l00055"></a>00055 
<a name="l00056"></a>00056   <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; 
<a name="l00057"></a><a class="code" href="structviennamath_1_1enable__if_3_01false_00_01_t_01_4.html">00057</a>   <span class="keyword">struct </span><a class="code" href="structviennamath_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">enable_if</a>&lt;false, T&gt; {};
<a name="l00058"></a>00058 
<a name="l00063"></a>00063   <span class="keyword">template</span> &lt;<span class="keywordtype">id</span>_type dim&gt;
<a name="l00064"></a><a class="code" href="structviennamath_1_1cartesian.html">00064</a>   <span class="keyword">struct </span><a class="code" href="structviennamath_1_1cartesian.html" title="A tag representing a Cartesian coordinate system in arbitrary dimensions.">cartesian</a> {};
<a name="l00065"></a>00065   
<a name="l00066"></a>00066 
<a name="l00077"></a>00077   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT&gt;
<a name="l00078"></a><a class="code" href="classviennamath_1_1numeric__type__proxy.html">00078</a>   <span class="keyword">class </span><a class="code" href="classviennamath_1_1numeric__type__proxy.html" title="A proxy object which allows for the use of plain default_numeric_type with template operator+...">numeric_type_proxy</a>
<a name="l00079"></a>00079   {
<a name="l00080"></a>00080     <span class="keyword">public</span>:
<a name="l00081"></a><a class="code" href="classviennamath_1_1numeric__type__proxy.html#a46b0c4395df69f76c831470dce8a0fbb">00081</a>       <a class="code" href="classviennamath_1_1numeric__type__proxy.html#a46b0c4395df69f76c831470dce8a0fbb">numeric_type_proxy</a>(NumericT value) : value_(value) {}
<a name="l00082"></a>00082       
<a name="l00083"></a><a class="code" href="classviennamath_1_1numeric__type__proxy.html#a335ccef24b364f16c27156f3c621d697">00083</a>       NumericT <span class="keyword">get</span>() <span class="keyword">const</span> { <span class="keywordflow">return</span> value_; }
<a name="l00084"></a>00084     <span class="keyword">private</span>:
<a name="l00085"></a>00085       NumericT value_;
<a name="l00086"></a>00086   };
<a name="l00087"></a>00087 
<a name="l00088"></a>00088   <span class="comment">//  </span>
<a name="l00090"></a>00090 <span class="comment"></span>  <span class="comment">//</span>
<a name="l00091"></a>00091   
<a name="l00098"></a>00098   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS,
<a name="l00099"></a>00099             <span class="keyword">typename</span> OP,
<a name="l00100"></a>00100             <span class="keyword">typename</span> RHS&gt;
<a name="l00101"></a>00101   <span class="keyword">class </span>ct_binary_expr;
<a name="l00102"></a>00102 
<a name="l00108"></a>00108   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS,
<a name="l00109"></a>00109             <span class="keyword">typename</span> OP&gt;
<a name="l00110"></a>00110   <span class="keyword">class </span>ct_unary_expr;
<a name="l00111"></a>00111   
<a name="l00116"></a>00116   <span class="keyword">template</span> &lt;<span class="keywordtype">long</span> value_&gt;
<a name="l00117"></a>00117   <span class="keyword">class </span>ct_constant;
<a name="l00118"></a>00118 
<a name="l00123"></a>00123   <span class="keyword">template</span> &lt;<span class="keywordtype">id</span>_type <span class="keywordtype">id</span> = 0&gt;
<a name="l00124"></a>00124   <span class="keyword">struct </span>ct_variable;
<a name="l00125"></a>00125 
<a name="l00130"></a>00130   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tag&gt;
<a name="l00131"></a>00131   <span class="keyword">class </span>ct_function_symbol;
<a name="l00132"></a>00132 
<a name="l00138"></a>00138   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS&gt;
<a name="l00139"></a>00139   <span class="keyword">class </span>ct_equation;
<a name="l00140"></a>00140   
<a name="l00141"></a>00141 
<a name="l00142"></a>00142   
<a name="l00147"></a>00147   <span class="keyword">template</span> &lt;<span class="keywordtype">long</span> i&gt;
<a name="l00148"></a><a class="code" href="structviennamath_1_1ct__index.html">00148</a>   <span class="keyword">struct </span><a class="code" href="structviennamath_1_1ct__index.html" title="Compiletime respresentation of a vector access index.">ct_index</a> {};
<a name="l00149"></a>00149   
<a name="l00154"></a>00154   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T0&gt;
<a name="l00155"></a>00155   <span class="keyword">class </span><a class="code" href="classviennamath_1_1ct__vector__1.html" title="Compiletime vector with one element.">ct_vector_1</a>;
<a name="l00156"></a>00156   
<a name="l00162"></a>00162   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T0, <span class="keyword">typename</span> T1&gt;
<a name="l00163"></a>00163   <span class="keyword">class </span><a class="code" href="classviennamath_1_1ct__vector__2.html" title="Compiletime vector with one element.">ct_vector_2</a>;
<a name="l00164"></a>00164   
<a name="l00171"></a>00171   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T0, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;
<a name="l00172"></a>00172   <span class="keyword">class </span><a class="code" href="classviennamath_1_1ct__vector__3.html" title="Compiletime vector with one element.">ct_vector_3</a>;
<a name="l00173"></a>00173  
<a name="l00174"></a>00174   <span class="comment">//</span>
<a name="l00176"></a>00176 <span class="comment"></span>  <span class="comment">//</span>
<a name="l00177"></a>00177 
<a name="l00179"></a>00179   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT&gt;
<a name="l00180"></a><a class="code" href="namespaceviennamath.html#ac8b78c7806640b05ca58aaeba616d9c1">00180</a>   <span class="keyword">class </span><a class="code" href="classviennamath_1_1rt__expression__interface.html" title="Abstract interface for all ViennaMath runtime expressions.">rt_expression_interface</a>;
<a name="l00181"></a>00181   
<a name="l00183"></a>00183   <span class="keyword">typedef</span> <a class="code" href="classviennamath_1_1rt__expression__interface.html" title="Abstract interface for all ViennaMath runtime expressions.">rt_expression_interface&lt;default_numeric_type&gt;</a>     <a class="code" href="classviennamath_1_1rt__expression__interface.html" title="Abstract interface for all ViennaMath runtime expressions.">default_interface_type</a>;
<a name="l00184"></a>00184   
<a name="l00189"></a>00189   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType = default_<span class="keywordtype">int</span>erface_type&gt;
<a name="l00190"></a><a class="code" href="namespaceviennamath.html#aca2ca1f2df887f6733612f7bebb12550">00190</a>   <span class="keyword">class </span><a class="code" href="classviennamath_1_1rt__variable.html" title="Representation of an variable (a variable). If the supplied argument is some vector type...">rt_variable</a>;
<a name="l00191"></a>00191   <span class="keyword">typedef</span> <a class="code" href="classviennamath_1_1rt__variable.html" title="Representation of an variable (a variable). If the supplied argument is some vector type...">rt_variable&lt;&gt;</a>                <a class="code" href="classviennamath_1_1rt__variable.html" title="Representation of an variable (a variable). If the supplied argument is some vector type...">variable</a>;
<a name="l00192"></a>00192 
<a name="l00197"></a>00197   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ScalarType = default_numeric_type, <span class="keyword">typename</span> InterfaceType = default_<span class="keywordtype">int</span>erface_type&gt;
<a name="l00198"></a><a class="code" href="namespaceviennamath.html#aba5112b4db8f18758911907e380cf264">00198</a>   <span class="keyword">class </span><a class="code" href="classviennamath_1_1rt__constant.html" title="Representation of a constant within the expression setting of ViennaMath.">rt_constant</a>;
<a name="l00199"></a>00199   <span class="keyword">typedef</span> <a class="code" href="classviennamath_1_1rt__constant.html" title="Representation of a constant within the expression setting of ViennaMath.">rt_constant&lt;&gt;</a>                <a class="code" href="classviennamath_1_1rt__constant.html" title="Representation of a constant within the expression setting of ViennaMath.">constant</a>;
<a name="l00200"></a>00200 
<a name="l00205"></a>00205   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType = default_<span class="keywordtype">int</span>erface_type&gt;
<a name="l00206"></a><a class="code" href="namespaceviennamath.html#ad9a6d21e340fc856e9e2a7ebb6cf21ca">00206</a>   <span class="keyword">class </span><a class="code" href="classviennamath_1_1rt__binary__expr.html" title="Runtime representation of a binary expression F(x,y), where F is a function of two argument (e...">rt_binary_expr</a>;  
<a name="l00207"></a>00207   <span class="keyword">typedef</span> <a class="code" href="classviennamath_1_1rt__binary__expr.html" title="Runtime representation of a binary expression F(x,y), where F is a function of two argument (e...">rt_binary_expr&lt;&gt;</a>             <a class="code" href="classviennamath_1_1rt__binary__expr.html" title="Runtime representation of a binary expression F(x,y), where F is a function of two argument (e...">binary_expr</a>;
<a name="l00208"></a>00208   
<a name="l00213"></a>00213   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType = default_<span class="keywordtype">int</span>erface_type&gt;
<a name="l00214"></a><a class="code" href="namespaceviennamath.html#a28408548bab180778977b5f39a383449">00214</a>   <span class="keyword">class </span><a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr</a>;
<a name="l00215"></a>00215   <span class="keyword">typedef</span> <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr&lt;&gt;</a>              <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">unary_expr</a>;
<a name="l00216"></a>00216   
<a name="l00223"></a>00223   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType = default_<span class="keywordtype">int</span>erface_type&gt;
<a name="l00224"></a><a class="code" href="namespaceviennamath.html#a50974365c0be03981bbd761766c970b6">00224</a>   <span class="keyword">class </span><a class="code" href="classviennamath_1_1rt__expr.html" title="This class represents a smart pointer to all types expressions.">rt_expr</a>;
<a name="l00225"></a>00225   <span class="keyword">typedef</span> <a class="code" href="classviennamath_1_1rt__expr.html" title="This class represents a smart pointer to all types expressions.">rt_expr&lt;&gt;</a>                    <a class="code" href="classviennamath_1_1rt__expr.html" title="This class represents a smart pointer to all types expressions.">expr</a>;
<a name="l00226"></a>00226   
<a name="l00231"></a>00231   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType = default_<span class="keywordtype">int</span>erface_type&gt;
<a name="l00232"></a><a class="code" href="namespaceviennamath.html#a2993287894f3ac500b754b731eadc295">00232</a>   <span class="keyword">class </span><a class="code" href="classviennamath_1_1rt__vector__expr.html" title="An tweaked auto_ptr for run time rt_expr types.">rt_vector_expr</a>; 
<a name="l00233"></a>00233   <span class="keyword">typedef</span> <a class="code" href="classviennamath_1_1rt__vector__expr.html" title="An tweaked auto_ptr for run time rt_expr types.">rt_vector_expr&lt;&gt;</a>             <a class="code" href="classviennamath_1_1rt__vector__expr.html" title="An tweaked auto_ptr for run time rt_expr types.">vector_expr</a>;
<a name="l00234"></a>00234   
<a name="l00239"></a>00239   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType = default_<span class="keywordtype">int</span>erface_type&gt;
<a name="l00240"></a><a class="code" href="namespaceviennamath.html#ab6b5705970b712844d53cbe01b130eec">00240</a>   <span class="keyword">class </span><a class="code" href="classviennamath_1_1rt__function__symbol.html" title="A function symbol. Can be used for unknown functions, test functions, etc. Cannot be evaluated...">rt_function_symbol</a>;
<a name="l00241"></a>00241   <span class="keyword">typedef</span> <a class="code" href="classviennamath_1_1rt__function__symbol.html" title="A function symbol. Can be used for unknown functions, test functions, etc. Cannot be evaluated...">rt_function_symbol&lt;&gt;</a>         <a class="code" href="classviennamath_1_1rt__function__symbol.html" title="A function symbol. Can be used for unknown functions, test functions, etc. Cannot be evaluated...">function_symbol</a>;
<a name="l00242"></a>00242 
<a name="l00247"></a>00247   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType = default_<span class="keywordtype">int</span>erface_type&gt;
<a name="l00248"></a><a class="code" href="namespaceviennamath.html#a851bad3788c5dbe912da12d0c40d4d20">00248</a>   <span class="keyword">class </span><a class="code" href="classviennamath_1_1rt__equation.html" title="Runtime representation of a equation by a left hand side and a right hand side expresssion.">rt_equation</a>;
<a name="l00249"></a>00249   <span class="keyword">typedef</span> <a class="code" href="classviennamath_1_1rt__equation.html" title="Runtime representation of a equation by a left hand side and a right hand side expresssion.">rt_equation&lt;&gt;</a>                <a class="code" href="classviennamath_1_1rt__equation.html" title="Runtime representation of a equation by a left hand side and a right hand side expresssion.">equation</a>;
<a name="l00250"></a>00250 
<a name="l00255"></a>00255   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType = default_<span class="keywordtype">int</span>erface_type&gt;
<a name="l00256"></a><a class="code" href="namespaceviennamath.html#a4b0e68703e0147319ac33fb857f1cdea">00256</a>   <span class="keyword">class </span><a class="code" href="classviennamath_1_1rt__interval.html" title="Represents an interval [a,b] at runtime. Note that the interval boundaries do not need to be constant...">rt_interval</a>;
<a name="l00257"></a>00257   <span class="keyword">typedef</span> <a class="code" href="classviennamath_1_1rt__interval.html" title="Represents an interval [a,b] at runtime. Note that the interval boundaries do not need to be constant...">rt_interval&lt;&gt;</a>                <a class="code" href="classviennamath_1_1rt__interval.html" title="Represents an interval [a,b] at runtime. Note that the interval boundaries do not need to be constant...">interval</a>;
<a name="l00258"></a>00258 
<a name="l00263"></a>00263   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType = default_<span class="keywordtype">int</span>erface_type&gt;
<a name="l00264"></a><a class="code" href="namespaceviennamath.html#a2f381b80192d3734ea27b03e10d7bb21">00264</a>   <span class="keyword">class </span><a class="code" href="classviennamath_1_1rt__symbolic__interval.html" title="A symbolic runtime interval.">rt_symbolic_interval</a>;
<a name="l00265"></a>00265   <span class="keyword">typedef</span> <a class="code" href="classviennamath_1_1rt__symbolic__interval.html" title="A symbolic runtime interval.">rt_symbolic_interval&lt;&gt;</a>       <a class="code" href="classviennamath_1_1rt__symbolic__interval.html" title="A symbolic runtime interval.">symbolic_interval</a>;
<a name="l00266"></a>00266   
<a name="l00267"></a>00267   
<a name="l00272"></a>00272   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType = default_<span class="keywordtype">int</span>erface_type&gt;   <span class="comment">//Note: No convenience typedef needed here</span>
<a name="l00273"></a>00273   <span class="keyword">class </span><a class="code" href="classviennamath_1_1rt__manipulation__interface.html" title="The abstract runtime interface for all expression manipulators.">rt_manipulation_interface</a>;
<a name="l00274"></a>00274 
<a name="l00279"></a>00279   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType = default_<span class="keywordtype">int</span>erface_type&gt;   <span class="comment">//Note: No convenience typedef needed here</span>
<a name="l00280"></a>00280   <span class="keyword">class </span><a class="code" href="classviennamath_1_1rt__manipulation__wrapper.html" title="A wrapper using type erasure for manipulation functors acting on expressions.">rt_manipulation_wrapper</a>;
<a name="l00281"></a>00281   
<a name="l00282"></a>00282   
<a name="l00287"></a>00287   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType = default_<span class="keywordtype">int</span>erface_type&gt;   <span class="comment">//Note: No convenience typedef needed here</span>
<a name="l00288"></a>00288   <span class="keyword">class </span><a class="code" href="classviennamath_1_1rt__traversal__interface.html" title="The abstract runtime interface for all expression traversal routines.">rt_traversal_interface</a>;
<a name="l00289"></a>00289   
<a name="l00294"></a>00294   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType = default_<span class="keywordtype">int</span>erface_type&gt;   <span class="comment">//Note: No convenience typedef needed here</span>
<a name="l00295"></a>00295   <span class="keyword">class </span><a class="code" href="classviennamath_1_1rt__traversal__wrapper.html" title="A wrapper using type erasure for traversal functions acting on expressions.">rt_traversal_wrapper</a>;
<a name="l00296"></a>00296   
<a name="l00297"></a>00297   <span class="comment">//</span>
<a name="l00299"></a>00299 <span class="comment"></span>  <span class="comment">//</span>
<a name="l00300"></a>00300   
<a name="l00305"></a>00305   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType = default_<span class="keywordtype">int</span>erface_type&gt;
<a name="l00306"></a>00306   <span class="keyword">class </span>rt_op_interface;
<a name="l00307"></a>00307 
<a name="l00308"></a>00308   <span class="comment">//binary operator tags:  </span>
<a name="l00314"></a>00314 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> BinaryOperation, <span class="keyword">typename</span> InterfaceType = default_<span class="keywordtype">int</span>erface_type&gt;
<a name="l00315"></a>00315   <span class="keyword">class </span><a class="code" href="classviennamath_1_1op__binary.html" title="This is the common wrapper class for binary operations.">op_binary</a>;
<a name="l00316"></a>00316   
<a name="l00318"></a>00318   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT&gt;
<a name="l00319"></a>00319   <span class="keyword">struct </span><a class="code" href="structviennamath_1_1op__plus.html" title="Tag for addition.">op_plus</a>;
<a name="l00320"></a>00320   
<a name="l00322"></a>00322   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT&gt;
<a name="l00323"></a>00323   <span class="keyword">struct </span><a class="code" href="structviennamath_1_1op__minus.html" title="Tag for subtraction.">op_minus</a>;
<a name="l00324"></a>00324   
<a name="l00326"></a>00326   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT&gt;
<a name="l00327"></a>00327   <span class="keyword">struct </span><a class="code" href="structviennamath_1_1op__mult.html" title="Tag for multiplication.">op_mult</a>;
<a name="l00328"></a>00328   
<a name="l00330"></a>00330   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT&gt;
<a name="l00331"></a>00331   <span class="keyword">struct </span><a class="code" href="structviennamath_1_1op__div.html" title="Tag for division.">op_div</a>;
<a name="l00332"></a>00332   
<a name="l00334"></a>00334   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT&gt;
<a name="l00335"></a>00335   <span class="keyword">struct </span>op_pow;
<a name="l00336"></a>00336 
<a name="l00337"></a>00337   
<a name="l00338"></a>00338   
<a name="l00339"></a>00339   <span class="comment">//</span>
<a name="l00341"></a>00341 <span class="comment"></span>  <span class="comment">//</span>
<a name="l00342"></a>00342   
<a name="l00348"></a>00348   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> UnaryOperation, <span class="keyword">typename</span> InterfaceType = default_<span class="keywordtype">int</span>erface_type&gt;
<a name="l00349"></a>00349   <span class="keyword">class </span><a class="code" href="classviennamath_1_1op__unary.html" title="Main class for all unary operations.">op_unary</a>;
<a name="l00350"></a>00350   
<a name="l00351"></a>00351 
<a name="l00353"></a>00353   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT&gt;
<a name="l00354"></a>00354   <span class="keyword">struct </span><a class="code" href="structviennamath_1_1op__id.html" title="Identity mapping: x |--&amp;gt; x.">op_id</a>;
<a name="l00355"></a>00355   
<a name="l00357"></a>00357   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT&gt;
<a name="l00358"></a>00358   <span class="keyword">struct </span><a class="code" href="structviennamath_1_1op__exp.html" title="Exponential mapping: x |--&amp;gt; exp(x).">op_exp</a>;
<a name="l00359"></a>00359   
<a name="l00361"></a>00361   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT&gt;
<a name="l00362"></a>00362   <span class="keyword">struct </span><a class="code" href="structviennamath_1_1op__sin.html" title="Sine function: x |--&amp;gt; sin(x).">op_sin</a>;
<a name="l00363"></a>00363   
<a name="l00365"></a>00365   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT&gt;
<a name="l00366"></a>00366   <span class="keyword">struct </span><a class="code" href="structviennamath_1_1op__cos.html" title="Cosine function: x |--&amp;gt; cos(x).">op_cos</a>;
<a name="l00367"></a>00367   
<a name="l00369"></a>00369   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT&gt;
<a name="l00370"></a>00370   <span class="keyword">struct </span><a class="code" href="structviennamath_1_1op__tan.html" title="Tangent function: x |--&amp;gt; tan(x).">op_tan</a>;
<a name="l00371"></a>00371   
<a name="l00373"></a>00373   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT&gt;
<a name="l00374"></a>00374   <span class="keyword">struct </span><a class="code" href="structviennamath_1_1op__fabs.html" title="Modulus: x |--&amp;gt; |x|.">op_fabs</a>;
<a name="l00375"></a>00375   
<a name="l00377"></a>00377   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT&gt;
<a name="l00378"></a>00378   <span class="keyword">struct </span><a class="code" href="structviennamath_1_1op__sqrt.html" title="Square root: x |--&amp;gt; \sqrt{x}.">op_sqrt</a>;
<a name="l00379"></a>00379   
<a name="l00381"></a>00381   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT&gt;
<a name="l00382"></a>00382   <span class="keyword">struct </span><a class="code" href="structviennamath_1_1op__log.html" title="Natural logarithm function: x |--&amp;gt; ln(x).">op_log</a>; <span class="comment">//natural logarithm</span>
<a name="l00383"></a>00383   
<a name="l00385"></a>00385   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT&gt;
<a name="l00386"></a>00386   <span class="keyword">struct </span><a class="code" href="structviennamath_1_1op__log10.html" title="Logarithm with base 10: x |--&amp;gt; \log_{10}(x).">op_log10</a>;
<a name="l00387"></a>00387 
<a name="l00389"></a>00389   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericT&gt;
<a name="l00390"></a>00390   <span class="keyword">class </span><a class="code" href="classviennamath_1_1op__partial__deriv.html" title="Divergence operator: f |--&amp;gt; d f / (d x_i).">op_partial_deriv</a>;
<a name="l00391"></a>00391   
<a name="l00393"></a>00393   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00394"></a>00394   <span class="keyword">class </span><a class="code" href="classviennamath_1_1op__rt__integral.html" title="A unary operation defining an integral over an interval.">op_rt_integral</a>;
<a name="l00395"></a>00395 
<a name="l00396"></a>00396   
<a name="l00401"></a>00401   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00402"></a>00402   <span class="keyword">class </span><a class="code" href="classviennamath_1_1op__rt__symbolic__integral.html" title="A unary operation encoding a symbolic interval. Cannot be evaluated and is meant to be replaced by a ...">op_rt_symbolic_integral</a>;
<a name="l00403"></a>00403   
<a name="l00404"></a>00404 
<a name="l00405"></a>00405 
<a name="l00407"></a>00407   <span class="keyword">namespace </span>result_of
<a name="l00408"></a>00408   {
<a name="l00415"></a>00415     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00416"></a><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath.html">00416</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath.html" title="A metafunction with value &amp;#39;true&amp;#39; if the provided argument is a ViennaMath expression type...">is_viennamath</a>
<a name="l00417"></a>00417     {
<a name="l00418"></a><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath.html#a06fc87d81c62e9abb8790b6e5713c55ba97de9ab6885342a574053b8f64a563a9">00418</a>       <span class="keyword">enum</span> { <a class="code" href="structviennamath_1_1result__of_1_1is__viennamath.html#a06fc87d81c62e9abb8790b6e5713c55ba97de9ab6885342a574053b8f64a563a9">value</a> = <span class="keyword">false</span> };
<a name="l00419"></a>00419     };
<a name="l00420"></a>00420     
<a name="l00422"></a>00422     <span class="keyword">template</span> &lt;<span class="keywordtype">long</span> val&gt;
<a name="l00423"></a><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__constant_3_01val_01_4_01_4.html">00423</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath.html" title="A metafunction with value &amp;#39;true&amp;#39; if the provided argument is a ViennaMath expression type...">is_viennamath</a>&lt;<a class="code" href="classviennamath_1_1ct__constant.html" title="A compiletime constant.">ct_constant</a>&lt;val&gt; &gt;
<a name="l00424"></a>00424     {
<a name="l00425"></a><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__constant_3_01val_01_4_01_4.html#adf764cbdea00d65edcd07bb9953ad2b7a97de9ab6885342a574053b8f64a563a9">00425</a>       <span class="keyword">enum</span> { <a class="code" href="structviennamath_1_1result__of_1_1is__viennamath.html#a06fc87d81c62e9abb8790b6e5713c55ba97de9ab6885342a574053b8f64a563a9">value</a> = <span class="keyword">true</span> };
<a name="l00426"></a>00426     };
<a name="l00427"></a>00427     
<a name="l00429"></a>00429     <span class="keyword">template</span> &lt;<span class="keywordtype">id</span>_type <span class="keywordtype">id</span>&gt;
<a name="l00430"></a><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__variable_3_01id_01_4_01_4.html">00430</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath.html" title="A metafunction with value &amp;#39;true&amp;#39; if the provided argument is a ViennaMath expression type...">is_viennamath</a>&lt;<a class="code" href="structviennamath_1_1ct__variable.html" title="Representation of a mathematical variable. If the supplied argument is some vector type...">ct_variable</a>&lt;id&gt; &gt;
<a name="l00431"></a>00431     {
<a name="l00432"></a><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__variable_3_01id_01_4_01_4.html#a99fb83031ce9923c84392b4e92f956b5a97de9ab6885342a574053b8f64a563a9">00432</a>       <span class="keyword">enum</span> { <a class="code" href="structviennamath_1_1result__of_1_1is__viennamath.html#a06fc87d81c62e9abb8790b6e5713c55ba97de9ab6885342a574053b8f64a563a9">value</a> = <span class="keyword">true</span> };
<a name="l00433"></a>00433     };
<a name="l00434"></a>00434 
<a name="l00436"></a>00436     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TAG&gt;
<a name="l00437"></a><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__function__symbol_3_01_t_a_g_01_4_01_4.html">00437</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath.html" title="A metafunction with value &amp;#39;true&amp;#39; if the provided argument is a ViennaMath expression type...">is_viennamath</a>&lt;<a class="code" href="classviennamath_1_1ct__function__symbol.html" title="A function symbol. Can be used for unknown functions, test functions, etc. Cannot be evaluated...">ct_function_symbol</a>&lt;TAG&gt; &gt;
<a name="l00438"></a>00438     {
<a name="l00439"></a><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__function__symbol_3_01_t_a_g_01_4_01_4.html#abc6126af1d45847bc59afa0aa3216b04a97de9ab6885342a574053b8f64a563a9">00439</a>       <span class="keyword">enum</span> { <a class="code" href="structviennamath_1_1result__of_1_1is__viennamath.html#a06fc87d81c62e9abb8790b6e5713c55ba97de9ab6885342a574053b8f64a563a9">value</a> = <span class="keyword">true</span> };
<a name="l00440"></a>00440     };
<a name="l00441"></a>00441     
<a name="l00443"></a>00443     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> OP, <span class="keyword">typename</span> RHS&gt;
<a name="l00444"></a><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h_s_01_4_01_4.html">00444</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath.html" title="A metafunction with value &amp;#39;true&amp;#39; if the provided argument is a ViennaMath expression type...">is_viennamath</a>&lt;<a class="code" href="classviennamath_1_1ct__binary__expr.html" title="A compile time expression consisting of two operands and one operation (taking two arguments)...">ct_binary_expr</a>&lt;LHS, OP, RHS&gt; &gt;
<a name="l00445"></a>00445     {
<a name="l00446"></a><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h_s_01_4_01_4.html#adc29c2ff13d900c2f185ee95427fb06ca97de9ab6885342a574053b8f64a563a9">00446</a>       <span class="keyword">enum</span> { <a class="code" href="structviennamath_1_1result__of_1_1is__viennamath.html#a06fc87d81c62e9abb8790b6e5713c55ba97de9ab6885342a574053b8f64a563a9">value</a> = <span class="keyword">true</span> };
<a name="l00447"></a>00447     };
<a name="l00448"></a>00448 
<a name="l00450"></a>00450     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> OP&gt;
<a name="l00451"></a><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__unary__expr_3_01_l_h_s_00_01_o_p_01_4_01_4.html">00451</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath.html" title="A metafunction with value &amp;#39;true&amp;#39; if the provided argument is a ViennaMath expression type...">is_viennamath</a>&lt;<a class="code" href="classviennamath_1_1ct__unary__expr.html" title="Defines a unary expression f(e), where f is function and &amp;#39;e&amp;#39; is an expression.">ct_unary_expr</a>&lt;LHS, OP&gt; &gt;
<a name="l00452"></a>00452     {
<a name="l00453"></a><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__unary__expr_3_01_l_h_s_00_01_o_p_01_4_01_4.html#a61dadd085c1777f559549e05962b2c9ea97de9ab6885342a574053b8f64a563a9">00453</a>       <span class="keyword">enum</span> { <a class="code" href="structviennamath_1_1result__of_1_1is__viennamath.html#a06fc87d81c62e9abb8790b6e5713c55ba97de9ab6885342a574053b8f64a563a9">value</a> = <span class="keyword">true</span> };
<a name="l00454"></a>00454     };
<a name="l00455"></a>00455     
<a name="l00456"></a>00456     
<a name="l00457"></a>00457     
<a name="l00459"></a>00459     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumericType, <span class="keyword">typename</span> InterfaceType&gt;
<a name="l00460"></a><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__constant_3_01_numeric_type_00_01_interface_type_01_4_01_4.html">00460</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath.html" title="A metafunction with value &amp;#39;true&amp;#39; if the provided argument is a ViennaMath expression type...">is_viennamath</a>&lt;<a class="code" href="classviennamath_1_1rt__constant.html" title="Representation of a constant within the expression setting of ViennaMath.">rt_constant</a>&lt;NumericType, InterfaceType&gt; &gt;
<a name="l00461"></a>00461     {
<a name="l00462"></a><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__constant_3_01_numeric_type_00_01_interface_type_01_4_01_4.html#a726ca809ffd3d67ab4b8476646f26635a97de9ab6885342a574053b8f64a563a9">00462</a>       <span class="keyword">enum</span> { <a class="code" href="structviennamath_1_1result__of_1_1is__viennamath.html#a06fc87d81c62e9abb8790b6e5713c55ba97de9ab6885342a574053b8f64a563a9">value</a> = <span class="keyword">true</span> };
<a name="l00463"></a>00463     };
<a name="l00464"></a>00464     
<a name="l00466"></a>00466     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00467"></a><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__variable_3_01_interface_type_01_4_01_4.html">00467</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath.html" title="A metafunction with value &amp;#39;true&amp;#39; if the provided argument is a ViennaMath expression type...">is_viennamath</a>&lt;<a class="code" href="classviennamath_1_1rt__variable.html" title="Representation of an variable (a variable). If the supplied argument is some vector type...">rt_variable</a>&lt;InterfaceType&gt; &gt;
<a name="l00468"></a>00468     {
<a name="l00469"></a><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__variable_3_01_interface_type_01_4_01_4.html#a0411cd49bb5b71852cecd93bcbf0ca2da97de9ab6885342a574053b8f64a563a9">00469</a>       <span class="keyword">enum</span> { <a class="code" href="structviennamath_1_1result__of_1_1is__viennamath.html#a06fc87d81c62e9abb8790b6e5713c55ba97de9ab6885342a574053b8f64a563a9">value</a> = <span class="keyword">true</span> };
<a name="l00470"></a>00470     };
<a name="l00471"></a>00471 
<a name="l00473"></a>00473     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00474"></a><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__function__symbol_3_01_interface_type_01_4_01_4.html">00474</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath.html" title="A metafunction with value &amp;#39;true&amp;#39; if the provided argument is a ViennaMath expression type...">is_viennamath</a>&lt;<a class="code" href="classviennamath_1_1rt__function__symbol.html" title="A function symbol. Can be used for unknown functions, test functions, etc. Cannot be evaluated...">rt_function_symbol</a>&lt;InterfaceType&gt; &gt;
<a name="l00475"></a>00475     {
<a name="l00476"></a><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__function__symbol_3_01_interface_type_01_4_01_4.html#abed82baf7f470b522273a3e37c24c600a97de9ab6885342a574053b8f64a563a9">00476</a>       <span class="keyword">enum</span> { <a class="code" href="structviennamath_1_1result__of_1_1is__viennamath.html#a06fc87d81c62e9abb8790b6e5713c55ba97de9ab6885342a574053b8f64a563a9">value</a> = <span class="keyword">true</span> };
<a name="l00477"></a>00477     };
<a name="l00478"></a>00478     
<a name="l00480"></a>00480     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00481"></a><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__unary__expr_3_01_interface_type_01_4_01_4.html">00481</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath.html" title="A metafunction with value &amp;#39;true&amp;#39; if the provided argument is a ViennaMath expression type...">is_viennamath</a>&lt;<a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr</a>&lt;InterfaceType&gt; &gt;
<a name="l00482"></a>00482     {
<a name="l00483"></a><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__unary__expr_3_01_interface_type_01_4_01_4.html#ab04a0655cd1e3bcac5e8f48c18df1a57a97de9ab6885342a574053b8f64a563a9">00483</a>       <span class="keyword">enum</span> { <a class="code" href="structviennamath_1_1result__of_1_1is__viennamath.html#a06fc87d81c62e9abb8790b6e5713c55ba97de9ab6885342a574053b8f64a563a9">value</a> = <span class="keyword">true</span> };
<a name="l00484"></a>00484     };
<a name="l00485"></a>00485     
<a name="l00487"></a>00487     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00488"></a><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__binary__expr_3_01_interface_type_01_4_01_4.html">00488</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath.html" title="A metafunction with value &amp;#39;true&amp;#39; if the provided argument is a ViennaMath expression type...">is_viennamath</a>&lt;<a class="code" href="classviennamath_1_1rt__binary__expr.html" title="Runtime representation of a binary expression F(x,y), where F is a function of two argument (e...">rt_binary_expr</a>&lt;InterfaceType&gt; &gt;
<a name="l00489"></a>00489     {
<a name="l00490"></a><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__binary__expr_3_01_interface_type_01_4_01_4.html#a385c44f6fb256e5716a2302a5b940388a97de9ab6885342a574053b8f64a563a9">00490</a>       <span class="keyword">enum</span> { <a class="code" href="structviennamath_1_1result__of_1_1is__viennamath.html#a06fc87d81c62e9abb8790b6e5713c55ba97de9ab6885342a574053b8f64a563a9">value</a> = <span class="keyword">true</span> };
<a name="l00491"></a>00491     };
<a name="l00492"></a>00492     
<a name="l00494"></a>00494     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InterfaceType&gt;
<a name="l00495"></a><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__expr_3_01_interface_type_01_4_01_4.html">00495</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath.html" title="A metafunction with value &amp;#39;true&amp;#39; if the provided argument is a ViennaMath expression type...">is_viennamath</a>&lt;<a class="code" href="classviennamath_1_1rt__expr.html" title="This class represents a smart pointer to all types expressions.">rt_expr</a>&lt;InterfaceType&gt; &gt;
<a name="l00496"></a>00496     {
<a name="l00497"></a><a class="code" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__expr_3_01_interface_type_01_4_01_4.html#abc5c98fcc1211af2b80116dd6e0a035da97de9ab6885342a574053b8f64a563a9">00497</a>       <span class="keyword">enum</span> { <a class="code" href="structviennamath_1_1result__of_1_1is__viennamath.html#a06fc87d81c62e9abb8790b6e5713c55ba97de9ab6885342a574053b8f64a563a9">value</a> = <span class="keyword">true</span> };
<a name="l00498"></a>00498     };
<a name="l00499"></a>00499     
<a name="l00501"></a>00501     
<a name="l00508"></a>00508     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00509"></a><a class="code" href="structviennamath_1_1result__of_1_1is__compiletime.html">00509</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1is__compiletime.html" title="A metafunction returning a value &amp;#39;true&amp;#39; if the provided argument is a ViennaMath compiletime ...">is_compiletime</a>
<a name="l00510"></a>00510     {
<a name="l00511"></a><a class="code" href="structviennamath_1_1result__of_1_1is__compiletime.html#ac36f475ca5b446f4fde4c9b90bec77c8a97de9ab6885342a574053b8f64a563a9">00511</a>       <span class="keyword">enum</span> { <a class="code" href="structviennamath_1_1result__of_1_1is__compiletime.html#ac36f475ca5b446f4fde4c9b90bec77c8a97de9ab6885342a574053b8f64a563a9">value</a> = <span class="keyword">false</span> };
<a name="l00512"></a>00512     };
<a name="l00513"></a>00513     
<a name="l00515"></a>00515     <span class="keyword">template</span> &lt;<span class="keywordtype">long</span> val&gt;
<a name="l00516"></a><a class="code" href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__constant_3_01val_01_4_01_4.html">00516</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1is__compiletime.html" title="A metafunction returning a value &amp;#39;true&amp;#39; if the provided argument is a ViennaMath compiletime ...">is_compiletime</a>&lt;<a class="code" href="classviennamath_1_1ct__constant.html" title="A compiletime constant.">ct_constant</a>&lt;val&gt; &gt;
<a name="l00517"></a>00517     {
<a name="l00518"></a><a class="code" href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__constant_3_01val_01_4_01_4.html#a05589fbab0657f08285ebdfe93f5ec9ea97de9ab6885342a574053b8f64a563a9">00518</a>       <span class="keyword">enum</span> { <a class="code" href="structviennamath_1_1result__of_1_1is__compiletime.html#ac36f475ca5b446f4fde4c9b90bec77c8a97de9ab6885342a574053b8f64a563a9">value</a> = <span class="keyword">true</span> };
<a name="l00519"></a>00519     };
<a name="l00520"></a>00520     
<a name="l00522"></a>00522     <span class="keyword">template</span> &lt;<span class="keywordtype">id</span>_type <span class="keywordtype">id</span>&gt;
<a name="l00523"></a><a class="code" href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__variable_3_01id_01_4_01_4.html">00523</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1is__compiletime.html" title="A metafunction returning a value &amp;#39;true&amp;#39; if the provided argument is a ViennaMath compiletime ...">is_compiletime</a>&lt;<a class="code" href="structviennamath_1_1ct__variable.html" title="Representation of a mathematical variable. If the supplied argument is some vector type...">ct_variable</a>&lt;id&gt; &gt;
<a name="l00524"></a>00524     {
<a name="l00525"></a><a class="code" href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__variable_3_01id_01_4_01_4.html#a16af7b253440dadd46a80a4b9fddba4da97de9ab6885342a574053b8f64a563a9">00525</a>       <span class="keyword">enum</span> { <a class="code" href="structviennamath_1_1result__of_1_1is__compiletime.html#ac36f475ca5b446f4fde4c9b90bec77c8a97de9ab6885342a574053b8f64a563a9">value</a> = <span class="keyword">true</span> };
<a name="l00526"></a>00526     };
<a name="l00527"></a>00527 
<a name="l00529"></a>00529     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TAG&gt;
<a name="l00530"></a><a class="code" href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__function__symbol_3_01_t_a_g_01_4_01_4.html">00530</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1is__compiletime.html" title="A metafunction returning a value &amp;#39;true&amp;#39; if the provided argument is a ViennaMath compiletime ...">is_compiletime</a>&lt;<a class="code" href="classviennamath_1_1ct__function__symbol.html" title="A function symbol. Can be used for unknown functions, test functions, etc. Cannot be evaluated...">ct_function_symbol</a>&lt;TAG&gt; &gt;
<a name="l00531"></a>00531     {
<a name="l00532"></a><a class="code" href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__function__symbol_3_01_t_a_g_01_4_01_4.html#aba01db17f4a2bfbc3db60dc172972a25a97de9ab6885342a574053b8f64a563a9">00532</a>       <span class="keyword">enum</span> { <a class="code" href="structviennamath_1_1result__of_1_1is__compiletime.html#ac36f475ca5b446f4fde4c9b90bec77c8a97de9ab6885342a574053b8f64a563a9">value</a> = <span class="keyword">true</span> };
<a name="l00533"></a>00533     };
<a name="l00534"></a>00534     
<a name="l00536"></a>00536     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> OP, <span class="keyword">typename</span> RHS&gt;
<a name="l00537"></a><a class="code" href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h_s_01_4_01_4.html">00537</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1is__compiletime.html" title="A metafunction returning a value &amp;#39;true&amp;#39; if the provided argument is a ViennaMath compiletime ...">is_compiletime</a>&lt;<a class="code" href="classviennamath_1_1ct__binary__expr.html" title="A compile time expression consisting of two operands and one operation (taking two arguments)...">ct_binary_expr</a>&lt;LHS, OP, RHS&gt; &gt;
<a name="l00538"></a>00538     {
<a name="l00539"></a><a class="code" href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h_s_01_4_01_4.html#aaf105ae5beaca1dee30ae54530691fcea97de9ab6885342a574053b8f64a563a9">00539</a>       <span class="keyword">enum</span> { <a class="code" href="structviennamath_1_1result__of_1_1is__compiletime.html#ac36f475ca5b446f4fde4c9b90bec77c8a97de9ab6885342a574053b8f64a563a9">value</a> = <span class="keyword">true</span> };
<a name="l00540"></a>00540     };
<a name="l00541"></a>00541 
<a name="l00543"></a>00543     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> OP&gt;
<a name="l00544"></a><a class="code" href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__unary__expr_3_01_l_h_s_00_01_o_p_01_4_01_4.html">00544</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1is__compiletime.html" title="A metafunction returning a value &amp;#39;true&amp;#39; if the provided argument is a ViennaMath compiletime ...">is_compiletime</a>&lt;<a class="code" href="classviennamath_1_1ct__unary__expr.html" title="Defines a unary expression f(e), where f is function and &amp;#39;e&amp;#39; is an expression.">ct_unary_expr</a>&lt;LHS, OP&gt; &gt;
<a name="l00545"></a>00545     {
<a name="l00546"></a><a class="code" href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__unary__expr_3_01_l_h_s_00_01_o_p_01_4_01_4.html#a80155586fa275b28773c9b203f52cabaa97de9ab6885342a574053b8f64a563a9">00546</a>       <span class="keyword">enum</span> { <a class="code" href="structviennamath_1_1result__of_1_1is__compiletime.html#ac36f475ca5b446f4fde4c9b90bec77c8a97de9ab6885342a574053b8f64a563a9">value</a> = <span class="keyword">true</span> };
<a name="l00547"></a>00547     };
<a name="l00548"></a>00548 
<a name="l00550"></a>00550     
<a name="l00555"></a>00555     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS&gt;
<a name="l00556"></a><a class="code" href="structviennamath_1_1result__of_1_1interface.html">00556</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1interface.html" title="A metafunction deducing the ViennaMath runtime expression interface (base class) from two types...">interface</a>
<a name="l00557"></a>00557     {
<a name="l00558"></a><a class="code" href="structviennamath_1_1result__of_1_1interface.html#a4621a607ed9d4da2f4dd35aa156a44dd">00558</a>       <span class="keyword">typedef</span> <a class="code" href="classviennamath_1_1rt__expression__interface.html" title="Abstract interface for all ViennaMath runtime expressions.">default_interface_type</a>  <a class="code" href="classviennamath_1_1rt__expression__interface.html" title="Abstract interface for all ViennaMath runtime expressions.">type</a>; <span class="comment">//for compatibility with enable_if</span>
<a name="l00559"></a>00559     };
<a name="l00560"></a>00560 
<a name="l00562"></a>00562     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keyword">typename</span> RHS&gt;
<a name="l00563"></a><a class="code" href="structviennamath_1_1result__of_1_1interface_3_01rt__constant_3_01_t_00_01_u_01_4_00_01_r_h_s_01_4.html">00563</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1interface.html" title="A metafunction deducing the ViennaMath runtime expression interface (base class) from two types...">interface</a>&lt; <a class="code" href="classviennamath_1_1rt__constant.html" title="Representation of a constant within the expression setting of ViennaMath.">rt_constant</a>&lt;T, U&gt;, RHS &gt;
<a name="l00564"></a>00564     {
<a name="l00565"></a><a class="code" href="structviennamath_1_1result__of_1_1interface_3_01rt__constant_3_01_t_00_01_u_01_4_00_01_r_h_s_01_4.html#a65e93f3a7496682b2143e31ab5620929">00565</a>       <span class="keyword">typedef</span> U    type;
<a name="l00566"></a>00566     };
<a name="l00567"></a>00567 
<a name="l00569"></a>00569     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> RHS&gt;
<a name="l00570"></a><a class="code" href="structviennamath_1_1result__of_1_1interface_3_01rt__variable_3_01_t_01_4_00_01_r_h_s_01_4.html">00570</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1interface.html" title="A metafunction deducing the ViennaMath runtime expression interface (base class) from two types...">interface</a>&lt; <a class="code" href="classviennamath_1_1rt__variable.html" title="Representation of an variable (a variable). If the supplied argument is some vector type...">rt_variable</a>&lt;T&gt;, RHS &gt;
<a name="l00571"></a>00571     {
<a name="l00572"></a><a class="code" href="structviennamath_1_1result__of_1_1interface_3_01rt__variable_3_01_t_01_4_00_01_r_h_s_01_4.html#a565429e62c1d4fd084335146ba778e17">00572</a>       <span class="keyword">typedef</span> T    type;
<a name="l00573"></a>00573     };
<a name="l00574"></a>00574 
<a name="l00576"></a>00576     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00577"></a><a class="code" href="structviennamath_1_1result__of_1_1interface_3_01default__numeric__type_00_01rt__variable_3_01_t_01_4_01_4.html">00577</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1interface.html" title="A metafunction deducing the ViennaMath runtime expression interface (base class) from two types...">interface</a>&lt; <a class="code" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286" title="The underlying floating point type to be used in case of doubt (e.g. when new constants are created d...">default_numeric_type</a>, <a class="code" href="classviennamath_1_1rt__variable.html" title="Representation of an variable (a variable). If the supplied argument is some vector type...">rt_variable</a>&lt;T&gt; &gt;
<a name="l00578"></a>00578     {
<a name="l00579"></a><a class="code" href="structviennamath_1_1result__of_1_1interface_3_01default__numeric__type_00_01rt__variable_3_01_t_01_4_01_4.html#a565429e62c1d4fd084335146ba778e17">00579</a>       <span class="keyword">typedef</span> T    type;
<a name="l00580"></a>00580     };
<a name="l00581"></a>00581 
<a name="l00583"></a>00583     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> RHS&gt;
<a name="l00584"></a><a class="code" href="structviennamath_1_1result__of_1_1interface_3_01rt__binary__expr_3_01_t_01_4_00_01_r_h_s_01_4.html">00584</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1interface.html" title="A metafunction deducing the ViennaMath runtime expression interface (base class) from two types...">interface</a>&lt; <a class="code" href="classviennamath_1_1rt__binary__expr.html" title="Runtime representation of a binary expression F(x,y), where F is a function of two argument (e...">rt_binary_expr</a>&lt;T&gt;, RHS &gt;
<a name="l00585"></a>00585     {
<a name="l00586"></a><a class="code" href="structviennamath_1_1result__of_1_1interface_3_01rt__binary__expr_3_01_t_01_4_00_01_r_h_s_01_4.html#a565429e62c1d4fd084335146ba778e17">00586</a>       <span class="keyword">typedef</span> T    type;
<a name="l00587"></a>00587     };
<a name="l00588"></a>00588 
<a name="l00590"></a>00590     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00591"></a><a class="code" href="structviennamath_1_1result__of_1_1interface_3_01default__numeric__type_00_01rt__binary__expr_3_01_t_01_4_01_4.html">00591</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1interface.html" title="A metafunction deducing the ViennaMath runtime expression interface (base class) from two types...">interface</a>&lt; <a class="code" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286" title="The underlying floating point type to be used in case of doubt (e.g. when new constants are created d...">default_numeric_type</a>, <a class="code" href="classviennamath_1_1rt__binary__expr.html" title="Runtime representation of a binary expression F(x,y), where F is a function of two argument (e...">rt_binary_expr</a>&lt;T&gt; &gt;
<a name="l00592"></a>00592     {
<a name="l00593"></a><a class="code" href="structviennamath_1_1result__of_1_1interface_3_01default__numeric__type_00_01rt__binary__expr_3_01_t_01_4_01_4.html#a565429e62c1d4fd084335146ba778e17">00593</a>       <span class="keyword">typedef</span> T    type;
<a name="l00594"></a>00594     };
<a name="l00595"></a>00595 
<a name="l00597"></a>00597     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> RHS&gt;
<a name="l00598"></a><a class="code" href="structviennamath_1_1result__of_1_1interface_3_01rt__unary__expr_3_01_t_01_4_00_01_r_h_s_01_4.html">00598</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1interface.html" title="A metafunction deducing the ViennaMath runtime expression interface (base class) from two types...">interface</a>&lt; <a class="code" href="classviennamath_1_1rt__unary__expr.html" title="Runtime representation of a unary expression F(e), where F is a function of one argument (e...">rt_unary_expr</a>&lt;T&gt;, RHS &gt;
<a name="l00599"></a>00599     {
<a name="l00600"></a><a class="code" href="structviennamath_1_1result__of_1_1interface_3_01rt__unary__expr_3_01_t_01_4_00_01_r_h_s_01_4.html#a565429e62c1d4fd084335146ba778e17">00600</a>       <span class="keyword">typedef</span> T    type;
<a name="l00601"></a>00601     };
<a name="l00602"></a>00602     
<a name="l00604"></a>00604     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> RHS&gt;
<a name="l00605"></a><a class="code" href="structviennamath_1_1result__of_1_1interface_3_01rt__expr_3_01_t_01_4_00_01_r_h_s_01_4.html">00605</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1interface.html" title="A metafunction deducing the ViennaMath runtime expression interface (base class) from two types...">interface</a>&lt; <a class="code" href="classviennamath_1_1rt__expr.html" title="This class represents a smart pointer to all types expressions.">rt_expr</a>&lt;T&gt;, RHS &gt;
<a name="l00606"></a>00606     {
<a name="l00607"></a><a class="code" href="structviennamath_1_1result__of_1_1interface_3_01rt__expr_3_01_t_01_4_00_01_r_h_s_01_4.html#a565429e62c1d4fd084335146ba778e17">00607</a>       <span class="keyword">typedef</span> T    type;
<a name="l00608"></a>00608     };
<a name="l00609"></a>00609 
<a name="l00611"></a>00611     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00612"></a><a class="code" href="structviennamath_1_1result__of_1_1interface_3_01double_00_01rt__expr_3_01_t_01_4_01_4.html">00612</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1interface.html" title="A metafunction deducing the ViennaMath runtime expression interface (base class) from two types...">interface</a>&lt; double,  <a class="code" href="classviennamath_1_1rt__expr.html" title="This class represents a smart pointer to all types expressions.">rt_expr</a>&lt;T&gt; &gt;
<a name="l00613"></a>00613     {
<a name="l00614"></a><a class="code" href="structviennamath_1_1result__of_1_1interface_3_01double_00_01rt__expr_3_01_t_01_4_01_4.html#a565429e62c1d4fd084335146ba778e17">00614</a>       <span class="keyword">typedef</span> T    type;
<a name="l00615"></a>00615     };
<a name="l00616"></a>00616     
<a name="l00620"></a>00620     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS,
<a name="l00621"></a>00621               <span class="keyword">typename</span> RHS,
<a name="l00622"></a>00622               <span class="keywordtype">bool</span> lhs_is_ct = <a class="code" href="structviennamath_1_1result__of_1_1is__compiletime.html" title="A metafunction returning a value &amp;#39;true&amp;#39; if the provided argument is a ViennaMath compiletime ...">is_compiletime&lt;LHS&gt;::value</a>,
<a name="l00623"></a>00623               <span class="keywordtype">bool</span> rhs_is_ct = <a class="code" href="structviennamath_1_1result__of_1_1is__compiletime.html" title="A metafunction returning a value &amp;#39;true&amp;#39; if the provided argument is a ViennaMath compiletime ...">is_compiletime&lt;RHS&gt;::value</a>&gt;
<a name="l00624"></a>00624     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1add.html" title="Returns the type of adding two expressions together. Default case: both types are runtime expressions...">add</a>;
<a name="l00625"></a>00625     
<a name="l00629"></a>00629     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS,
<a name="l00630"></a>00630               <span class="keyword">typename</span> RHS,
<a name="l00631"></a>00631               <span class="keywordtype">bool</span> lhs_is_ct = <a class="code" href="structviennamath_1_1result__of_1_1is__compiletime.html" title="A metafunction returning a value &amp;#39;true&amp;#39; if the provided argument is a ViennaMath compiletime ...">is_compiletime&lt;LHS&gt;::value</a>,
<a name="l00632"></a>00632               <span class="keywordtype">bool</span> rhs_is_ct = <a class="code" href="structviennamath_1_1result__of_1_1is__compiletime.html" title="A metafunction returning a value &amp;#39;true&amp;#39; if the provided argument is a ViennaMath compiletime ...">is_compiletime&lt;RHS&gt;::value</a>&gt;
<a name="l00633"></a>00633     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1subtract.html" title="Returns the type when subtracting two expressions. Default case: both types are runtime expressions...">subtract</a>;
<a name="l00634"></a>00634     
<a name="l00638"></a>00638     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS,
<a name="l00639"></a>00639               <span class="keyword">typename</span> RHS,
<a name="l00640"></a>00640               <span class="keywordtype">bool</span> lhs_is_ct = <a class="code" href="structviennamath_1_1result__of_1_1is__compiletime.html" title="A metafunction returning a value &amp;#39;true&amp;#39; if the provided argument is a ViennaMath compiletime ...">is_compiletime&lt;LHS&gt;::value</a>,
<a name="l00641"></a>00641               <span class="keywordtype">bool</span> rhs_is_ct = <a class="code" href="structviennamath_1_1result__of_1_1is__compiletime.html" title="A metafunction returning a value &amp;#39;true&amp;#39; if the provided argument is a ViennaMath compiletime ...">is_compiletime&lt;RHS&gt;::value</a>&gt;
<a name="l00642"></a>00642     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1mult.html" title="Returns the type when multiplying two expressions. Default case: both types are runtime expressions...">mult</a>;
<a name="l00643"></a>00643 
<a name="l00647"></a>00647     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS,
<a name="l00648"></a>00648               <span class="keyword">typename</span> RHS,
<a name="l00649"></a>00649               <span class="keywordtype">bool</span> lhs_is_ct = <a class="code" href="structviennamath_1_1result__of_1_1is__compiletime.html" title="A metafunction returning a value &amp;#39;true&amp;#39; if the provided argument is a ViennaMath compiletime ...">is_compiletime&lt;LHS&gt;::value</a>,
<a name="l00650"></a>00650               <span class="keywordtype">bool</span> rhs_is_ct = <a class="code" href="structviennamath_1_1result__of_1_1is__compiletime.html" title="A metafunction returning a value &amp;#39;true&amp;#39; if the provided argument is a ViennaMath compiletime ...">is_compiletime&lt;RHS&gt;::value</a>&gt;
<a name="l00651"></a>00651     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1div.html" title="Returns the type when dividing two expressions. Default case: both types are runtime expressions...">div</a>;
<a name="l00652"></a>00652     
<a name="l00653"></a>00653     
<a name="l00655"></a>00655     
<a name="l00657"></a>00657     <span class="keyword">template</span> &lt;<span class="keywordtype">long</span> a, <span class="keywordtype">long</span> b&gt;
<a name="l00658"></a><a class="code" href="structviennamath_1_1result__of_1_1gcd.html">00658</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1gcd.html" title="Helper metafunction for computing the greatest common divisor of two numbers.">gcd</a>
<a name="l00659"></a>00659     {
<a name="l00660"></a><a class="code" href="structviennamath_1_1result__of_1_1gcd.html#a6b7b47dd702d9e331586d485013fd1eaafcc7a4b78ecd8fa7e713f8cfa0f51017">00660</a>       <span class="keyword">enum</span> { <a class="code" href="structviennamath_1_1result__of_1_1gcd.html#a6b7b47dd702d9e331586d485013fd1eaafcc7a4b78ecd8fa7e713f8cfa0f51017">value</a> = <a class="code" href="structviennamath_1_1result__of_1_1gcd.html" title="Helper metafunction for computing the greatest common divisor of two numbers.">gcd&lt;b, a % b&gt;::value</a> };
<a name="l00661"></a>00661     };
<a name="l00662"></a>00662     
<a name="l00664"></a>00664     <span class="keyword">template</span> &lt;<span class="keywordtype">long</span> a&gt;
<a name="l00665"></a><a class="code" href="structviennamath_1_1result__of_1_1gcd_3_01a_00_010_01_4.html">00665</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1gcd.html" title="Helper metafunction for computing the greatest common divisor of two numbers.">gcd</a> &lt;a, 0&gt;
<a name="l00666"></a>00666     {
<a name="l00667"></a><a class="code" href="structviennamath_1_1result__of_1_1gcd_3_01a_00_010_01_4.html#af9bdc3014f3d54c426b6d2df10de4960a97de9ab6885342a574053b8f64a563a9">00667</a>       <span class="keyword">enum</span> { <a class="code" href="structviennamath_1_1result__of_1_1gcd.html#a6b7b47dd702d9e331586d485013fd1eaafcc7a4b78ecd8fa7e713f8cfa0f51017">value</a> = a};
<a name="l00668"></a>00668     };
<a name="l00669"></a>00669 
<a name="l00671"></a>00671     <span class="keyword">template</span> &lt;&gt;
<a name="l00672"></a><a class="code" href="structviennamath_1_1result__of_1_1gcd_3_010_00_010_01_4.html">00672</a>     <span class="keyword">struct </span><a class="code" href="structviennamath_1_1result__of_1_1gcd.html" title="Helper metafunction for computing the greatest common divisor of two numbers.">gcd</a> &lt;0, 0&gt;
<a name="l00673"></a>00673     {
<a name="l00674"></a><a class="code" href="structviennamath_1_1result__of_1_1gcd_3_010_00_010_01_4.html#adb49720dc49f7d4e4cf9adbf2948e409ad606e435413ea0944dd00d49e901e4ed">00674</a>       <span class="keyword">enum</span> { error = 1};
<a name="l00675"></a>00675     };
<a name="l00676"></a>00676     
<a name="l00677"></a>00677     
<a name="l00678"></a>00678   } <span class="comment">//namespace result_of</span>
<a name="l00679"></a>00679   
<a name="l00680"></a>00680   
<a name="l00681"></a>00681     
<a name="l00683"></a>00683   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00684"></a><a class="code" href="structviennamath_1_1expression__traits.html">00684</a>   <span class="keyword">struct </span><a class="code" href="structviennamath_1_1expression__traits.html" title="A traits system for expressions. For now provides a deduction of the const reference type only...">expression_traits</a>
<a name="l00685"></a>00685   {
<a name="l00686"></a><a class="code" href="structviennamath_1_1expression__traits.html#a032c08496942bb61dc08ec7e620d6d0d">00686</a>     <span class="keyword">typedef</span> T   const_reference_type; 
<a name="l00687"></a>00687   };
<a name="l00688"></a>00688   
<a name="l00689"></a>00689   <span class="comment">//for compile time constants, we have to copy in order to circumvent problems with temporaries</span>
<a name="l00696"></a>00696 <span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keywordtype">long</span> value&gt;
<a name="l00697"></a><a class="code" href="structviennamath_1_1expression__traits_3_01ct__constant_3_01value_01_4_01_4.html">00697</a>   <span class="keyword">struct </span><a class="code" href="structviennamath_1_1expression__traits.html" title="A traits system for expressions. For now provides a deduction of the const reference type only...">expression_traits</a> &lt; <a class="code" href="classviennamath_1_1ct__constant.html" title="A compiletime constant.">ct_constant</a>&lt;value&gt; &gt;
<a name="l00698"></a>00698   {
<a name="l00699"></a><a class="code" href="structviennamath_1_1expression__traits_3_01ct__constant_3_01value_01_4_01_4.html#a43c87ad732a045046e94b02faca6ad87">00699</a>      <span class="keyword">typedef</span> <a class="code" href="classviennamath_1_1ct__constant.html" title="A compiletime constant.">ct_constant&lt;value&gt;</a>    <a class="code" href="classviennamath_1_1ct__constant.html" title="A compiletime constant.">const_reference_type</a>;
<a name="l00700"></a>00700   };
<a name="l00701"></a>00701 
<a name="l00708"></a>00708   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> InterfaceType&gt;
<a name="l00709"></a><a class="code" href="structviennamath_1_1expression__traits_3_01rt__constant_3_01_t_00_01_interface_type_01_4_01_4.html">00709</a>   <span class="keyword">struct </span><a class="code" href="structviennamath_1_1expression__traits.html" title="A traits system for expressions. For now provides a deduction of the const reference type only...">expression_traits</a> &lt; <a class="code" href="classviennamath_1_1rt__constant.html" title="Representation of a constant within the expression setting of ViennaMath.">rt_constant</a>&lt;T, InterfaceType&gt; &gt;
<a name="l00710"></a>00710   {
<a name="l00711"></a><a class="code" href="structviennamath_1_1expression__traits_3_01rt__constant_3_01_t_00_01_interface_type_01_4_01_4.html#af64aa096af8855ab3500ca87e9249401">00711</a>      <span class="keyword">typedef</span> <a class="code" href="classviennamath_1_1rt__constant.html" title="Representation of a constant within the expression setting of ViennaMath.">rt_constant&lt;T, InterfaceType&gt;</a>    <a class="code" href="classviennamath_1_1rt__constant.html" title="Representation of a constant within the expression setting of ViennaMath.">const_reference_type</a>;
<a name="l00712"></a>00712   };
<a name="l00713"></a>00713   
<a name="l00714"></a>00714 
<a name="l00715"></a>00715   
<a name="l00716"></a>00716   
<a name="l00720"></a>00720   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS&gt;
<a name="l00721"></a>00721   <span class="keyword">typename</span> <a class="code" href="structviennamath_1_1enable__if.html" title="Simple enable-if variant that uses the SFINAE pattern.">enable_if&lt; result_of::is_viennamath&lt;LHS&gt;::value</a> || <a class="code" href="structviennamath_1_1result__of_1_1is__viennamath.html" title="A metafunction with value &amp;#39;true&amp;#39; if the provided argument is a ViennaMath expression type...">result_of::is_viennamath&lt;RHS&gt;::value</a>,
<a name="l00722"></a>00722                       <span class="keyword">typename</span> <a class="code" href="classviennamath_1_1rt__binary__expr.html" title="Runtime representation of a binary expression F(x,y), where F is a function of two argument (e...">result_of::add&lt;LHS, RHS&gt;::type</a> &gt;::type
<a name="l00723"></a><a class="code" href="namespaceviennamath.html#aaf03494c176b69f6988225edfc9e74be">00723</a>   <a class="code" href="namespaceviennamath.html#aa1a9be719914d3c45c4ad75494fccbdb" title="Special overload: ct_c1 + (c2 + X) -&amp;gt; [ct_c1 + c2] + X, where ct_c1 is a compiletime constant...">operator+</a>(LHS <span class="keyword">const</span> &amp; lhs, RHS <span class="keyword">const</span> &amp; rhs)
<a name="l00724"></a>00724   {
<a name="l00725"></a>00725     <span class="keywordflow">return</span> <a class="code" href="structviennamath_1_1result__of_1_1add.html#af23b0d10c0e8f3cd21ae5e60215bf533">result_of::add&lt;LHS, RHS&gt;::instance</a>(lhs, rhs); 
<a name="l00726"></a>00726   }
<a name="l00727"></a>00727   
<a name="l00731"></a>00731   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS&gt;
<a name="l00732"></a>00732   <span class="keyword">typename</span> enable_if&lt; result_of::is_viennamath&lt;LHS&gt;::value || result_of::is_viennamath&lt;RHS&gt;::value,
<a name="l00733"></a>00733                       <span class="keyword">typename</span> result_of::subtract&lt;LHS, RHS&gt;::type &gt;::type
<a name="l00734"></a><a class="code" href="namespaceviennamath.html#abc5bac5399fd74594c55f8a65d89b8c4">00734</a>   <a class="code" href="namespaceviennamath.html#aee490081c338660d19d0262a234a433d" title="Special overload: ct_c1 - (c2 + X) -&amp;gt; [ct_c1 - c2] - X, where ct_c1 is a compiletime constant...">operator-</a>(LHS <span class="keyword">const</span> &amp; lhs, RHS <span class="keyword">const</span> &amp; rhs)
<a name="l00735"></a>00735   {
<a name="l00736"></a>00736     <span class="keywordflow">return</span> <a class="code" href="structviennamath_1_1result__of_1_1subtract.html#af23b0d10c0e8f3cd21ae5e60215bf533">result_of::subtract&lt;LHS, RHS&gt;::instance</a>(lhs, rhs); 
<a name="l00737"></a>00737   }
<a name="l00738"></a>00738 
<a name="l00742"></a>00742   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS&gt;
<a name="l00743"></a>00743   <span class="keyword">typename</span> enable_if&lt; result_of::is_viennamath&lt;LHS&gt;::value || result_of::is_viennamath&lt;RHS&gt;::value,
<a name="l00744"></a>00744                       <span class="keyword">typename</span> result_of::mult&lt;LHS, RHS&gt;::type &gt;::type
<a name="l00745"></a><a class="code" href="namespaceviennamath.html#a456766f51c85687bb300c754e5db6d67">00745</a>   <a class="code" href="namespaceviennamath.html#a5c9e697377a7c6ce26c3315c9169ea01" title="Special overload: Condense multiplication of two compiletime constants into one constant.">operator*</a>(LHS <span class="keyword">const</span> &amp; lhs, RHS <span class="keyword">const</span> &amp; rhs)
<a name="l00746"></a>00746   {
<a name="l00747"></a>00747     <span class="keywordflow">return</span> <a class="code" href="structviennamath_1_1result__of_1_1mult.html#af23b0d10c0e8f3cd21ae5e60215bf533">result_of::mult&lt;LHS, RHS&gt;::instance</a>(lhs, rhs); 
<a name="l00748"></a>00748   }
<a name="l00749"></a>00749   
<a name="l00753"></a>00753   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LHS, <span class="keyword">typename</span> RHS&gt;
<a name="l00754"></a>00754   <span class="keyword">typename</span> enable_if&lt; result_of::is_viennamath&lt;LHS&gt;::value || result_of::is_viennamath&lt;RHS&gt;::value,
<a name="l00755"></a>00755                       <span class="keyword">typename</span> result_of::div&lt;LHS, RHS&gt;::type &gt;::type
<a name="l00756"></a><a class="code" href="namespaceviennamath.html#aa3ab0fb522083f3a037467af4b19ef6f">00756</a>   <a class="code" href="namespaceviennamath.html#ab387a8c9fc10cb75a804df8b1640440a" title="Special overload: division of the same thing leads to &amp;#39;1&amp;#39;.">operator/</a>(LHS <span class="keyword">const</span> &amp; lhs, RHS <span class="keyword">const</span> &amp; rhs)
<a name="l00757"></a>00757   {
<a name="l00758"></a>00758     <span class="keywordflow">return</span> <a class="code" href="structviennamath_1_1result__of_1_1div.html#af23b0d10c0e8f3cd21ae5e60215bf533">result_of::div&lt;LHS, RHS&gt;::instance</a>(lhs, rhs); 
<a name="l00759"></a>00759   }
<a name="l00760"></a>00760   
<a name="l00761"></a>00761 }
<a name="l00762"></a>00762 
<a name="l00763"></a>00763 <span class="preprocessor">#endif</span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Feb 29 2012 21:50:43 for ViennaMath by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
