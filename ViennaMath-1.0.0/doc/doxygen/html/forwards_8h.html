<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ViennaMath: /export/development/ViennaMath/viennamath/forwards.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>/export/development/ViennaMath/viennamath/forwards.h File Reference</h1>  </div>
</div>
<div class="contents">

<p>Contains forward declarations and definition of small classes/metafunctions required to be defined at an early stage.  
<a href="#_details">More...</a></p>
<code>#include &lt;string&gt;</code><br/>
<code>#include &lt;vector&gt;</code><br/>
<code>#include &lt;exception&gt;</code><br/>
<code>#include &lt;sstream&gt;</code><br/>
<code>#include &lt;memory&gt;</code><br/>

<p><a href="forwards_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1enable__if.html">enable_if&lt; b, T &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple enable-if variant that uses the SFINAE pattern.  <a href="structviennamath_1_1enable__if.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1enable__if_3_01false_00_01_t_01_4.html">enable_if&lt; false, T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1cartesian.html">cartesian&lt; dim &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag representing a Cartesian coordinate system in arbitrary dimensions.  <a href="structviennamath_1_1cartesian.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1numeric__type__proxy.html">numeric_type_proxy&lt; NumericT &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A proxy object which allows for the use of plain default_numeric_type with template operator+, operator-, operator*, operator/ without running into problems with ambiguity. With the proxy object, one additional conversion is required, thus resolving the ambiguity.  <a href="classviennamath_1_1numeric__type__proxy.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1ct__index.html">ct_index&lt; i &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compiletime respresentation of a vector access index.  <a href="structviennamath_1_1ct__index.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath.html">is_viennamath&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A metafunction with value 'true' if the provided argument is a ViennaMath expression type. Otherwise, false is returned.  <a href="structviennamath_1_1result__of_1_1is__viennamath.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__constant_3_01val_01_4_01_4.html">is_viennamath&lt; ct_constant&lt; val &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath compiletime constant.  <a href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__constant_3_01val_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__variable_3_01id_01_4_01_4.html">is_viennamath&lt; ct_variable&lt; id &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath compiletime variable.  <a href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__variable_3_01id_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__function__symbol_3_01_t_a_g_01_4_01_4.html">is_viennamath&lt; ct_function_symbol&lt; TAG &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath compiletime function symbol.  <a href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__function__symbol_3_01_t_a_g_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h_s_01_4_01_4.html">is_viennamath&lt; ct_binary_expr&lt; LHS, OP, RHS &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath compiletime binary expression.  <a href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h_s_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__unary__expr_3_01_l_h_s_00_01_o_p_01_4_01_4.html">is_viennamath&lt; ct_unary_expr&lt; LHS, OP &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath compiletime unary expression.  <a href="structviennamath_1_1result__of_1_1is__viennamath_3_01ct__unary__expr_3_01_l_h_s_00_01_o_p_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__constant_3_01_numeric_type_00_01_interface_type_01_4_01_4.html">is_viennamath&lt; rt_constant&lt; NumericType, InterfaceType &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath runtime constant.  <a href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__constant_3_01_numeric_type_00_01_interface_type_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__variable_3_01_interface_type_01_4_01_4.html">is_viennamath&lt; rt_variable&lt; InterfaceType &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath runtime variable.  <a href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__variable_3_01_interface_type_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__function__symbol_3_01_interface_type_01_4_01_4.html">is_viennamath&lt; rt_function_symbol&lt; InterfaceType &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath runtime function symbol.  <a href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__function__symbol_3_01_interface_type_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__unary__expr_3_01_interface_type_01_4_01_4.html">is_viennamath&lt; rt_unary_expr&lt; InterfaceType &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath runtime unary expression.  <a href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__unary__expr_3_01_interface_type_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__binary__expr_3_01_interface_type_01_4_01_4.html">is_viennamath&lt; rt_binary_expr&lt; InterfaceType &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath runtime binary expression.  <a href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__binary__expr_3_01_interface_type_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__expr_3_01_interface_type_01_4_01_4.html">is_viennamath&lt; rt_expr&lt; InterfaceType &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath runtime expression.  <a href="structviennamath_1_1result__of_1_1is__viennamath_3_01rt__expr_3_01_interface_type_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__compiletime.html">is_compiletime&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A metafunction returning a value 'true' if the provided argument is a ViennaMath compiletime expression type. Otherwise, false is returned.  <a href="structviennamath_1_1result__of_1_1is__compiletime.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__constant_3_01val_01_4_01_4.html">is_compiletime&lt; ct_constant&lt; val &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath compiletime constant.  <a href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__constant_3_01val_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__variable_3_01id_01_4_01_4.html">is_compiletime&lt; ct_variable&lt; id &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath compiletime variable.  <a href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__variable_3_01id_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__function__symbol_3_01_t_a_g_01_4_01_4.html">is_compiletime&lt; ct_function_symbol&lt; TAG &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath compiletime function symbol.  <a href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__function__symbol_3_01_t_a_g_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h_s_01_4_01_4.html">is_compiletime&lt; ct_binary_expr&lt; LHS, OP, RHS &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath compiletime binary expression.  <a href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__binary__expr_3_01_l_h_s_00_01_o_p_00_01_r_h_s_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__unary__expr_3_01_l_h_s_00_01_o_p_01_4_01_4.html">is_compiletime&lt; ct_unary_expr&lt; LHS, OP &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the metafunction for a ViennaMath compiletime unary expression.  <a href="structviennamath_1_1result__of_1_1is__compiletime_3_01ct__unary__expr_3_01_l_h_s_00_01_o_p_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1interface.html">interface&lt; LHS, RHS &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A metafunction deducing the ViennaMath runtime expression interface (base class) from two types. The first argument has priority.  <a href="structviennamath_1_1result__of_1_1interface.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1interface_3_01rt__constant_3_01_t_00_01_u_01_4_00_01_r_h_s_01_4.html">interface&lt; rt_constant&lt; T, U &gt;, RHS &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the runtime expression interface deduction for a ViennaMath runtime constant.  <a href="structviennamath_1_1result__of_1_1interface_3_01rt__constant_3_01_t_00_01_u_01_4_00_01_r_h_s_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1interface_3_01rt__variable_3_01_t_01_4_00_01_r_h_s_01_4.html">interface&lt; rt_variable&lt; T &gt;, RHS &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the runtime expression interface deduction for a ViennaMath runtime variable.  <a href="structviennamath_1_1result__of_1_1interface_3_01rt__variable_3_01_t_01_4_00_01_r_h_s_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1interface_3_01default__numeric__type_00_01rt__variable_3_01_t_01_4_01_4.html">interface&lt; default_numeric_type, rt_variable&lt; T &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the runtime expression interface deduction for a ViennaMath runtime variable.  <a href="structviennamath_1_1result__of_1_1interface_3_01default__numeric__type_00_01rt__variable_3_01_t_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1interface_3_01rt__binary__expr_3_01_t_01_4_00_01_r_h_s_01_4.html">interface&lt; rt_binary_expr&lt; T &gt;, RHS &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the runtime expression interface deduction for a ViennaMath runtime binary expression.  <a href="structviennamath_1_1result__of_1_1interface_3_01rt__binary__expr_3_01_t_01_4_00_01_r_h_s_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1interface_3_01default__numeric__type_00_01rt__binary__expr_3_01_t_01_4_01_4.html">interface&lt; default_numeric_type, rt_binary_expr&lt; T &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the runtime expression interface deduction for a ViennaMath runtime binary expression.  <a href="structviennamath_1_1result__of_1_1interface_3_01default__numeric__type_00_01rt__binary__expr_3_01_t_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1interface_3_01rt__unary__expr_3_01_t_01_4_00_01_r_h_s_01_4.html">interface&lt; rt_unary_expr&lt; T &gt;, RHS &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the runtime expression interface deduction for a ViennaMath runtime unary expression.  <a href="structviennamath_1_1result__of_1_1interface_3_01rt__unary__expr_3_01_t_01_4_00_01_r_h_s_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1interface_3_01rt__expr_3_01_t_01_4_00_01_r_h_s_01_4.html">interface&lt; rt_expr&lt; T &gt;, RHS &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the runtime expression interface deduction for the ViennaMath runtime expression wrapper.  <a href="structviennamath_1_1result__of_1_1interface_3_01rt__expr_3_01_t_01_4_00_01_r_h_s_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1interface_3_01double_00_01rt__expr_3_01_t_01_4_01_4.html">interface&lt; double, rt_expr&lt; T &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the runtime expression interface deduction for the ViennaMath runtime expression wrapper.  <a href="structviennamath_1_1result__of_1_1interface_3_01double_00_01rt__expr_3_01_t_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1gcd.html">gcd&lt; a, b &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper metafunction for computing the greatest common divisor of two numbers.  <a href="structviennamath_1_1result__of_1_1gcd.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1gcd_3_01a_00_010_01_4.html">gcd&lt; a, 0 &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for the computation of the greatest common divisor of a and 0, which is a.  <a href="structviennamath_1_1result__of_1_1gcd_3_01a_00_010_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1result__of_1_1gcd_3_010_00_010_01_4.html">gcd&lt; 0, 0 &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization forcing a compile time error, since the greatest common divisor of 0 and 0 is not defined.  <a href="structviennamath_1_1result__of_1_1gcd_3_010_00_010_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1expression__traits.html">expression_traits&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A traits system for expressions. For now provides a deduction of the const reference type only.  <a href="structviennamath_1_1expression__traits.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1expression__traits_3_01ct__constant_3_01value_01_4_01_4.html">expression_traits&lt; ct_constant&lt; value &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the expression traits system: A compiletime constant can be copied with no extra cost, thus no need for const reference.  <a href="structviennamath_1_1expression__traits_3_01ct__constant_3_01value_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1expression__traits_3_01rt__constant_3_01_t_00_01_interface_type_01_4_01_4.html">expression_traits&lt; rt_constant&lt; T, InterfaceType &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the expression traits system: A runtime constant does not allow for copying, otherwise one runs into problems with tempories.  <a href="structviennamath_1_1expression__traits_3_01rt__constant_3_01_t_00_01_interface_type_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html">viennamath</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The main ViennaMath namespace. All types and functions for the user reside here. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath_1_1result__of.html">viennamath::result_of</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The namespace containing a set of metafunctions which can be used by the ViennaMath library user. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The underlying floating point type to be used in case of doubt (e.g. when new constants are created during manipulation).  <a href="#a97e77ded8737e25ae18d165a33179286"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#acff9357d27786ad0c1d9ae2e78ab83d2">id_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type used for any kind of IDs (variable, etc.).  <a href="#acff9357d27786ad0c1d9ae2e78ab83d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
rt_expression_interface<br class="typebreak"/>
&lt; default_numeric_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ac8b78c7806640b05ca58aaeba616d9c1">default_interface_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience type definition for the default expression interface.  <a href="#ac8b78c7806640b05ca58aaeba616d9c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef rt_variable&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aca2ca1f2df887f6733612f7bebb12550">variable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef rt_constant&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aba5112b4db8f18758911907e380cf264">constant</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef rt_binary_expr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ad9a6d21e340fc856e9e2a7ebb6cf21ca">binary_expr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef rt_unary_expr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a28408548bab180778977b5f39a383449">unary_expr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef rt_expr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a50974365c0be03981bbd761766c970b6">expr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef rt_vector_expr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a2993287894f3ac500b754b731eadc295">vector_expr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef rt_function_symbol&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ab6b5705970b712844d53cbe01b130eec">function_symbol</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef rt_equation&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a851bad3788c5dbe912da12d0c40d4d20">equation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef rt_interval&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a4b0e68703e0147319ac33fb857f1cdea">interval</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef rt_symbolic_interval&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a2f381b80192d3734ea27b03e10d7bb21">symbolic_interval</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">enable_if<br class="typebreak"/>
&lt; result_of::is_viennamath<br class="typebreak"/>
&lt; LHS &gt;::value||result_of::is_viennamath<br class="typebreak"/>
&lt; RHS &gt;::value, typename <br class="typebreak"/>
result_of::add&lt; LHS, RHS &gt;<br class="typebreak"/>
::type &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aaf03494c176b69f6988225edfc9e74be">operator+</a> (LHS const &amp;lhs, RHS const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic overload of the addition operator for ViennaMath types. Uses SFINAE to control the scope, otherwise one may run into very tricky problems with operator+ being considered outside the viennamath namespace.  <a href="#aaf03494c176b69f6988225edfc9e74be"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">enable_if<br class="typebreak"/>
&lt; result_of::is_viennamath<br class="typebreak"/>
&lt; LHS &gt;::value||result_of::is_viennamath<br class="typebreak"/>
&lt; RHS &gt;::value, typename <br class="typebreak"/>
result_of::subtract&lt; LHS, RHS &gt;<br class="typebreak"/>
::type &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#abc5bac5399fd74594c55f8a65d89b8c4">operator-</a> (LHS const &amp;lhs, RHS const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic overload of the subtraction operator for ViennaMath types. Uses SFINAE to control the scope, otherwise one may run into very tricky problems with operator- being considered outside the viennamath namespace.  <a href="#abc5bac5399fd74594c55f8a65d89b8c4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">enable_if<br class="typebreak"/>
&lt; result_of::is_viennamath<br class="typebreak"/>
&lt; LHS &gt;::value||result_of::is_viennamath<br class="typebreak"/>
&lt; RHS &gt;::value, typename <br class="typebreak"/>
result_of::mult&lt; LHS, RHS &gt;<br class="typebreak"/>
::type &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a456766f51c85687bb300c754e5db6d67">operator*</a> (LHS const &amp;lhs, RHS const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic overload of the multiplication operator for ViennaMath types. Uses SFINAE to control the scope, otherwise one may run into very tricky problems with operator* being considered outside the viennamath namespace.  <a href="#a456766f51c85687bb300c754e5db6d67"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">enable_if<br class="typebreak"/>
&lt; result_of::is_viennamath<br class="typebreak"/>
&lt; LHS &gt;::value||result_of::is_viennamath<br class="typebreak"/>
&lt; RHS &gt;::value, typename <br class="typebreak"/>
result_of::div&lt; LHS, RHS &gt;<br class="typebreak"/>
::type &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aa3ab0fb522083f3a037467af4b19ef6f">operator/</a> (LHS const &amp;lhs, RHS const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic overload of the division operator for ViennaMath types. Uses SFINAE to control the scope, otherwise one may run into very tricky problems with operator/ being considered outside the viennamath namespace.  <a href="#aa3ab0fb522083f3a037467af4b19ef6f"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Contains forward declarations and definition of small classes/metafunctions required to be defined at an early stage. </p>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Feb 29 2012 21:50:43 for ViennaMath by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
