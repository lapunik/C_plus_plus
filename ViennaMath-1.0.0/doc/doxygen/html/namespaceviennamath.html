<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ViennaMath: viennamath Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>viennamath Namespace Reference</h1>  </div>
</div>
<div class="contents">

<p>The main ViennaMath namespace. All types and functions for the user reside here.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath_1_1detail.html">detail</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Implementation details for functionality in ViennaMath. Not intended for direct use. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath_1_1result__of.html">result_of</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The namespace containing a set of metafunctions which can be used by the ViennaMath library user. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath_1_1traits.html">traits</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Any generic free functions for unifying interfaces are defined here. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1op__plus.html">op_plus</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tag for addition.  <a href="structviennamath_1_1op__plus.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1op__minus.html">op_minus</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tag for subtraction.  <a href="structviennamath_1_1op__minus.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1op__mult.html">op_mult</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tag for multiplication.  <a href="structviennamath_1_1op__mult.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1op__div.html">op_div</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tag for division.  <a href="structviennamath_1_1op__div.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A compile time expression consisting of two operands and one operation (taking two arguments).  <a href="classviennamath_1_1ct__binary__expr.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A compiletime constant.  <a href="classviennamath_1_1ct__constant.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A compile time equation.  <a href="classviennamath_1_1ct__equation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1unknown__tag.html">unknown_tag</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A compiletime tag for an unknown function:  <a href="structviennamath_1_1unknown__tag.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1test__tag.html">test_tag</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A compiletime tag for a test function:  <a href="structviennamath_1_1test__tag.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A function symbol. Can be used for unknown functions, test functions, etc. Cannot be evaluated, but substituted with an evaluable object.  <a href="classviennamath_1_1ct__function__symbol.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A compile time interval.  <a href="classviennamath_1_1ct__interval.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines a unary expression f(e), where f is function and 'e' is an expression.  <a href="classviennamath_1_1ct__unary__expr.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1type__by__index.html">type_by_index</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper metafunction for returning the 'id'-th entry of a compiletime vector.  <a href="structviennamath_1_1type__by__index.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1type__by__index_3_01vmath__vector_00_010_01_4.html">type_by_index&lt; vmath_vector, 0 &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accesses the first entry in a compiletime vector.  <a href="structviennamath_1_1type__by__index_3_01vmath__vector_00_010_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1type__by__index_3_01vmath__vector_00_011_01_4.html">type_by_index&lt; vmath_vector, 1 &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accesses the second entry in a compiletime vector.  <a href="structviennamath_1_1type__by__index_3_01vmath__vector_00_011_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1type__by__index_3_01vmath__vector_00_012_01_4.html">type_by_index&lt; vmath_vector, 2 &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accesses the third entry in a compiletime vector.  <a href="structviennamath_1_1type__by__index_3_01vmath__vector_00_012_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1variable__traits.html">variable_traits</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper struct for accessing the i-th element of a vector at runtime.  <a href="structviennamath_1_1variable__traits.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1variable__traits_3_01ct__vector__1_3_01_t0_01_4_00_01id_01_4.html">variable_traits&lt; ct_vector_1&lt; T0 &gt;, id &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper struct for accessing the i-th element of a vector at runtime. Specialization for a ViennaMath compiletime vector with one entry.  <a href="structviennamath_1_1variable__traits_3_01ct__vector__1_3_01_t0_01_4_00_01id_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1variable__traits_3_01ct__vector__2_3_01_t0_00_01_t1_01_4_00_01id_01_4.html">variable_traits&lt; ct_vector_2&lt; T0, T1 &gt;, id &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper struct for accessing the i-th element of a vector at runtime. Specialization for a ViennaMath compiletime vector with two entries.  <a href="structviennamath_1_1variable__traits_3_01ct__vector__2_3_01_t0_00_01_t1_01_4_00_01id_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1variable__traits_3_01ct__vector__3_3_01_t0_00_01_t1_00_01_t2_01_4_00_01id_01_4.html">variable_traits&lt; ct_vector_3&lt; T0, T1, T2 &gt;, id &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper struct for accessing the i-th element of a vector at runtime. Specialization for a ViennaMath compiletime vector with three entries.  <a href="structviennamath_1_1variable__traits_3_01ct__vector__3_3_01_t0_00_01_t1_00_01_t2_01_4_00_01id_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1variable__traits_3_01ct__constant_3_01value___01_4_00_010_01_4.html">variable_traits&lt; ct_constant&lt; value_ &gt;, 0 &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper struct for accessing the 0-th element of a constant at runtime.  <a href="structviennamath_1_1variable__traits_3_01ct__constant_3_01value___01_4_00_010_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1variable__traits_3_01ct__constant_3_01value___01_4_00_01id_01_4.html">variable_traits&lt; ct_constant&lt; value_ &gt;, id &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compiletime guard for index out of bounds.  <a href="structviennamath_1_1variable__traits_3_01ct__constant_3_01value___01_4_00_01id_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Representation of a mathematical variable. If the supplied argument is some vector type, a traits system accesses the id-th component.  <a href="structviennamath_1_1ct__variable.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1ct__vector__1.html">ct_vector_1</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compiletime vector with one element.  <a href="classviennamath_1_1ct__vector__1.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1ct__vector__2.html">ct_vector_2</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compiletime vector with one element.  <a href="classviennamath_1_1ct__vector__2.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1ct__vector__3.html">ct_vector_3</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compiletime vector with one element.  <a href="classviennamath_1_1ct__vector__3.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For two numeric types T and U with objects t and u respectively, the result type of t+u is returned. Default case: return the basic numeric type for ViennaMath.  <a href="structviennamath_1_1promote__traits.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1promote__traits_3_01_t_00_01_o_p_00_01_t_01_4.html">promote_traits&lt; T, OP, T &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The result type of two operands of the same type is of the same type again (cf. standard C/C++ behavior for integers).  <a href="structviennamath_1_1promote__traits_3_01_t_00_01_o_p_00_01_t_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1promote__traits_3_01double_00_01_o_p_00_01long_01_4.html">promote_traits&lt; double, OP, long &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1promote__traits_3_01long_00_01_o_p_00_01double_01_4.html">promote_traits&lt; long, OP, double &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1promote__traits_3_01double_00_01_o_p_00_01int_01_4.html">promote_traits&lt; double, OP, int &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1promote__traits_3_01int_00_01_o_p_00_01double_01_4.html">promote_traits&lt; int, OP, double &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1promote__traits_3_01double_00_01_o_p_00_01float_01_4.html">promote_traits&lt; double, OP, float &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1promote__traits_3_01float_00_01_o_p_00_01double_01_4.html">promote_traits&lt; float, OP, double &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1promote__traits_3_01float_00_01_o_p_00_01long_01_4.html">promote_traits&lt; float, OP, long &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1promote__traits_3_01long_00_01_o_p_00_01float_01_4.html">promote_traits&lt; long, OP, float &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1promote__traits_3_01float_00_01_o_p_00_01int_01_4.html">promote_traits&lt; float, OP, int &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1promote__traits_3_01int_00_01_o_p_00_01float_01_4.html">promote_traits&lt; int, OP, float &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1promote__traits_3_01long_00_01op__div_3_01_numeric_type_01_4_00_01long_01_4.html">promote_traits&lt; long, op_div&lt; NumericType &gt;, long &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1promote__traits_3_01long_00_01op__div_3_01_numeric_type_01_4_00_01int_01_4.html">promote_traits&lt; long, op_div&lt; NumericType &gt;, int &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1promote__traits_3_01int_00_01op__div_3_01_numeric_type_01_4_00_01long_01_4.html">promote_traits&lt; int, op_div&lt; NumericType &gt;, long &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1op__id.html">op_id</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Identity mapping: x |--&gt; x.  <a href="structviennamath_1_1op__id.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1op__exp.html">op_exp</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exponential mapping: x |--&gt; exp(x).  <a href="structviennamath_1_1op__exp.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1op__sin.html">op_sin</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sine function: x |--&gt; sin(x).  <a href="structviennamath_1_1op__sin.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1op__cos.html">op_cos</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cosine function: x |--&gt; cos(x).  <a href="structviennamath_1_1op__cos.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1op__tan.html">op_tan</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tangent function: x |--&gt; tan(x).  <a href="structviennamath_1_1op__tan.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1op__fabs.html">op_fabs</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modulus: x |--&gt; |x|.  <a href="structviennamath_1_1op__fabs.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1op__sqrt.html">op_sqrt</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Square root: x |--&gt; \sqrt{x}.  <a href="structviennamath_1_1op__sqrt.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1op__log.html">op_log</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Natural logarithm function: x |--&gt; ln(x).  <a href="structviennamath_1_1op__log.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1op__log10.html">op_log10</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Logarithm with base 10: x |--&gt; \log_{10}(x).  <a href="structviennamath_1_1op__log10.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1op__gradient.html">op_gradient</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gradient operator: f |--&gt; grad(x).  <a href="structviennamath_1_1op__gradient.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1op__divergence.html">op_divergence</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Divergence operator: f |--&gt; div(f).  <a href="structviennamath_1_1op__divergence.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1op__partial__deriv.html">op_partial_deriv</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Divergence operator: f |--&gt; d f / (d x_i).  <a href="classviennamath_1_1op__partial__deriv.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1op__ct__integral.html">op_ct_integral</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Integration operator: f |--&gt; \int_I f d x.  <a href="classviennamath_1_1op__ct__integral.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1integration__without__integral__exception.html">integration_without_integral_exception</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception for the case that an integration over expressions without integral is attempted.  <a href="structviennamath_1_1integration__without__integral__exception.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1symbolic__integral__evaluation__not__possible__exception.html">symbolic_integral_evaluation_not_possible_exception</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analytic integration at runtime not supported.  <a href="structviennamath_1_1symbolic__integral__evaluation__not__possible__exception.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1analytic__integration__not__supported__exception.html">analytic_integration_not_supported_exception</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analytic integration at runtime not supported.  <a href="structviennamath_1_1analytic__integration__not__supported__exception.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1no__rhs__provided__exception.html">no_rhs_provided_exception</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An exception which is thrown if no right hand side operand is passed to a binary operation.  <a href="structviennamath_1_1no__rhs__provided__exception.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1rhs__provided__for__unary__operation__exception.html">rhs_provided_for_unary_operation_exception</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An exception which is thrown if a right hand side argument is passed to a unary operation.  <a href="structviennamath_1_1rhs__provided__for__unary__operation__exception.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1expression__not__evaluable__exception.html">expression_not_evaluable_exception</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An exception which is thrown if an expression should be evaluated to a floating point number using <a class="el" href="namespaceviennamath.html#adc71b02c9631188dfd54d127ab2fabd4" title="Main user function for the evaluation of a compiletime expression at compiletime.">eval()</a>, but at least one of the leaves in the expression tree cannot be evaluated (e.g. is a function symbol).  <a href="classviennamath_1_1expression__not__evaluable__exception.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1expression__not__unwrappable__exception.html">expression_not_unwrappable_exception</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An exception which is thrown if an expression should be reduced to a floating point number using unwrap(), but at least one of the leaves in the expression tree is not a constant (e.g. is a variable).  <a href="classviennamath_1_1expression__not__unwrappable__exception.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1expression__not__differentiable__exception.html">expression_not_differentiable_exception</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An exception which is thrown if an expression should be differentiated, but at least one of the leaves in the expression tree cannot be differentiated (e.g. is a function symbol).  <a href="classviennamath_1_1expression__not__differentiable__exception.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1variable__index__out__of__bounds__exception.html">variable_index_out_of_bounds_exception</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An exception which is thrown if a variable index is out of bounds. Similar to the C++ STL, index checks are performed on vectors using the .at() member function only.  <a href="classviennamath_1_1variable__index__out__of__bounds__exception.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1enable__if.html">enable_if</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple enable-if variant that uses the SFINAE pattern.  <a href="structviennamath_1_1enable__if.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1enable__if_3_01false_00_01_t_01_4.html">enable_if&lt; false, T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1cartesian.html">cartesian</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag representing a Cartesian coordinate system in arbitrary dimensions.  <a href="structviennamath_1_1cartesian.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1numeric__type__proxy.html">numeric_type_proxy</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A proxy object which allows for the use of plain default_numeric_type with template operator+, operator-, operator*, operator/ without running into problems with ambiguity. With the proxy object, one additional conversion is required, thus resolving the ambiguity.  <a href="classviennamath_1_1numeric__type__proxy.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1ct__index.html">ct_index</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compiletime respresentation of a vector access index.  <a href="structviennamath_1_1ct__index.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1expression__traits.html">expression_traits</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A traits system for expressions. For now provides a deduction of the const reference type only.  <a href="structviennamath_1_1expression__traits.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1expression__traits_3_01ct__constant_3_01value_01_4_01_4.html">expression_traits&lt; ct_constant&lt; value &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the expression traits system: A compiletime constant can be copied with no extra cost, thus no need for const reference.  <a href="structviennamath_1_1expression__traits_3_01ct__constant_3_01value_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1expression__traits_3_01rt__constant_3_01_t_00_01_interface_type_01_4_01_4.html">expression_traits&lt; rt_constant&lt; T, InterfaceType &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization of the expression traits system: A runtime constant does not allow for copying, otherwise one runs into problems with tempories.  <a href="structviennamath_1_1expression__traits_3_01rt__constant_3_01_t_00_01_interface_type_01_4_01_4.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__latex__processor__interface.html">rt_latex_processor_interface</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The abstract interface for each LaTeX processor module.  <a href="classviennamath_1_1rt__latex__processor__interface.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__latex__translator.html">rt_latex_translator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The main LaTeX translator class. To be used and manipulated by the ViennaMath library user.  <a href="classviennamath_1_1rt__latex__translator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__latex__binary__expr__processor.html">rt_latex_binary_expr_processor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A LaTeX processor responsible for translating binary expressions to LaTeX code.  <a href="classviennamath_1_1rt__latex__binary__expr__processor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__latex__unary__expr__processor.html">rt_latex_unary_expr_processor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A LaTeX processor responsible for translating unary expressions to LaTeX code.  <a href="classviennamath_1_1rt__latex__unary__expr__processor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__latex__constant__processor.html">rt_latex_constant_processor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A LaTeX processor responsible for translating ViennaMath runtime constants to LaTeX code.  <a href="classviennamath_1_1rt__latex__constant__processor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__latex__variable__processor.html">rt_latex_variable_processor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A LaTeX processor responsible for translating ViennaMath runtime variables to LaTeX code.  <a href="classviennamath_1_1rt__latex__variable__processor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__latex__function__symbol__processor.html">rt_latex_function_symbol_processor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A LaTeX processor responsible for translating ViennaMath runtime function symbols to LaTeX code.  <a href="classviennamath_1_1rt__latex__function__symbol__processor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Runtime representation of a binary expression F(x,y), where F is a function of two argument (e.g. +) and x,y are expressions.  <a href="classviennamath_1_1rt__binary__expr.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1op__binary.html">op_binary</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the common wrapper class for binary operations.  <a href="classviennamath_1_1op__binary.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Representation of a constant within the expression setting of ViennaMath.  <a href="classviennamath_1_1rt__constant.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Runtime representation of a equation by a left hand side and a right hand side expresssion.  <a href="classviennamath_1_1rt__equation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class represents a smart pointer to all types expressions.  <a href="classviennamath_1_1rt__expr.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__expression__interface.html">rt_expression_interface</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract interface for all ViennaMath runtime expressions.  <a href="classviennamath_1_1rt__expression__interface.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__function__symbol.html">rt_function_symbol</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A function symbol. Can be used for unknown functions, test functions, etc. Cannot be evaluated, but substituted with an evaluable object.  <a href="classviennamath_1_1rt__function__symbol.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__manipulation__interface.html">rt_manipulation_interface</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The abstract runtime interface for all expression manipulators.  <a href="classviennamath_1_1rt__manipulation__interface.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__manipulation__wrapper.html">rt_manipulation_wrapper</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A wrapper using type erasure for manipulation functors acting on expressions.  <a href="classviennamath_1_1rt__manipulation__wrapper.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__traversal__interface.html">rt_traversal_interface</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The abstract runtime interface for all expression traversal routines.  <a href="classviennamath_1_1rt__traversal__interface.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__traversal__wrapper.html">rt_traversal_wrapper</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A wrapper using type erasure for traversal functions acting on expressions.  <a href="classviennamath_1_1rt__traversal__wrapper.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structviennamath_1_1callback__if__castable.html">callback_if_castable</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A helper class which calls a provided functor if the supplied expression pointer can be cast to the target type.  <a href="structviennamath_1_1callback__if__castable.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1op__rt__integral.html">op_rt_integral</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A unary operation defining an integral over an interval.  <a href="classviennamath_1_1op__rt__integral.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1op__rt__symbolic__integral.html">op_rt_symbolic_integral</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A unary operation encoding a symbolic interval. Cannot be evaluated and is meant to be replaced by a concrete integration later on.  <a href="classviennamath_1_1op__rt__symbolic__integral.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents an interval [a,b] at runtime. Note that the interval boundaries do not need to be constants.  <a href="classviennamath_1_1rt__interval.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1numerical__quadrature__interface.html">numerical_quadrature_interface</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The abstract runtime interface for all numerical quadrature rules.  <a href="classviennamath_1_1numerical__quadrature__interface.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__gauss__quad__1.html">rt_gauss_quad_1</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gauss quadrature rule with first-order accuracy.  <a href="classviennamath_1_1rt__gauss__quad__1.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__numerical__quadrature.html">rt_numerical_quadrature</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The main numerical quadrature rule class. Wraps the integration rule and performs all the book-keeping for the evaluation.  <a href="classviennamath_1_1rt__numerical__quadrature.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1op__interface.html">op_interface</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The abstract runtime interface for all operations (unary and binary).  <a href="classviennamath_1_1op__interface.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__symbolic__interval.html">rt_symbolic_interval</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A symbolic runtime interval.  <a href="classviennamath_1_1rt__symbolic__interval.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Runtime representation of a unary expression F(e), where F is a function of one argument (e.g. <a class="el" href="namespaceviennamath.html#aeb237d8f5686e7cddc50e8b2dc5a703e" title="Overload of the natural logarithm function for a ViennaMath runtime constant.">log()</a>) and e is an expression.  <a href="classviennamath_1_1rt__unary__expr.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1op__unary.html">op_unary</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Main class for all unary operations.  <a href="classviennamath_1_1op__unary.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Representation of an variable (a variable). If the supplied argument is some vector type, a traits system accesses the id-th component.  <a href="classviennamath_1_1rt__variable.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classviennamath_1_1rt__vector__expr.html">rt_vector_expr</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An tweaked auto_ptr for run time <a class="el" href="classviennamath_1_1rt__expr.html" title="This class represents a smart pointer to all types expressions.">rt_expr</a> types.  <a href="classviennamath_1_1rt__vector__expr.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The underlying floating point type to be used in case of doubt (e.g. when new constants are created during manipulation).  <a href="#a97e77ded8737e25ae18d165a33179286"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#acff9357d27786ad0c1d9ae2e78ab83d2">id_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type used for any kind of IDs (variable, etc.).  <a href="#acff9357d27786ad0c1d9ae2e78ab83d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classviennamath_1_1rt__expression__interface.html">rt_expression_interface</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ac8b78c7806640b05ca58aaeba616d9c1">default_interface_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience type definition for the default expression interface.  <a href="#ac8b78c7806640b05ca58aaeba616d9c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aca2ca1f2df887f6733612f7bebb12550">variable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aba5112b4db8f18758911907e380cf264">constant</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ad9a6d21e340fc856e9e2a7ebb6cf21ca">binary_expr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a28408548bab180778977b5f39a383449">unary_expr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a50974365c0be03981bbd761766c970b6">expr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennamath_1_1rt__vector__expr.html">rt_vector_expr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a2993287894f3ac500b754b731eadc295">vector_expr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennamath_1_1rt__function__symbol.html">rt_function_symbol</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ab6b5705970b712844d53cbe01b130eec">function_symbol</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a851bad3788c5dbe912da12d0c40d4d20">equation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a4b0e68703e0147319ac33fb857f1cdea">interval</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennamath_1_1rt__symbolic__interval.html">rt_symbolic_interval</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a2f381b80192d3734ea27b03e10d7bb21">symbolic_interval</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennamath_1_1rt__latex__translator.html">rt_latex_translator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a60b5a0cfc11e63a12ed29bb2ed6a364e">latex_translator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience typedef for the latex translator in order to avoid the ugly '&lt;&gt;' for the default template parameter of <a class="el" href="classviennamath_1_1rt__latex__translator.html" title="The main LaTeX translator class. To be used and manipulated by the ViennaMath library user...">rt_latex_translator</a>.  <a href="#a60b5a0cfc11e63a12ed29bb2ed6a364e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennamath_1_1rt__gauss__quad__1.html">rt_gauss_quad_1</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a36770fadae668b44095f251e00511537">gauss_quad_1</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classviennamath_1_1rt__numerical__quadrature.html">rt_numerical_quadrature</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a79a2a51538257b304d7801a5d4404474">numerical_quadrature</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a6718c3868b4e8d87b724e88366c38b0c">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS, OP, RHS &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience overload for printing a compiletime binary expression to an output stream.  <a href="#a6718c3868b4e8d87b724e88366c38b0c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value_&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a2f3d57f39b39e62c1137df0d1ed41bd0">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value_ &gt; const &amp;c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience overload for printing a compiletime constant to an output stream.  <a href="#a2f3d57f39b39e62c1137df0d1ed41bd0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a131e77c1c72b390bd576740bd3ddb744">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt; LHS, RHS &gt; const &amp;u)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience overload for printing a compiletime equation to an output stream.  <a href="#a131e77c1c72b390bd576740bd3ddb744"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename OP1 , typename RHS1 , typename LHS2 , typename OP2 , typename RHS2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt; <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a><br class="typebreak"/>
&lt; LHS1, OP1, RHS1 &gt;<br class="typebreak"/>
, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS2, OP2, <br class="typebreak"/>
RHS2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#add4a1ae18991014d98974999f73d6501">make_equation</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS1, OP1, RHS1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS2, OP2, RHS2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an equation from two binary expressions at compiletime.  <a href="#add4a1ae18991014d98974999f73d6501"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename OP1 , typename RHS1 , typename LHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt; <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a><br class="typebreak"/>
&lt; LHS1, OP1, RHS1 &gt;<br class="typebreak"/>
, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS2, OP2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a7888da1175eab8c9581337f19768bd45">make_equation</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS1, OP1, RHS1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS2, OP2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an equation from a binary expressions and a unary expression at compiletime.  <a href="#a7888da1175eab8c9581337f19768bd45"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename OP1 , typename RHS1 , long value&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt; <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a><br class="typebreak"/>
&lt; LHS1, OP1, RHS1 &gt;<br class="typebreak"/>
, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a83deea69be0d24015a7b4192cee5cbd2">make_equation</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS1, OP1, RHS1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an equation from a binary expressions and a constant at compiletime.  <a href="#a83deea69be0d24015a7b4192cee5cbd2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename OP1 , typename RHS1 , typename TAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt; <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a><br class="typebreak"/>
&lt; LHS1, OP1, RHS1 &gt;<br class="typebreak"/>
, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#afd347142e25ba9f8d059f57322992dcb">make_equation</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS1, OP1, RHS1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an equation from a binary expressions and a function symbol at compiletime.  <a href="#afd347142e25ba9f8d059f57322992dcb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename OP1 , typename RHS1 , id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt; <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a><br class="typebreak"/>
&lt; LHS1, OP1, RHS1 &gt;<br class="typebreak"/>
, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a767e37950716493d58cd56f9ab11b56c">make_equation</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS1, OP1, RHS1 &gt; const &amp;lhs, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an equation from a binary expressions and a variable at compiletime.  <a href="#a767e37950716493d58cd56f9ab11b56c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename OP1 , typename LHS2 , typename OP2 , typename RHS2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt; <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a><br class="typebreak"/>
&lt; LHS1, OP1 &gt;, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a><br class="typebreak"/>
&lt; LHS2, OP2, RHS2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a84f877a23da1606e62aed3ed23721aa1">make_equation</a> (<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS1, OP1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS2, OP2, RHS2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an equation from a unary expressions and a binary expression at compiletime.  <a href="#a84f877a23da1606e62aed3ed23721aa1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename OP1 , typename LHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt; <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a><br class="typebreak"/>
&lt; LHS1, OP1 &gt;, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a><br class="typebreak"/>
&lt; LHS2, OP2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a1a9694ff1100f5214a3a87e0cbbe70d6">make_equation</a> (<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS1, OP1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS2, OP2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an equation from two unary expressions at compiletime.  <a href="#a1a9694ff1100f5214a3a87e0cbbe70d6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename OP1 , long value&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt; <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a><br class="typebreak"/>
&lt; LHS1, OP1 &gt;, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a><br class="typebreak"/>
&lt; value &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a8e7a6ed0e53f2d15e8f2194a235cb699">make_equation</a> (<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS1, OP1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an equation from a unary expressions and a constant at compiletime.  <a href="#a8e7a6ed0e53f2d15e8f2194a235cb699"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename OP1 , typename TAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt; <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a><br class="typebreak"/>
&lt; LHS1, OP1 &gt;<br class="typebreak"/>
, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a5cc963a04160551e0c3c80087c04e9f8">make_equation</a> (<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS1, OP1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an equation from a unary expressions and a function symbol at compiletime.  <a href="#a5cc963a04160551e0c3c80087c04e9f8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename OP1 , id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt; <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a><br class="typebreak"/>
&lt; LHS1, OP1 &gt;, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#abe6b4efb7cee97a998c909a5f8cd4a52">make_equation</a> (<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS1, OP1 &gt; const &amp;lhs, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an equation from a unary expressions and a variable at compiletime.  <a href="#abe6b4efb7cee97a998c909a5f8cd4a52"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value1, typename LHS2 , typename OP2 , typename RHS2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a><br class="typebreak"/>
&lt; value1 &gt;, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a><br class="typebreak"/>
&lt; LHS2, OP2, RHS2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a0acc4326232c49b6844ae7d36a3c5321">make_equation</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS2, OP2, RHS2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an equation from a constant and a binary expression at compiletime.  <a href="#a0acc4326232c49b6844ae7d36a3c5321"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value1, typename LHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a><br class="typebreak"/>
&lt; value1 &gt;, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a><br class="typebreak"/>
&lt; LHS2, OP2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ab4a59a2515079317fa4e4536d5644a1f">make_equation</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS2, OP2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an equation from a constant and a unary expression at compiletime.  <a href="#ab4a59a2515079317fa4e4536d5644a1f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value1, long value2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a><br class="typebreak"/>
&lt; value1 &gt;, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a><br class="typebreak"/>
&lt; value2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#abb9d548fac3628cd418061b3f7540227">make_equation</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an equation from two constants at compiletime.  <a href="#abb9d548fac3628cd418061b3f7540227"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value1, typename TAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a><br class="typebreak"/>
&lt; value1 &gt;, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a><br class="typebreak"/>
&lt; TAG &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#acee7618050972a4797b9615e244118e3">make_equation</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an equation from a constant and a function symbol at compiletime.  <a href="#acee7618050972a4797b9615e244118e3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value1, id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a><br class="typebreak"/>
&lt; value1 &gt;, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a7ca225bfb0cfaa3d17c12208b37746c5">make_equation</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value1 &gt; const &amp;lhs, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an equation from a constant and a variable at compiletime.  <a href="#a7ca225bfb0cfaa3d17c12208b37746c5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TAG , typename LHS2 , typename OP2 , typename RHS2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a><br class="typebreak"/>
&lt; <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt;<br class="typebreak"/>
, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS2, OP2, <br class="typebreak"/>
RHS2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#adeaf2a2dcb3b0b7f37aff0878852bbb1">make_equation</a> (<a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS2, OP2, RHS2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an equation from a function symbol and a binary expression at compiletime.  <a href="#adeaf2a2dcb3b0b7f37aff0878852bbb1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TAG , typename LHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a><br class="typebreak"/>
&lt; <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt;<br class="typebreak"/>
, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS2, OP2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a80308557d326a80d72ad4f2740bc326e">make_equation</a> (<a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS2, OP2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an equation from a function symbol and a unary expression at compiletime.  <a href="#a80308557d326a80d72ad4f2740bc326e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TAG , long value&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a><br class="typebreak"/>
&lt; <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt;<br class="typebreak"/>
, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a1392eca4e428f0895b46c627d004005a">make_equation</a> (<a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an equation from a function symbol and a constant at compiletime.  <a href="#a1392eca4e428f0895b46c627d004005a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TAG1 , typename TAG2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a><br class="typebreak"/>
&lt; <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG1 &gt;<br class="typebreak"/>
, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a9a265e80d965fbe2d9917e13650892c7">make_equation</a> (<a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an equation from two function symbols at compiletime.  <a href="#a9a265e80d965fbe2d9917e13650892c7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TAG , id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a><br class="typebreak"/>
&lt; <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt;<br class="typebreak"/>
, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ab2e734ddfdee0d920848ba181772a6e1">make_equation</a> (<a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt; const &amp;lhs, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an equation from a function symbol and a variable at compiletime.  <a href="#ab2e734ddfdee0d920848ba181772a6e1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id1, typename LHS2 , typename OP2 , typename RHS2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt; <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id1 &gt;<br class="typebreak"/>
, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS2, OP2, <br class="typebreak"/>
RHS2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a935774c963fa6f3cd64c5171d19720be">make_equation</a> (<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS2, OP2, RHS2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an equation from a variable and a binary expression at compiletime.  <a href="#a935774c963fa6f3cd64c5171d19720be"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id1, typename LHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt; <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id1 &gt;<br class="typebreak"/>
, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS2, OP2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a4bded0b31f7a2dc492b9af6da45c341b">make_equation</a> (<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS2, OP2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an equation from a variable and a unary expression at compiletime.  <a href="#a4bded0b31f7a2dc492b9af6da45c341b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id1, long value2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt; <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id1 &gt;<br class="typebreak"/>
, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a907d596009397f34675578dcc21462dd">make_equation</a> (<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an equation from a variable and a constant at compiletime.  <a href="#a907d596009397f34675578dcc21462dd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id1, typename TAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt; <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id1 &gt;<br class="typebreak"/>
, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a7434b2696c2b420582de0f16d03f025f">make_equation</a> (<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an equation from a variable and a function symbol at compiletime.  <a href="#a7434b2696c2b420582de0f16d03f025f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id1, id_type id2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt; <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id1 &gt;<br class="typebreak"/>
, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a1e46690ad9bfff5ce059662e0bb8a089">make_equation</a> (<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id1 &gt; const &amp;lhs, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an equation from two variables at compiletime.  <a href="#a1e46690ad9bfff5ce059662e0bb8a089"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a4a65fb56be14e23ca213f8d6806ae287">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; Tag &gt; const &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience overload for printing a compiletime function symbol to an output stream.  <a href="#a4a65fb56be14e23ca213f8d6806ae287"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a403ecd7be88e92a2ccfc901e82c81a73">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt; LHS, RHS &gt; const &amp;u)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience overload for printing a compiletime interval to an output stream.  <a href="#a403ecd7be88e92a2ccfc901e82c81a73"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename OP1 , typename RHS1 , typename LHS2 , typename OP2 , typename RHS2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt; <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a><br class="typebreak"/>
&lt; LHS1, OP1, RHS1 &gt;<br class="typebreak"/>
, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS2, OP2, <br class="typebreak"/>
RHS2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a9767bae21e77482491a62a4889c993a5">make_interval</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS1, OP1, RHS1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS2, OP2, RHS2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an interval from two binary expressions at compiletime.  <a href="#a9767bae21e77482491a62a4889c993a5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename OP1 , typename RHS1 , typename LHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt; <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a><br class="typebreak"/>
&lt; LHS1, OP1, RHS1 &gt;<br class="typebreak"/>
, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS2, OP2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a4e994b2dba9f14c3e08e8406e3b0af87">make_interval</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS1, OP1, RHS1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS2, OP2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an interval from a binary expression and a unary expression at compiletime.  <a href="#a4e994b2dba9f14c3e08e8406e3b0af87"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename OP1 , typename RHS1 , long value&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt; <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a><br class="typebreak"/>
&lt; LHS1, OP1, RHS1 &gt;<br class="typebreak"/>
, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a50ae4586eaa29562af3b676cc25b720a">make_interval</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS1, OP1, RHS1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an interval from a binary expression and a constant at compiletime.  <a href="#a50ae4586eaa29562af3b676cc25b720a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename OP1 , typename RHS1 , typename TAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt; <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a><br class="typebreak"/>
&lt; LHS1, OP1, RHS1 &gt;<br class="typebreak"/>
, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a49b0fea2d3317d93f15a925022329e23">make_interval</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS1, OP1, RHS1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an interval from a binary expression and a function symbol at compiletime.  <a href="#a49b0fea2d3317d93f15a925022329e23"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename OP1 , typename RHS1 , id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt; <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a><br class="typebreak"/>
&lt; LHS1, OP1, RHS1 &gt;<br class="typebreak"/>
, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a8bcda02cb6f61be2622b77d117ba962d">make_interval</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS1, OP1, RHS1 &gt; const &amp;lhs, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an interval from a binary expression and a variable at compiletime.  <a href="#a8bcda02cb6f61be2622b77d117ba962d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename OP1 , typename LHS2 , typename OP2 , typename RHS2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt; <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a><br class="typebreak"/>
&lt; LHS1, OP1 &gt;, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a><br class="typebreak"/>
&lt; LHS2, OP2, RHS2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ae9f6464bdef45ff9c5870e4fb83f5011">make_interval</a> (<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS1, OP1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS2, OP2, RHS2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an interval from a unary expression and a binary expression at compiletime.  <a href="#ae9f6464bdef45ff9c5870e4fb83f5011"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename OP1 , typename LHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt; <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a><br class="typebreak"/>
&lt; LHS1, OP1 &gt;, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a><br class="typebreak"/>
&lt; LHS2, OP2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a3dba992f3529b044a87b528f947ebf25">make_interval</a> (<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS1, OP1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS2, OP2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an interval from two unary expressions at compiletime.  <a href="#a3dba992f3529b044a87b528f947ebf25"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename OP1 , long value&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt; <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a><br class="typebreak"/>
&lt; LHS1, OP1 &gt;, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a><br class="typebreak"/>
&lt; value &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a2657a2dd5bc0573de3bca00f1359ae61">make_interval</a> (<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS1, OP1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an interval from a unary expression and a constant at compiletime.  <a href="#a2657a2dd5bc0573de3bca00f1359ae61"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename OP1 , typename TAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt; <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a><br class="typebreak"/>
&lt; LHS1, OP1 &gt;<br class="typebreak"/>
, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a9c8566c7e24e3bb8ab3b69b3e0bf6fb1">make_interval</a> (<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS1, OP1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an interval from a unary expression and a function symbol at compiletime.  <a href="#a9c8566c7e24e3bb8ab3b69b3e0bf6fb1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS1 , typename OP1 , id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt; <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a><br class="typebreak"/>
&lt; LHS1, OP1 &gt;, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#afb7ed761b87ff3dadf12c500465e390b">make_interval</a> (<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS1, OP1 &gt; const &amp;lhs, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an interval from a unary expression and a variable at compiletime.  <a href="#afb7ed761b87ff3dadf12c500465e390b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value1, typename LHS2 , typename OP2 , typename RHS2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a><br class="typebreak"/>
&lt; value1 &gt;, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a><br class="typebreak"/>
&lt; LHS2, OP2, RHS2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ab0f31ba9638abd55997318f91b143c56">make_interval</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS2, OP2, RHS2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an interval from a constant and a binary expression at compiletime.  <a href="#ab0f31ba9638abd55997318f91b143c56"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value1, typename LHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a><br class="typebreak"/>
&lt; value1 &gt;, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a><br class="typebreak"/>
&lt; LHS2, OP2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ab9e633caae5bf50bf3db985328eac803">make_interval</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS2, OP2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an interval from a constant and a unary expression at compiletime.  <a href="#ab9e633caae5bf50bf3db985328eac803"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value1, long value2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a><br class="typebreak"/>
&lt; value1 &gt;, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a><br class="typebreak"/>
&lt; value2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a15f7c1f9a832b3d0deb7992d78cf9233">make_interval</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an interval from two constants at compiletime.  <a href="#a15f7c1f9a832b3d0deb7992d78cf9233"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value1, typename TAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a><br class="typebreak"/>
&lt; value1 &gt;, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a><br class="typebreak"/>
&lt; TAG &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a93da8c5b3917e7d87e95a66fbf4057d4">make_interval</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an interval from a constant and a function symbol at compiletime.  <a href="#a93da8c5b3917e7d87e95a66fbf4057d4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value1, id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a><br class="typebreak"/>
&lt; value1 &gt;, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aa3a28a5f050165138f775e09aeae4a07">make_interval</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value1 &gt; const &amp;lhs, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an interval from a constant and a variable at compiletime.  <a href="#aa3a28a5f050165138f775e09aeae4a07"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TAG , typename LHS2 , typename OP2 , typename RHS2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a><br class="typebreak"/>
&lt; <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt;<br class="typebreak"/>
, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS2, OP2, <br class="typebreak"/>
RHS2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a24c9c83653c0ed54bf2b000d75b62327">make_interval</a> (<a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS2, OP2, RHS2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an interval from a function symbol and a binary expression at compiletime.  <a href="#a24c9c83653c0ed54bf2b000d75b62327"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TAG , typename LHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a><br class="typebreak"/>
&lt; <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt;<br class="typebreak"/>
, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS2, OP2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a6aa35c36866aa94dd2acdff66dd3bcc8">make_interval</a> (<a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS2, OP2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an interval from a function symbol and a unary expression at compiletime.  <a href="#a6aa35c36866aa94dd2acdff66dd3bcc8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TAG , long value&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a><br class="typebreak"/>
&lt; <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt;<br class="typebreak"/>
, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a3ad924db674ed5ce43acacb73b872aa7">make_interval</a> (<a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an interval from a function symbol and a constant at compiletime.  <a href="#a3ad924db674ed5ce43acacb73b872aa7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TAG1 , typename TAG2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a><br class="typebreak"/>
&lt; <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG1 &gt;<br class="typebreak"/>
, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aeca718473db37116c1754f414138d898">make_interval</a> (<a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an interval from two function symbols at compiletime.  <a href="#aeca718473db37116c1754f414138d898"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TAG , id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a><br class="typebreak"/>
&lt; <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt;<br class="typebreak"/>
, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aa5214063f27699f986ea90286e4ad66a">make_interval</a> (<a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt; const &amp;lhs, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an interval from a function symbol and a variable at compiletime.  <a href="#aa5214063f27699f986ea90286e4ad66a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id1, typename LHS2 , typename OP2 , typename RHS2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt; <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id1 &gt;<br class="typebreak"/>
, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS2, OP2, <br class="typebreak"/>
RHS2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a0887f620f606144edc0e696c0754806d">make_interval</a> (<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS2, OP2, RHS2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an interval from a variable and a binary expression at compiletime.  <a href="#a0887f620f606144edc0e696c0754806d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id1, typename LHS2 , typename OP2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt; <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id1 &gt;<br class="typebreak"/>
, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS2, OP2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aaa5b5b3e96adb2435d6fa5c885239366">make_interval</a> (<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS2, OP2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an interval from a variable and a unary expression at compiletime.  <a href="#aaa5b5b3e96adb2435d6fa5c885239366"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id1, long value2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt; <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id1 &gt;<br class="typebreak"/>
, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#abc5ab309374f2294b6b2827a1635b7df">make_interval</a> (<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an interval from a variable and a constant at compiletime.  <a href="#abc5ab309374f2294b6b2827a1635b7df"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id1, typename TAG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt; <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id1 &gt;<br class="typebreak"/>
, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ac4b17fdd9afd30257fd8cbd4cee2d89a">make_interval</a> (<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id1 &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an interval from a variable and a function symbol at compiletime.  <a href="#ac4b17fdd9afd30257fd8cbd4cee2d89a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id1, id_type id2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt; <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id1 &gt;<br class="typebreak"/>
, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id2 &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ade43afd6088321160d1aea7a3d784baa">make_interval</a> (<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id1 &gt; const &amp;lhs, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id2 &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates an interval from two variables at compiletime.  <a href="#ade43afd6088321160d1aea7a3d784baa"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a87236971206e8eef4a0d6506cc8a4050">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS, OP &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience overload for printing a compiletime unary expression to an output stream.  <a href="#a87236971206e8eef4a0d6506cc8a4050"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a3e4801b3e30bf59480a7031dc668b590">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;u)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience overload for printing a variable to an output stream.  <a href="#a3e4801b3e30bf59480a7031dc668b590"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T0 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aa5038fa5139aeecdaeae19bb50817cbc">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="classviennamath_1_1ct__vector__1.html">ct_vector_1</a>&lt; T0 &gt; const &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience functionality for printing a compiletime vector with one entry to an output stream.  <a href="#aa5038fa5139aeecdaeae19bb50817cbc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aa03dffe4e96434bab3268451aa2f9180">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="classviennamath_1_1ct__vector__2.html">ct_vector_2</a>&lt; T0, T1 &gt; const &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience functionality for printing a compiletime vector with two entries to an output stream.  <a href="#aa03dffe4e96434bab3268451aa2f9180"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a9bffff51daca9b5beabf23ea9d28e53d">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="classviennamath_1_1ct__vector__3.html">ct_vector_3</a>&lt; T0, T1, T2 &gt; const &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience functionality for printing a compiletime vector with three entries to an output stream.  <a href="#a9bffff51daca9b5beabf23ea9d28e53d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T0 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__vector__1.html">ct_vector_1</a>&lt; T0 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ae2b922e3910ae182fef18bddb73bd00d">make_vector</a> (T0 const &amp;t0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function for creating a compiletime vector with one element.  <a href="#ae2b922e3910ae182fef18bddb73bd00d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__vector__2.html">ct_vector_2</a>&lt; T0, T1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#af8bf92dc3f6734771ae97d808947451e">make_vector</a> (T0 const &amp;t0, T1 const &amp;t1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function for creating a compiletime vector with two elements.  <a href="#af8bf92dc3f6734771ae97d808947451e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__vector__3.html">ct_vector_3</a>&lt; T0, T1, T2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a02acd683350b951fef8f2c7f98ddddb3">make_vector</a> (T0 const &amp;t0, T1 const &amp;t1, T2 const &amp;t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function for creating a compiletime vector with three elements.  <a href="#a02acd683350b951fef8f2c7f98ddddb3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value, typename ScalarType , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a><br class="typebreak"/>
&lt; typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a><br class="typebreak"/>
&lt; long, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> &gt;<br class="typebreak"/>
, ScalarType &gt;::result_type &gt;<br class="typebreak"/>
, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> &gt;, RHS &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aa1a9be719914d3c45c4ad75494fccbdb">operator+</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; ScalarType &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt; <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> &gt;, RHS &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload: ct_c1 + (c2 + X) -&gt; [ct_c1 + c2] + X, where ct_c1 is a compiletime constant, c2 is a runtime constant, and X is any other expression.  <a href="#aa1a9be719914d3c45c4ad75494fccbdb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value, long value2, typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a><br class="typebreak"/>
&lt; value+value2 &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> &gt;, RHS &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a9e93dd68221d8bb304f8f3014967413b">operator+</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value2 &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt; <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> &gt;, RHS &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload: ct_c1 + (ct_c2 + X) -&gt; [ct_c1 + ct_c2] + X, where ct_c1 and ct_c2 are compiletime constants and X is any other expression.  <a href="#a9e93dd68221d8bb304f8f3014967413b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value, typename ScalarType , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a><br class="typebreak"/>
&lt; typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a><br class="typebreak"/>
&lt; long, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> &gt;<br class="typebreak"/>
, ScalarType &gt;::result_type &gt;<br class="typebreak"/>
, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> &gt;, RHS &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a775b8f96ff955d3c807cd0815cdfa430">operator+</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; ScalarType &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt; <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> &gt;, RHS &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload: ct_c1 + (c2 - X) -&gt; [ct_c1 + c2] - X, where ct_c1 is a compiletime constant, c2 is a runtime constant, and X is any other expression.  <a href="#a775b8f96ff955d3c807cd0815cdfa430"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value, long value2, typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a><br class="typebreak"/>
&lt; value+value2 &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> &gt;, RHS &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#af12a4b1127521b1b28888fcc62f563c4">operator+</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value2 &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt; <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> &gt;, RHS &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload: ct_c1 + (ct_c2 - X) -&gt; [ct_c1 + ct_c2] - X, where ct_c1 and ct_c2 are compiletime constants and X is any other expression.  <a href="#af12a4b1127521b1b28888fcc62f563c4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value, long other_value&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value+other_value &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a7d16242e99d0cdd196f815ab8c14774d">operator+</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; other_value &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload: Condense addition of two compiletime constants into one constant.  <a href="#a7d16242e99d0cdd196f815ab8c14774d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value, typename ScalarType , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a><br class="typebreak"/>
&lt; typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a><br class="typebreak"/>
&lt; long, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> &gt;<br class="typebreak"/>
, ScalarType &gt;::result_type &gt;<br class="typebreak"/>
, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> &gt;, RHS &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aee490081c338660d19d0262a234a433d">operator-</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; ScalarType &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt; <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> &gt;, RHS &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload: ct_c1 - (c2 + X) -&gt; [ct_c1 - c2] - X, where ct_c1 is a compiletime constant, c2 is a runtime constant, and X is any other expression.  <a href="#aee490081c338660d19d0262a234a433d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value, long value2, typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a><br class="typebreak"/>
&lt; value-value2 &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> &gt;, RHS &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a8cc0d2be89063b81b38f671dc6458250">operator-</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value2 &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt; <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> &gt;, RHS &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload: ct_c1 - (ct_c2 + X) -&gt; [ct_c1 - ct_c2] - X, where ct_c1 and ct_c2 are compiletime constants and X is any other expression.  <a href="#a8cc0d2be89063b81b38f671dc6458250"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value, typename ScalarType , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a><br class="typebreak"/>
&lt; typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a><br class="typebreak"/>
&lt; long, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> &gt;<br class="typebreak"/>
, ScalarType &gt;::result_type &gt;<br class="typebreak"/>
, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> &gt;, RHS &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a385f10e49b1375a6085b1c4e8b73cbc7">operator-</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; ScalarType &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt; <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> &gt;, RHS &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload: ct_c1 - (c2 - X) -&gt; [ct_c1 - c2] + X, where ct_c1 is a compiletime constant, c2 is a runtime constant, and X is any other expression.  <a href="#a385f10e49b1375a6085b1c4e8b73cbc7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value, long value2, typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a><br class="typebreak"/>
&lt; value-value2 &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> &gt;, RHS &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ac7c6039c3198189205edf97c72213679">operator-</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value2 &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt; <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> &gt;, RHS &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload: ct_c1 - (ct_c2 - X) -&gt; [ct_c1 - ct_c2] + X, where ct_c1 and ct_c2 are compiletime constants and X is any other expression.  <a href="#ac7c6039c3198189205edf97c72213679"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value, long other_value&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value-other_value &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a9a96021e72d094dd7dc25f90cf26ed1b">operator-</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; other_value &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload: Condense subtraction of two compiletime constants into one constant.  <a href="#a9a96021e72d094dd7dc25f90cf26ed1b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value, long other_value&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value *other_value &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a5c9e697377a7c6ce26c3315c9169ea01">operator*</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; other_value &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload: Condense multiplication of two compiletime constants into one constant.  <a href="#a5c9e697377a7c6ce26c3315c9169ea01"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , long value_1, typename RHS , long value_2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a><br class="typebreak"/>
&lt; value_1+value_2 &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a><br class="typebreak"/>
&lt; ScalarType &gt;, RHS &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a96ec78d34ab84218d7e718c210115796">operator+</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value_1 &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt; ScalarType &gt;, RHS &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value_2 &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload: (ct_c1 + X) + ct_c2 becomes [ct_c1 + ct_c2] + X, where ct_c1 and ct_c2 are compiletime constants and X is any other expression.  <a href="#a96ec78d34ab84218d7e718c210115796"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , long value_1, typename RHS , long value_2&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a><br class="typebreak"/>
&lt; value_1+value_2 &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a><br class="typebreak"/>
&lt; ScalarType &gt;, RHS &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a4fe9e5b9767699300dd46af21db100af">operator+</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value_1 &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt; ScalarType &gt;, RHS &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value_2 &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload: (ct_c1 - X) + ct_c2 becomes [ct_c1 + ct_c2] - X, where ct_c1 and ct_c2 are compiletime constants and X is any other expression.  <a href="#a4fe9e5b9767699300dd46af21db100af"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename OtherScalarType , typename RHS , long value&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a><br class="typebreak"/>
&lt; typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a><br class="typebreak"/>
&lt; OtherScalarType, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a><br class="typebreak"/>
&lt; ScalarType &gt;, long &gt;<br class="typebreak"/>
::result_type &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a><br class="typebreak"/>
&lt; ScalarType &gt;, RHS &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a5133241f93f36e119c3c7f432a0e8be0">operator+</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; OtherScalarType &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt; ScalarType &gt;, RHS &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload: (c1 - X) + ct_c2 -&gt; [c1 + ct_c2] - X, where ct_c1 and ct_c2 are compiletime constants and X is any other expression.  <a href="#a5133241f93f36e119c3c7f432a0e8be0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , id_type id, typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">RHS&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a05d342780bb2a0ee78f53ae4a53e3995">operator-</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt; ScalarType &gt;, RHS &gt; const &amp;lhs, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload: (A + B) - A -&gt; B, where A is an variable and X can be anything.  <a href="#a05d342780bb2a0ee78f53ae4a53e3995"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value_1, typename RHS , long value_2, typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a><br class="typebreak"/>
&lt; value_1-value_2 &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a><br class="typebreak"/>
&lt; T &gt;, RHS &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ac765c3d235c5bc88544b3b3931ed8ef8">operator-</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value_1 &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt; T &gt;, RHS &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value_2 &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload: (ct_c1 + X) - ct_c2 -&gt; [ct_c1 - ct_c2] + X, where ct_c1 and ct_c2 are compiletime constants and X is any other expression.  <a href="#ac765c3d235c5bc88544b3b3931ed8ef8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename OtherScalarType , typename RHS , long value, typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a><br class="typebreak"/>
&lt; typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a><br class="typebreak"/>
&lt; OtherScalarType, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt; T &gt;<br class="typebreak"/>
, long &gt;::result_type &gt;<br class="typebreak"/>
, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt; T &gt;, RHS &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a3ab61f0e93572689c8fb25c084175fda">operator-</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; OtherScalarType &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt; T &gt;, RHS &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload: (c1 + X) - ct_c2 -&gt; [c1 - ct_c2] + X, where ct_c1 and ct_c2 are compiletime constants and X is any other expression.  <a href="#a3ab61f0e93572689c8fb25c084175fda"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value_1, typename RHS , long value_2, typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a><br class="typebreak"/>
&lt; value_1-value_2 &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a><br class="typebreak"/>
&lt; T &gt;, RHS &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a79934ad09196a21b4185519cca650fe3">operator-</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value_1 &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt; T &gt;, RHS &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value_2 &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload: (ct_c1 - X) - ct_c2 -&gt; [ct_c1 - ct_c2] - X, where ct_c1 and ct_c2 are compiletime constants and X is any other expression.  <a href="#a79934ad09196a21b4185519cca650fe3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename OtherScalarType , typename RHS , long value, typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a><br class="typebreak"/>
&lt; typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a><br class="typebreak"/>
&lt; OtherScalarType, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt; T &gt;<br class="typebreak"/>
, long &gt;::result_type &gt;<br class="typebreak"/>
, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt; T &gt;, RHS &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ae3af7f10cb1c8816c1f6912e55a9eed0">operator-</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; OtherScalarType &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt; T &gt;, RHS &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload: (c1 - X) - ct_c2 -&gt; [c1 - ct_c2] - X, where ct_c1 and ct_c2 are compiletime constants and X is any other expression.  <a href="#ae3af7f10cb1c8816c1f6912e55a9eed0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; 1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ab387a8c9fc10cb75a804df8b1640440a">operator/</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS, OP, RHS &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS, OP, RHS &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload: division of the same thing leads to '1'.  <a href="#ab387a8c9fc10cb75a804df8b1640440a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a><br class="typebreak"/>
&lt; 2 &gt;, <a class="el" href="structviennamath_1_1op__mult.html">op_mult</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> &gt;<br class="typebreak"/>
, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#afc8b0467c2889c5a24ec9a3a053e0951">operator+</a> (<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;lhs, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload: x + x becomes 2*x.  <a href="#afc8b0467c2889c5a24ec9a3a053e0951"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; 0 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ae13e94bfe9efecfa85d1c7c7cdc92fbe">operator-</a> (<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;lhs, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload: x - x becomes 0.  <a href="#ae13e94bfe9efecfa85d1c7c7cdc92fbe"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; 1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a59f2a2bb6054ab3ead3aaa6c4ca0dcd4">operator/</a> (<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;lhs, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload: x / x becomes 1.  <a href="#a59f2a2bb6054ab3ead3aaa6c4ca0dcd4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a53b7241560fc9d3020efcbe0a70a16f6">unary_op_equal</a> (<a class="el" href="classviennamath_1_1op__partial__deriv.html">op_partial_deriv</a>&lt; T &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1op__partial__deriv.html">op_partial_deriv</a>&lt; T &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares two partial derivatives for equality with respect to the differentiation variable.  <a href="#a53b7241560fc9d3020efcbe0a70a16f6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennamath_1_1enable__if.html">enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennamath_1_1result__of_1_1is__viennamath.html">result_of::is_viennamath</a><br class="typebreak"/>
&lt; LHS &gt;::value||<a class="el" href="structviennamath_1_1result__of_1_1is__viennamath.html">result_of::is_viennamath</a><br class="typebreak"/>
&lt; RHS &gt;::value, typename <br class="typebreak"/>
<a class="el" href="structviennamath_1_1result__of_1_1add.html">result_of::add</a>&lt; LHS, RHS &gt;<br class="typebreak"/>
::type &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aaf03494c176b69f6988225edfc9e74be">operator+</a> (LHS const &amp;lhs, RHS const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic overload of the addition operator for ViennaMath types. Uses SFINAE to control the scope, otherwise one may run into very tricky problems with operator+ being considered outside the viennamath namespace.  <a href="#aaf03494c176b69f6988225edfc9e74be"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennamath_1_1enable__if.html">enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennamath_1_1result__of_1_1is__viennamath.html">result_of::is_viennamath</a><br class="typebreak"/>
&lt; LHS &gt;::value||<a class="el" href="structviennamath_1_1result__of_1_1is__viennamath.html">result_of::is_viennamath</a><br class="typebreak"/>
&lt; RHS &gt;::value, typename <br class="typebreak"/>
<a class="el" href="structviennamath_1_1result__of_1_1subtract.html">result_of::subtract</a>&lt; LHS, RHS &gt;<br class="typebreak"/>
::type &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#abc5bac5399fd74594c55f8a65d89b8c4">operator-</a> (LHS const &amp;lhs, RHS const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic overload of the subtraction operator for ViennaMath types. Uses SFINAE to control the scope, otherwise one may run into very tricky problems with operator- being considered outside the viennamath namespace.  <a href="#abc5bac5399fd74594c55f8a65d89b8c4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennamath_1_1enable__if.html">enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennamath_1_1result__of_1_1is__viennamath.html">result_of::is_viennamath</a><br class="typebreak"/>
&lt; LHS &gt;::value||<a class="el" href="structviennamath_1_1result__of_1_1is__viennamath.html">result_of::is_viennamath</a><br class="typebreak"/>
&lt; RHS &gt;::value, typename <br class="typebreak"/>
<a class="el" href="structviennamath_1_1result__of_1_1mult.html">result_of::mult</a>&lt; LHS, RHS &gt;<br class="typebreak"/>
::type &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a456766f51c85687bb300c754e5db6d67">operator*</a> (LHS const &amp;lhs, RHS const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic overload of the multiplication operator for ViennaMath types. Uses SFINAE to control the scope, otherwise one may run into very tricky problems with operator* being considered outside the viennamath namespace.  <a href="#a456766f51c85687bb300c754e5db6d67"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennamath_1_1enable__if.html">enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennamath_1_1result__of_1_1is__viennamath.html">result_of::is_viennamath</a><br class="typebreak"/>
&lt; LHS &gt;::value||<a class="el" href="structviennamath_1_1result__of_1_1is__viennamath.html">result_of::is_viennamath</a><br class="typebreak"/>
&lt; RHS &gt;::value, typename <br class="typebreak"/>
<a class="el" href="structviennamath_1_1result__of_1_1div.html">result_of::div</a>&lt; LHS, RHS &gt;<br class="typebreak"/>
::type &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aa3ab0fb522083f3a037467af4b19ef6f">operator/</a> (LHS const &amp;lhs, RHS const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic overload of the division operator for ViennaMath types. Uses SFINAE to control the scope, otherwise one may run into very tricky problems with operator/ being considered outside the viennamath namespace.  <a href="#aa3ab0fb522083f3a037467af4b19ef6f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ac92bb7219a73e9249de48ce223188f64">apply_coordinate_system</a> (<a class="el" href="structviennamath_1_1cartesian.html">cartesian</a>&lt; 1 &gt;, <a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;ex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transforms the expression to a Cartesian coordinate system in one dimension.  <a href="#ac92bb7219a73e9249de48ce223188f64"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a3f6f67ccee010451bf05ccf324cd3703">apply_coordinate_system</a> (<a class="el" href="structviennamath_1_1cartesian.html">cartesian</a>&lt; 1 &gt;, <a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt; const &amp;ex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transforms the expression to a Cartesian coordinate system in one dimension.  <a href="#a3f6f67ccee010451bf05ccf324cd3703"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a902afcecfaad71142eea4fbed682a7b5">apply_coordinate_system</a> (<a class="el" href="structviennamath_1_1cartesian.html">cartesian</a>&lt; 1 &gt;, <a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt; InterfaceType &gt; const &amp;ex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transforms the expression to a Cartesian coordinate system in one dimension.  <a href="#a902afcecfaad71142eea4fbed682a7b5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a8c6f262a6341815bf3e351a66f75e673">apply_coordinate_system</a> (<a class="el" href="structviennamath_1_1cartesian.html">cartesian</a>&lt; 2 &gt;, <a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;ex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transforms the expression to a Cartesian coordinate system in two dimensions.  <a href="#a8c6f262a6341815bf3e351a66f75e673"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a9404f9d8a924aca257b04610322f75ca">apply_coordinate_system</a> (<a class="el" href="structviennamath_1_1cartesian.html">cartesian</a>&lt; 2 &gt;, <a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt; const &amp;ex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transforms the expression to a Cartesian coordinate system in two dimensions.  <a href="#a9404f9d8a924aca257b04610322f75ca"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a35f31f13ad8fdffe7e8794b9f6dc4a08">apply_coordinate_system</a> (<a class="el" href="structviennamath_1_1cartesian.html">cartesian</a>&lt; 2 &gt;, <a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt; InterfaceType &gt; const &amp;ex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transforms the expression to a Cartesian coordinate system in two dimensions.  <a href="#a35f31f13ad8fdffe7e8794b9f6dc4a08"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a0d844bc96490b7de1badeb12f8d1fa8b">apply_coordinate_system</a> (<a class="el" href="structviennamath_1_1cartesian.html">cartesian</a>&lt; 3 &gt;, <a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;ex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transforms the expression to a Cartesian coordinate system in two dimensions.  <a href="#a0d844bc96490b7de1badeb12f8d1fa8b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#addb1d3f9467893cbfa12b5ee8f15bdf4">apply_coordinate_system</a> (<a class="el" href="structviennamath_1_1cartesian.html">cartesian</a>&lt; 3 &gt;, <a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt; const &amp;ex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transforms the expression to a Cartesian coordinate system in three dimensions.  <a href="#addb1d3f9467893cbfa12b5ee8f15bdf4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ad7d9bad718c2e2c91e2df780b275709b">apply_coordinate_system</a> (<a class="el" href="structviennamath_1_1cartesian.html">cartesian</a>&lt; 3 &gt;, <a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt; InterfaceType &gt; const &amp;ex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transforms the expression to a Cartesian coordinate system in three dimensions.  <a href="#ad7d9bad718c2e2c91e2df780b275709b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , id_type dim&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a90a0140ca5c7c0956bc4cf2e05aeaed1">apply_coordinate_system</a> (<a class="el" href="structviennamath_1_1cartesian.html">cartesian</a>&lt; dim &gt;, <a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&lt; InterfaceType &gt; const &amp;equ)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience overload which automatically applies the coordinate transformation to the right hand left hand side of an equation.  <a href="#a90a0140ca5c7c0956bc4cf2e05aeaed1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename FactorType , typename ExpressionType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennamath_1_1result__of_1_1coefficient.html">viennamath::result_of::coefficient</a><br class="typebreak"/>
&lt; FactorType, ExpressionType &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ae70ee72fa691c4309562685abdc08c9d">coefficient</a> (FactorType const &amp;f, ExpressionType const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User function for extracting the coefficient of a variable or sub-expression from an expression.  <a href="#ae70ee72fa691c4309562685abdc08c9d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ab2aded2fd0a5e180147b4e571389ae0a">diff_impl</a> (const InterfaceType *lhs, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt; NumericT &gt;, const InterfaceType *rhs, const InterfaceType *diff_var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the differentation of e1 + e1, where e1 and e2 are expressions.  <a href="#ab2aded2fd0a5e180147b4e571389ae0a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a43db4c7b01bb93d7ef27715437d47ee2">simplify_impl</a> (const InterfaceType *lhs, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt; NumericT &gt;, const InterfaceType *rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the simplification procedures for an expression of the form e1 + e2.  <a href="#a43db4c7b01bb93d7ef27715437d47ee2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aa897431732086eff2b487d13b163ba1d">can_simplify_impl</a> (const InterfaceType *lhs, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt; NumericT &gt;, const InterfaceType *rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether an expression of the form e1 + e2 can be simplified.  <a href="#aa897431732086eff2b487d13b163ba1d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a61e5fca5087550574135b593cfdfce59">diff_impl</a> (const InterfaceType *lhs, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt; NumericT &gt;, const InterfaceType *rhs, const InterfaceType *diff_var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the differentation of e1 - e1, where e1 and e2 are expressions.  <a href="#a61e5fca5087550574135b593cfdfce59"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#afc140581a47526c8806588e89ba9170c">simplify_impl</a> (const InterfaceType *lhs, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt; NumericT &gt;, const InterfaceType *rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the simplification procedures for an expression of the form e1 - e2.  <a href="#afc140581a47526c8806588e89ba9170c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ae55ecd908151aa5bd5370d852e096738">can_simplify_impl</a> (const InterfaceType *lhs, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt; NumericT &gt;, const InterfaceType *rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether an expression of the form e1 - e2 can be simplified.  <a href="#ae55ecd908151aa5bd5370d852e096738"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a72280e28b99d3acf307d9cd2d07ffa36">diff_impl</a> (const InterfaceType *lhs, <a class="el" href="structviennamath_1_1op__mult.html">op_mult</a>&lt; NumericT &gt;, const InterfaceType *rhs, const InterfaceType *diff_var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the differentation of e1 * e1, where e1 and e2 are expressions.  <a href="#a72280e28b99d3acf307d9cd2d07ffa36"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a0242029fb878937caab203ca397848c2">simplify_impl</a> (const InterfaceType *lhs, <a class="el" href="structviennamath_1_1op__mult.html">op_mult</a>&lt; NumericT &gt;, const InterfaceType *rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the simplification procedures for an expression of the form e1 * e2.  <a href="#a0242029fb878937caab203ca397848c2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a07f64745b64d72de0b8b2851f1f10fb1">can_simplify_impl</a> (const InterfaceType *lhs, <a class="el" href="structviennamath_1_1op__mult.html">op_mult</a>&lt; NumericT &gt;, const InterfaceType *rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether an expression of the form e1 * e2 can be simplified.  <a href="#a07f64745b64d72de0b8b2851f1f10fb1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a145f22648aab309a9196fc2f5401a0c6">diff_impl</a> (const InterfaceType *lhs, <a class="el" href="structviennamath_1_1op__div.html">op_div</a>&lt; NumericT &gt;, const InterfaceType *rhs, const InterfaceType *diff_var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the differentation of e1 / e1, where e1 and e2 are expressions.  <a href="#a145f22648aab309a9196fc2f5401a0c6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a1c8fb4e0cbecf7705f1a79e21b083962">simplify_impl</a> (const InterfaceType *lhs, <a class="el" href="structviennamath_1_1op__div.html">op_div</a>&lt; NumericT &gt;, const InterfaceType *rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the simplification procedures for an expression of the form e1 / e2.  <a href="#a1c8fb4e0cbecf7705f1a79e21b083962"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a0b6c204941b90a57ce27da642b68d531">can_simplify_impl</a> (const InterfaceType *lhs, <a class="el" href="structviennamath_1_1op__div.html">op_div</a>&lt; NumericT &gt;, const InterfaceType *rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether an expression of the form e1 / e2 can be simplified.  <a href="#a0b6c204941b90a57ce27da642b68d531"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#af046a1c2c0925c4abcebff160ccd9b74">diff_impl</a> (const InterfaceType *e, <a class="el" href="structviennamath_1_1op__id.html">op_id</a>&lt; NumericT &gt;, const InterfaceType *diff_var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Differentation of a unary expression containing identity.  <a href="#af046a1c2c0925c4abcebff160ccd9b74"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ac28c355c4b8937f04d3029c0072c6aa5">diff_impl</a> (const InterfaceType *e, <a class="el" href="structviennamath_1_1op__exp.html">op_exp</a>&lt; NumericT &gt;, const InterfaceType *diff_var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Differentation of exp(e), where e is an expression.  <a href="#ac28c355c4b8937f04d3029c0072c6aa5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aebc9979a5a89c77c58d3648a2dbb218e">exp</a> (<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; NumericT, InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the exponential function for a ViennaMath runtime constant.  <a href="#aebc9979a5a89c77c58d3648a2dbb218e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a987cd95708aed4f6ac167110874d4a2c">exp</a> (<a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the exponential function for a ViennaMath runtime variable.  <a href="#a987cd95708aed4f6ac167110874d4a2c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ad90b3035ce745a93c453bbb7d96ae46b">exp</a> (<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the exponential function for a ViennaMath compiletime variable.  <a href="#ad90b3035ce745a93c453bbb7d96ae46b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a61b858b450e456302f721b4ff282d9e3">exp</a> (<a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the exponential function for a ViennaMath runtime binary expression.  <a href="#a61b858b450e456302f721b4ff282d9e3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ab026d3b9ba9bcd69872a1344b1deb337">exp</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS, OP, RHS &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the exponential function for a ViennaMath compiletime binary expression.  <a href="#ab026d3b9ba9bcd69872a1344b1deb337"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a2c32cb661a87fef8e39deeb0e925bc0b">exp</a> (<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS, OP &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the exponential function for a ViennaMath compiletime unary expression.  <a href="#a2c32cb661a87fef8e39deeb0e925bc0b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a1a9b4ef02365b4587acb152fd08d6da6">exp</a> (<a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the exponential function for a ViennaMath runtime expression wrapper.  <a href="#a1a9b4ef02365b4587acb152fd08d6da6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ad5d7fe3c536f80a4afe29d2a5a136e97">diff_impl</a> (const InterfaceType *e, <a class="el" href="structviennamath_1_1op__sin.html">op_sin</a>&lt; NumericT &gt;, const InterfaceType *diff_var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Differentation of sin(e), where e is an expression.  <a href="#ad5d7fe3c536f80a4afe29d2a5a136e97"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#adb139682031d58c74f3251482c912a65">sin</a> (<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; NumericT, InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the sine function for a ViennaMath runtime constant.  <a href="#adb139682031d58c74f3251482c912a65"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a0e90789fe641f5b4a081e56b08fc9291">sin</a> (<a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the sine function for a ViennaMath runtime variable.  <a href="#a0e90789fe641f5b4a081e56b08fc9291"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ae4fd81949da2c40ee2d5a0078460e177">sin</a> (<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the sine function for a ViennaMath compiletime variable.  <a href="#ae4fd81949da2c40ee2d5a0078460e177"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a063eb151d24c03cf9179918b5c312af4">sin</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS, OP, RHS &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the sine function for a ViennaMath compiletime binary expression.  <a href="#a063eb151d24c03cf9179918b5c312af4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a6e7edbb3417d17155fe81a296aac16ee">sin</a> (<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS, OP &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the sine function for a ViennaMath compiletime unary expression.  <a href="#a6e7edbb3417d17155fe81a296aac16ee"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ad9542d9a32538308ca47867384f0001e">sin</a> (<a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the sine function for a ViennaMath runtime unary expression.  <a href="#ad9542d9a32538308ca47867384f0001e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a01828a35cd515c72e5631c690cc9d661">sin</a> (<a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the sine function for a ViennaMath runtime binary expression.  <a href="#a01828a35cd515c72e5631c690cc9d661"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a87a291b8cd5e8810deb3aa173a6e31c7">sin</a> (<a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the sine function for a ViennaMath runtime expression wrapper.  <a href="#a87a291b8cd5e8810deb3aa173a6e31c7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a0d86fa7b07f826fd1da058c99bbe5c8b">diff_impl</a> (const InterfaceType *e, <a class="el" href="structviennamath_1_1op__cos.html">op_cos</a>&lt; NumericT &gt;, const InterfaceType *diff_var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Differentation of cos(e), where e is an expression.  <a href="#a0d86fa7b07f826fd1da058c99bbe5c8b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ab34c1026105a04eef6e8433cc228893c">cos</a> (<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; NumericT, InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the cosine function for a ViennaMath runtime constant.  <a href="#ab34c1026105a04eef6e8433cc228893c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a5f9160049c00d26edcbf7223c9a9cc92">cos</a> (<a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the cosine function for a ViennaMath runtime variable.  <a href="#a5f9160049c00d26edcbf7223c9a9cc92"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a0252e9b79684a885babceb416c0f7eeb">cos</a> (<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the cosine function for a ViennaMath compiletime variable.  <a href="#a0252e9b79684a885babceb416c0f7eeb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#abd11bddf2d5ea29cd6dc432ae84f0691">cos</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS, OP, RHS &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the cosine function for a ViennaMath compiletime binary expression.  <a href="#abd11bddf2d5ea29cd6dc432ae84f0691"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a241e81bac772871f95061481fe5a912c">cos</a> (<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS, OP &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the cosine function for a ViennaMath compiletime unary expression.  <a href="#a241e81bac772871f95061481fe5a912c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#abfdb31cae3e8b1958e19aff8d8caf240">cos</a> (<a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the cosine function for a ViennaMath runtime unary expression.  <a href="#abfdb31cae3e8b1958e19aff8d8caf240"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a6760f76e92b43f668ca0aadfa6f0bde0">cos</a> (<a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the cosine function for a ViennaMath runtime binary expression.  <a href="#a6760f76e92b43f668ca0aadfa6f0bde0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a20397bef45df45443e7fd1e9627ad12e">cos</a> (<a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the cosine function for a ViennaMath runtime expression wrapper.  <a href="#a20397bef45df45443e7fd1e9627ad12e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a2765cdcc5145a1080b085750334a9064">diff_impl</a> (const InterfaceType *e, <a class="el" href="structviennamath_1_1op__tan.html">op_tan</a>&lt; NumericT &gt;, const InterfaceType *diff_var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Differentation of tan(e), where e is an expression.  <a href="#a2765cdcc5145a1080b085750334a9064"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a6466850318e6dcc1a0997af207ccde57">tan</a> (<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; NumericT, InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the tangent function for a ViennaMath runtime constant.  <a href="#a6466850318e6dcc1a0997af207ccde57"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a8b481f3d63879c2978f03653e6153d37">tan</a> (<a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the tangent function for a ViennaMath runtime variable.  <a href="#a8b481f3d63879c2978f03653e6153d37"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ac8bd49e99dc88986d1fc3273c0e36fc2">tan</a> (<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the tangent function for a ViennaMath compiletime variable.  <a href="#ac8bd49e99dc88986d1fc3273c0e36fc2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a6dad9a86aa4baf42aa2458dc87643c61">tan</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS, OP, RHS &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the tangent function for a ViennaMath compiletime binary expression.  <a href="#a6dad9a86aa4baf42aa2458dc87643c61"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a12c45b179f539b54bf24141d4c10ad37">tan</a> (<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS, OP &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the tangent function for a ViennaMath compiletime unary expression.  <a href="#a12c45b179f539b54bf24141d4c10ad37"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ad62dadb75a7676cdb66e793783e27da5">tan</a> (<a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the tangent function for a ViennaMath runtime unary expression.  <a href="#ad62dadb75a7676cdb66e793783e27da5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ad8126ebb56c187caf6a1ba56914a70e8">tan</a> (<a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the tangent function for a ViennaMath runtime binary expression.  <a href="#ad8126ebb56c187caf6a1ba56914a70e8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a71505792183df693d76ff36342e9ac09">tan</a> (<a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the tangent function for a ViennaMath runtime expression wrapper.  <a href="#a71505792183df693d76ff36342e9ac09"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a43f146b14bccaeeb99e20f5c0c3fe2cc">diff_impl</a> (const InterfaceType *e, <a class="el" href="structviennamath_1_1op__fabs.html">op_fabs</a>&lt; NumericT &gt;, const InterfaceType *diff_var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the differentation of |e|, where e is an expression. Since the modulus is not differentiable everywhere, an exception is thrown.  <a href="#a43f146b14bccaeeb99e20f5c0c3fe2cc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aa3594f0a2c482ac86fd8ec8873d3c3e7">fabs</a> (<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; NumericT, InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the modulus function for a ViennaMath runtime constant.  <a href="#aa3594f0a2c482ac86fd8ec8873d3c3e7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a2ede41bcefb44408201a88dbcbe0cfb2">fabs</a> (<a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the modulus function for a ViennaMath runtime variable.  <a href="#a2ede41bcefb44408201a88dbcbe0cfb2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a6f44a9f96dd780601ea180516815f502">fabs</a> (<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the modulus function for a ViennaMath compiletime variable.  <a href="#a6f44a9f96dd780601ea180516815f502"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ae076c0df57cbd72ce3bdfee7e6a7d213">fabs</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS, OP, RHS &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the modulus function for a ViennaMath compiletime binary expression.  <a href="#ae076c0df57cbd72ce3bdfee7e6a7d213"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a7a237c3e4d8c86f74dedff3d35f20f4a">fabs</a> (<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS, OP &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the modulus function for a ViennaMath compiletime unary expression.  <a href="#a7a237c3e4d8c86f74dedff3d35f20f4a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a6a178d09db8cca450fb30c34e72d94e8">fabs</a> (<a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the modulus function for a ViennaMath runtime unary expression.  <a href="#a6a178d09db8cca450fb30c34e72d94e8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#afea99b6d77391cfb133b5453af718527">fabs</a> (<a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the modulus function for a ViennaMath runtime binary expression.  <a href="#afea99b6d77391cfb133b5453af718527"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a9b4616e8a2666125465ce772af757368">fabs</a> (<a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the modulus function for a ViennaMath runtime expression wrapper.  <a href="#a9b4616e8a2666125465ce772af757368"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a7c1ea7f64c46f85bdee5a5eea2fd79a4">diff_impl</a> (const InterfaceType *e, <a class="el" href="structviennamath_1_1op__sqrt.html">op_sqrt</a>&lt; NumericT &gt;, const InterfaceType *diff_var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the differentation of \sqrt{e}, where e is an expression.  <a href="#a7c1ea7f64c46f85bdee5a5eea2fd79a4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#abfaab8e3dea4888fe01c6bd8e125431a">sqrt</a> (<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; NumericT, InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the square-root function for a ViennaMath runtime constant.  <a href="#abfaab8e3dea4888fe01c6bd8e125431a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a169cd852af6f99d1fafc6a02f872a69e">sqrt</a> (<a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the square-root function for a ViennaMath runtime variable.  <a href="#a169cd852af6f99d1fafc6a02f872a69e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a7a77c13989060743c6446ce7253d08f7">sqrt</a> (<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the square-root function for a ViennaMath compiletime variable.  <a href="#a7a77c13989060743c6446ce7253d08f7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a36e1fb9ed0568a4913278d3456a28a37">sqrt</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS, OP, RHS &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the square-root function for a ViennaMath compiletime binary expression.  <a href="#a36e1fb9ed0568a4913278d3456a28a37"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a465666c605b600b20acc607b4754abf8">sqrt</a> (<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS, OP &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the square-root function for a ViennaMath compiletime unary expression.  <a href="#a465666c605b600b20acc607b4754abf8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a133ebc258c5eb5062eed77b6b872e784">sqrt</a> (<a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the square-root function for a ViennaMath runtime unary expression.  <a href="#a133ebc258c5eb5062eed77b6b872e784"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a30f229ea98616d7ef9f0497564119b84">sqrt</a> (<a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the square-root function for a ViennaMath runtime binary expression.  <a href="#a30f229ea98616d7ef9f0497564119b84"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a5ae7b8f5fb1d62a122860950bd34838e">sqrt</a> (<a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the square-root function for a ViennaMath runtime expression wrapper.  <a href="#a5ae7b8f5fb1d62a122860950bd34838e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a08dbc843d6877c0821b8cce7d30c8ffe">diff_impl</a> (const InterfaceType *e, <a class="el" href="structviennamath_1_1op__log.html">op_log</a>&lt; NumericT &gt;, const InterfaceType *diff_var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the differentation of ln(e), where e is an expression.  <a href="#a08dbc843d6877c0821b8cce7d30c8ffe"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aeb237d8f5686e7cddc50e8b2dc5a703e">log</a> (<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; NumericT, InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the natural logarithm function for a ViennaMath runtime constant.  <a href="#aeb237d8f5686e7cddc50e8b2dc5a703e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a0ecd5f1586131782887cb1347a728eb0">log</a> (<a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the natural logarithm function for a ViennaMath runtime variable.  <a href="#a0ecd5f1586131782887cb1347a728eb0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a3e37b0e91fcd0ea5b307e4288a247aa4">log</a> (<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the natural logarithm function for a ViennaMath compiletime variable.  <a href="#a3e37b0e91fcd0ea5b307e4288a247aa4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ad0422a93d2137caa7872f0be7a5a897c">log</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS, OP, RHS &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the natural logarithm function for a ViennaMath compiletime binary expression.  <a href="#ad0422a93d2137caa7872f0be7a5a897c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a6e05131933e69d2974eb42c47908623d">log</a> (<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS, OP &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the natural logarithm function for a ViennaMath compiletime unary expression.  <a href="#a6e05131933e69d2974eb42c47908623d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a93c8877c03a3a06b30c9204dd0d13e8e">log</a> (<a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the natural logarithm function for a ViennaMath runtime unary expression.  <a href="#a93c8877c03a3a06b30c9204dd0d13e8e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a63888ee558eaa93fd56a110b907f5669">log</a> (<a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the natural logarithm function for a ViennaMath runtime binary expression.  <a href="#a63888ee558eaa93fd56a110b907f5669"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a34927e53ac2ea16e6a43d6e2fa71c808">log</a> (<a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the natural logarithm function for a ViennaMath runtime expression wrapper.  <a href="#a34927e53ac2ea16e6a43d6e2fa71c808"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#adb58aa5f11273da6486e4581959ea13a">diff_impl</a> (const InterfaceType *e, <a class="el" href="structviennamath_1_1op__log10.html">op_log10</a>&lt; NumericT &gt;, const InterfaceType *diff_var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the differentation of log10(e), where e is an expression.  <a href="#adb58aa5f11273da6486e4581959ea13a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ae4f69733aee4b9fc4265d02db6b5b7d1">log10</a> (<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; NumericT, InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the logarithm with base 10 for a ViennaMath runtime constant.  <a href="#ae4f69733aee4b9fc4265d02db6b5b7d1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a7e22a44799aa61baa2fa262f1a0045b8">log10</a> (<a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the logarithm with base 10 for a ViennaMath runtime variable.  <a href="#a7e22a44799aa61baa2fa262f1a0045b8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a587bd0314a06e67fec06cc8330458c5f">log10</a> (<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the logarithm with base 10 for a ViennaMath compiletime variable.  <a href="#a587bd0314a06e67fec06cc8330458c5f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a5e79b5affd916aef44eb91595e9fe023">log10</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS, OP, RHS &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the logarithm with base 10 for a ViennaMath compiletime binary expression.  <a href="#a5e79b5affd916aef44eb91595e9fe023"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a555f9270711b945f99226b3b7da95841">log10</a> (<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS, OP &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the logarithm with base 10 for a ViennaMath compiletime unary expression.  <a href="#a555f9270711b945f99226b3b7da95841"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a214c73b75ed19e2123fb6d5f48ffa31a">log10</a> (<a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the logarithm with base 10 for a ViennaMath runtime unary expression.  <a href="#a214c73b75ed19e2123fb6d5f48ffa31a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#abba554e4ced71245733157ae0aa09a53">log10</a> (<a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the logarithm with base 10 for a ViennaMath runtime binary expression.  <a href="#abba554e4ced71245733157ae0aa09a53"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ab0ec9dd80d7522b20ade837e4b181e20">log10</a> (<a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the logarithm with base 10 for a ViennaMath runtime expression wrapper.  <a href="#ab0ec9dd80d7522b20ade837e4b181e20"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a1f335a870411768416d7711e16b11c30">diff_impl</a> (const InterfaceType *e, <a class="el" href="structviennamath_1_1op__gradient.html">op_gradient</a>&lt; NumericT &gt;, const InterfaceType *diff_var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the differentation of a gradient. This is currently not supported, thus an exception is thrown.  <a href="#a1f335a870411768416d7711e16b11c30"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a77e82fadba1cd6372147e8ae28082908">grad</a> (<a class="el" href="classviennamath_1_1rt__function__symbol.html">rt_function_symbol</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the gradient function for a ViennaMath runtime function symbol.  <a href="#a77e82fadba1cd6372147e8ae28082908"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aa7a9cb779ba7c6e763d1a94cb3d04111">grad</a> (<a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the gradient function for a ViennaMath runtime unary expression.  <a href="#aa7a9cb779ba7c6e763d1a94cb3d04111"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aad557e872cac4a1385b7e6317f2bbc02">diff_impl</a> (const InterfaceType *e, <a class="el" href="structviennamath_1_1op__divergence.html">op_divergence</a>&lt; NumericT &gt;, const InterfaceType *diff_var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the differentation of the divergence operator. This is currently not supported, thus an exception is thrown.  <a href="#aad557e872cac4a1385b7e6317f2bbc02"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a7aae8ad176b5963f7f09ca1316ee93e5">div</a> (<a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the divergence function for a ViennaMath runtime expression wrapper.  <a href="#a7aae8ad176b5963f7f09ca1316ee93e5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a77d3b61ee7c51c9915eb9725acb977e5">div</a> (<a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the divergence function for a ViennaMath runtime unary expression.  <a href="#a77d3b61ee7c51c9915eb9725acb977e5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a3a7ffb1808fe0426557b7e89b8e2affc">div</a> (<a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the divergence function for a ViennaMath runtime binary expression.  <a href="#a3a7ffb1808fe0426557b7e89b8e2affc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aa2c45c85d6f6c3b49926444879bb2655">div</a> (<a class="el" href="classviennamath_1_1rt__function__symbol.html">rt_function_symbol</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the divergence function for a ViennaMath runtime function symbol.  <a href="#aa2c45c85d6f6c3b49926444879bb2655"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a0c217094f61fa562b2f38d8d31bd236b">laplace</a> (<a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For convenience, the Laplace operator (divergence of the gradient) is provided as a separate function.  <a href="#a0c217094f61fa562b2f38d8d31bd236b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ad2b1b2c5a42ce2ff90216898f1c09697">laplace</a> (<a class="el" href="classviennamath_1_1rt__function__symbol.html">rt_function_symbol</a>&lt; InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For convenience, the Laplace operator (divergence of the gradient) is provided as a separate function.  <a href="#ad2b1b2c5a42ce2ff90216898f1c09697"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename NumericT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aa51eddfe0bc23018878703f5e5d0f622">diff_impl</a> (const InterfaceType *e, <a class="el" href="classviennamath_1_1op__partial__deriv.html">op_partial_deriv</a>&lt; NumericT &gt;, const InterfaceType *diff_var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the differentation of a partial derivative. This is currently not supported, thus an exception is thrown.  <a href="#aa51eddfe0bc23018878703f5e5d0f622"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a89e5e3980bfaf17936d92ada9594d611">diff_impl</a> (const InterfaceType *e, <a class="el" href="classviennamath_1_1op__rt__integral.html">op_rt_integral</a>&lt; InterfaceType &gt;, const InterfaceType *diff_var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the differentation of an integral. This is currently not supported, thus an exception is thrown.  <a href="#a89e5e3980bfaf17936d92ada9594d611"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InterfaceType *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a664a62b90f283761c819f8cccc56c5ae">diff_impl</a> (const InterfaceType *e, <a class="el" href="classviennamath_1_1op__rt__symbolic__integral.html">op_rt_symbolic_integral</a>&lt; InterfaceType &gt;, const InterfaceType *diff_var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the differentation of an integral with symbolic integration domain. This is currently not supported, thus an exception is thrown.  <a href="#a664a62b90f283761c819f8cccc56c5ae"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a64939d85ad712c555e36b4ad7b2bbe1a">diff</a> (<a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt; InterfaceType &gt; const &amp;e, <a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; const &amp;var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the derivative of the provided runtime binary expression.  <a href="#a64939d85ad712c555e36b4ad7b2bbe1a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a31ee8f1d64581ca114dc0fe3d2802a53">diff</a> (<a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt; const &amp;e, <a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; const &amp;var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the derivative of the provided runtime unary expression.  <a href="#a31ee8f1d64581ca114dc0fe3d2802a53"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a6bacb9c25981a59bde285ae251411679">diff</a> (<a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;e, <a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; const &amp;var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the derivative of the provided runtime expression wrapper.  <a href="#a6bacb9c25981a59bde285ae251411679"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ac419e6ca9f4617f8a067b76425b50842">diff</a> (<a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt; InterfaceType &gt; const &amp;e, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the derivative of the provided runtime binary expression.  <a href="#ac419e6ca9f4617f8a067b76425b50842"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a9c0967e60ffcbc81c111f9915cd1c2e2">diff</a> (<a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt; const &amp;e, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the derivative of the provided runtime unary expression.  <a href="#a9c0967e60ffcbc81c111f9915cd1c2e2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a8e239d8c7d96460390e42e716dc38de9">diff</a> (<a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;e, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the derivative of the provided runtime expression wrapper.  <a href="#a8e239d8c7d96460390e42e716dc38de9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aeee9a608db41f2ba50043818657b49d0">diff</a> (<a class="el" href="classviennamath_1_1rt__function__symbol.html">rt_function_symbol</a>&lt; InterfaceType &gt; const &amp;other, <a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; const &amp;var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a symbolic representation of a differentiated function.  <a href="#aeee9a608db41f2ba50043818657b49d0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a297fafc1ec5b442c97b6574863c33569">diff</a> (<a class="el" href="classviennamath_1_1rt__function__symbol.html">rt_function_symbol</a>&lt; InterfaceType &gt; const &amp;other, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a symbolic representation of a differentiated function.  <a href="#a297fafc1ec5b442c97b6574863c33569"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; typename <br class="typebreak"/>
InterfaceType::numeric_type &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#afba60fe763204bd93cbc06f374415adb">diff</a> (typename InterfaceType::numeric_type value, <a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; const &amp;var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload for the derivative of a function.  <a href="#afba60fe763204bd93cbc06f374415adb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename OtherScalarType , typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; typename <br class="typebreak"/>
InterfaceType::numeric_type &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a00a4befbb56c300bc567ecb9957025e7">diff</a> (<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; OtherScalarType, InterfaceType &gt; const &amp;c, <a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; const &amp;var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload for the derivative of a ViennaMath runtime constant.  <a href="#a00a4befbb56c300bc567ecb9957025e7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type other_id, typename InterfaceType , id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; typename <br class="typebreak"/>
InterfaceType::numeric_type &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a8d2887dc545d3557aac5cdd776408bfd">diff</a> (<a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; const &amp;c, <a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; const &amp;var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload for computing the derivative of a runtime variable.  <a href="#a8d2887dc545d3557aac5cdd776408bfd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ExpressionType , id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennamath_1_1result__of_1_1diff.html">result_of::diff</a><br class="typebreak"/>
&lt; ExpressionType, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a><br class="typebreak"/>
&lt; id &gt; &gt;::result_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a3a61a081f98d587311e238af776275e7">diff</a> (ExpressionType const &amp;c, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The user function for differentiation of a compile time expression with respect to a compile time variable.  <a href="#a3a61a081f98d587311e238af776275e7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename FactorType , typename ExpressionType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennamath_1_1result__of_1_1drop__dependent__terms.html">result_of::drop_dependent_terms</a><br class="typebreak"/>
&lt; FactorType, ExpressionType &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a2ba179781678a0025cb911124c786d06">drop_dependent_terms</a> (FactorType const &amp;f, ExpressionType const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Main user function for dropping all terms from an expression which depend on a certain variable or expression.  <a href="#a2ba179781678a0025cb911124c786d06"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ExpressionType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennamath_1_1enable__if.html">enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structviennamath_1_1result__of_1_1is__ct__evaluable.html">result_of::is_ct_evaluable</a><br class="typebreak"/>
&lt; ExpressionType &gt;::value <br class="typebreak"/>
&amp;&amp;<a class="el" href="structviennamath_1_1result__of_1_1is__ct__vector.html">result_of::is_ct_vector</a><br class="typebreak"/>
&lt; VectorType &gt;::value, <br class="typebreak"/>
<a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#adc71b02c9631188dfd54d127ab2fabd4">eval</a> (ExpressionType const &amp;e, VectorType const &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Main user function for the evaluation of a compiletime expression at compiletime.  <a href="#adc71b02c9631188dfd54d127ab2fabd4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a25f3d5f97481e938b9bede810d3d998f">eval</a> (<a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> value, VectorType const &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation of a numeric constant at a vector: Return the constant.  <a href="#a25f3d5f97481e938b9bede810d3d998f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">long&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aa367b9783bb88e37367156901310030e">eval</a> (long value, VectorType const &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation of a long integer at a vector: Return the integer.  <a href="#aa367b9783bb88e37367156901310030e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename InterfaceType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InterfaceType::numeric_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a2697bfce5d19ac98b3ec55e5eb44b417">eval</a> (<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; T, InterfaceType &gt; c, VectorType const &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation of a runtime constant at a vector: Return the runtime constant.  <a href="#a2697bfce5d19ac98b3ec55e5eb44b417"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InterfaceType::numeric_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ae063e8264a95daa4f729dc3f94d22263">eval</a> (<a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; e, VectorType const &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation of a ViennaMath expression wrapper.  <a href="#ae063e8264a95daa4f729dc3f94d22263"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InterfaceType::numeric_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a81109d65dd902fdaf8a005b92cc5f8d6">eval</a> (<a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt; InterfaceType &gt; e, VectorType const &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation of a ViennaMath binary expression.  <a href="#a81109d65dd902fdaf8a005b92cc5f8d6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InterfaceType::numeric_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a82fcef91453e4c79b810bbd8732388af">eval</a> (<a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt; e, VectorType const &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation of a ViennaMath unary expression.  <a href="#a82fcef91453e4c79b810bbd8732388af"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InterfaceType::numeric_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a15b3925e322b066bceb1ca58fdb7a6e7">eval</a> (<a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; e, VectorType const &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation of a ViennaMath variable.  <a href="#a15b3925e322b066bceb1ca58fdb7a6e7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP , typename RHS , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennamath_1_1enable__if.html">enable_if</a><br class="typebreak"/>
&lt;!<a class="el" href="structviennamath_1_1result__of_1_1is__ct__evaluable.html">result_of::is_ct_evaluable</a><br class="typebreak"/>
&lt; <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS, OP, RHS &gt;<br class="typebreak"/>
 &gt;::value||!<a class="el" href="structviennamath_1_1result__of_1_1is__ct__vector.html">result_of::is_ct_vector</a><br class="typebreak"/>
&lt; VectorType &gt;::value, <br class="typebreak"/>
<a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a5c9885515a49186ecb6ee21c93bf7701">eval</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS, OP, RHS &gt; ex, VectorType const &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation of a ViennaMath compiletime binary expression using a runtime vector.  <a href="#a5c9885515a49186ecb6ee21c93bf7701"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP , typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennamath_1_1enable__if.html">enable_if</a><br class="typebreak"/>
&lt;!<a class="el" href="structviennamath_1_1result__of_1_1is__ct__evaluable.html">result_of::is_ct_evaluable</a><br class="typebreak"/>
&lt; <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS, OP &gt;<br class="typebreak"/>
 &gt;::value||!<a class="el" href="structviennamath_1_1result__of_1_1is__ct__vector.html">result_of::is_ct_vector</a><br class="typebreak"/>
&lt; VectorType &gt;::value, <br class="typebreak"/>
<a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a6b3443e4253490ad4f06590d551a7098">eval</a> (<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS, OP &gt; ex, VectorType const &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation of a ViennaMath compiletime unary expression using a runtime vector.  <a href="#a6b3443e4253490ad4f06590d551a7098"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value, typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ab0530d94cd91a922373ded31ce59046e">eval</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt; c, VectorType const &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation of a ViennaMath compiletime constant using a runtime vector.  <a href="#ab0530d94cd91a922373ded31ce59046e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id, typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#add057cfdd00564ef57e8dc6bf71e2f8d">eval</a> (<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; c, VectorType const &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation of a ViennaMath compiletime variable using a runtime vector.  <a href="#add057cfdd00564ef57e8dc6bf71e2f8d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id, typename T0 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a739cbee44c2b4c272312743453ebbb2d">eval</a> (<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; c, <a class="el" href="classviennamath_1_1ct__vector__1.html">ct_vector_1</a>&lt; T0 &gt; const &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation of a ViennaMath compiletime variable using a compiletime vector with one entry.  <a href="#a739cbee44c2b4c272312743453ebbb2d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id, typename T0 , typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aeb2c47237b0f5997f695f40bdc49fb8b">eval</a> (<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; c, <a class="el" href="classviennamath_1_1ct__vector__2.html">ct_vector_2</a>&lt; T0, T1 &gt; const &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation of a ViennaMath compiletime variable using a compiletime vector with two entries.  <a href="#aeb2c47237b0f5997f695f40bdc49fb8b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id, typename T0 , typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a112b8368ef6c6825946c30d010088dff">eval</a> (<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; c, <a class="el" href="classviennamath_1_1ct__vector__3.html">ct_vector_3</a>&lt; T0, T1, T2 &gt; const &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation of a ViennaMath compiletime variable using a compiletime vector with three entries.  <a href="#a112b8368ef6c6825946c30d010088dff"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ExpressionType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennamath_1_1result__of_1_1expand.html">result_of::expand</a><br class="typebreak"/>
&lt; ExpressionType &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ae659107e853ebcbb55407bb153a39e47">expand</a> (ExpressionType const &amp;type)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User function for expanding a compile time expression.  <a href="#ae659107e853ebcbb55407bb153a39e47"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LowerBound , typename UpperBound , typename IntegrandType , typename VariableType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennamath_1_1result__of_1_1integrate.html">result_of::integrate</a><br class="typebreak"/>
&lt; LowerBound, UpperBound, <br class="typebreak"/>
IntegrandType, VariableType &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a3e087490d53accc08db64b493a8d204e">integrate</a> (<a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt; LowerBound, UpperBound &gt; const &amp;interv, IntegrandType const &amp;integrand, VariableType const &amp;var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The user function for the compile time integration of a compile time expression.  <a href="#a3e087490d53accc08db64b493a8d204e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ExpressionType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennamath_1_1result__of_1_1simplify.html">result_of::simplify</a><br class="typebreak"/>
&lt; ExpressionType &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a099a3472ee309f0a7f3856ea53b4c224">simplify</a> (ExpressionType const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The generic interface function for compiletime manipulations.  <a href="#a099a3472ee309f0a7f3856ea53b4c224"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a17319bad30cc7bb804f34bfc1df2c773">inplace_simplify</a> (<a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simplifies an expression. Directly manipulates the provided expression.  <a href="#a17319bad30cc7bb804f34bfc1df2c773"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#accae5edbf08f26762a753808fb37cb03">inplace_simplify</a> (<a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt; &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simplifies an expression. Directly manipulates the provided expression.  <a href="#accae5edbf08f26762a753808fb37cb03"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a0514b3a86d63537776a8c06d5064305a">inplace_simplify</a> (<a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt; InterfaceType &gt; &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simplifies an expression. Directly manipulates the provided expression.  <a href="#a0514b3a86d63537776a8c06d5064305a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ab2bb6d0b7464765a9921c836412577ff">inplace_simplify</a> (T &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simplifies an expression. Directly manipulates the provided expression.  <a href="#ab2bb6d0b7464765a9921c836412577ff"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a7f0a16889b15a3820baff9d6d8e4e4b8">simplify</a> (<a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a new, simplified expression.  <a href="#a7f0a16889b15a3820baff9d6d8e4e4b8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a1117bd43873542d12cbcd9e4519577e0">simplify</a> (<a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a new, simplified expression.  <a href="#a1117bd43873542d12cbcd9e4519577e0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#af9cdf0307fb2394e9e3aafec045f46fb">simplify</a> (<a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a new, simplified expression.  <a href="#af9cdf0307fb2394e9e3aafec045f46fb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a03aca40c921022b15f1a9f7848111e3b">simplify</a> (T const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a new, simplified expression.  <a href="#a03aca40c921022b15f1a9f7848111e3b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename SearchType , typename ReplacementType , typename ExpressionType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structviennamath_1_1result__of_1_1substitute.html">result_of::substitute</a><br class="typebreak"/>
&lt; SearchType, ReplacementType, <br class="typebreak"/>
ExpressionType &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a175715df224eeeaca505554906516230">substitute</a> (SearchType const &amp;, ReplacementType const &amp;, ExpressionType const &amp;ex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The generic interface function for compiletime substitution.  <a href="#a175715df224eeeaca505554906516230"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename ReplacementType , typename ExpressionType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aebf95ab660141cea0a1657e9d3ca29d7">substitute</a> (<a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; const &amp;u, ReplacementType const &amp;repl, ExpressionType const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces all occurances of the variable 'u' in the expression 'e' with 'repl'.  <a href="#aebf95ab660141cea0a1657e9d3ca29d7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename ReplacementType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aa5add5eb3186740a97c9d02e9530b30e">substitute</a> (<a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; const &amp;u, ReplacementType const &amp;repl, <a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces all occurances of the variable 'u' in the expression 'e' with 'repl'.  <a href="#aa5add5eb3186740a97c9d02e9530b30e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#af6c27a8c577b4d1a3a43160eee378a90">substitute</a> (<a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; const &amp;u, <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> repl, <a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces all occurances of the variable 'u' in the expression 'e' with 'repl'.  <a href="#af6c27a8c577b4d1a3a43160eee378a90"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aa757a4af65d821d7023707a3308f20d4">substitute</a> (<a class="el" href="classviennamath_1_1rt__function__symbol.html">rt_function_symbol</a>&lt; InterfaceType &gt; const &amp;u, <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> repl, <a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces all occurances of the function symbol 'u' in the expression 'e' with 'repl'.  <a href="#aa757a4af65d821d7023707a3308f20d4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a62df9bea306cfe3e5df84601d41e5afa">substitute</a> (<a class="el" href="classviennamath_1_1rt__function__symbol.html">rt_function_symbol</a>&lt; InterfaceType &gt; const &amp;u, <a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;repl, <a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces all occurances of the function symbol 'u' in the expression 'e' with 'repl'.  <a href="#a62df9bea306cfe3e5df84601d41e5afa"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename ReplacementType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a7615a8e86229b78c6839dd562a7d5d65">substitute</a> (<a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt; const &amp;search, ReplacementType const &amp;repl, <a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces all occurances of the unary expression 'search' in the expression 'e' with 'repl'.  <a href="#a7615a8e86229b78c6839dd562a7d5d65"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a3558dd9b9b06dd97f0593c90055bcd82">substitute</a> (<a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt; const &amp;search, <a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;repl, <a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces all occurances of the unary expression 'search' in the expression 'e' with 'repl'.  <a href="#a3558dd9b9b06dd97f0593c90055bcd82"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename ReplacementType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a14a37e585c04587cbdd2b5bae45810f6">substitute</a> (<a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt; InterfaceType &gt; const &amp;search, ReplacementType const &amp;repl, <a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces all occurances of the binary expression 'search' in the expression 'e' with 'repl'.  <a href="#a14a37e585c04587cbdd2b5bae45810f6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a62faa5f9c1dfff907b94060b54211a7f">substitute</a> (<a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;search, <a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;repl, <a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces all occurances of the expression 'search' in the expression 'e' with 'repl'.  <a href="#a62faa5f9c1dfff907b94060b54211a7f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ac9ee50377d9c6ac19e3e06cc07e40a91">substitute</a> (std::vector&lt; <a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; &gt; const &amp;search, std::vector&lt; <a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; &gt; const &amp;repl, <a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces all occurances of the the expressions in 'search' in the expression 'e' with the corresponding expressions in 'repl'.  <a href="#ac9ee50377d9c6ac19e3e06cc07e40a91"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename PairType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aa31d186e422de5b063d30a189107257c">substitute</a> (<a class="el" href="classviennamath_1_1rt__symbolic__interval.html">rt_symbolic_interval</a>&lt; InterfaceType &gt; const &amp;search, PairType const &amp;repl, <a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Substitutes a symbolic interval with a concrete interval.  <a href="#aa31d186e422de5b063d30a189107257c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a2b93076569cd52d663262e1f6f2a272f">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the stream operator in order to allow for a convenient conversion of a unary expression to a string.  <a href="#a2b93076569cd52d663262e1f6f2a272f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a0f94e753da1d69943f9cb75e37f2a1ae">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; ScalarType, InterfaceType &gt; const &amp;c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience operator overload for streaming a runtime constant to std::cout or any other STL-compatible output stream.  <a href="#a0f94e753da1d69943f9cb75e37f2a1ae"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a4ad290f04051ef6fd8dc907265ecbae0">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience operator overload for streaming a runtime equation to std::cout or any other STL-compatible output stream.  <a href="#a4ad290f04051ef6fd8dc907265ecbae0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename InterfaceType , typename RHSType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a41161cd9c03afda4965842f1204f5756">make_equation</a> (typename InterfaceType::numeric_type lhs, <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; NumericT, InterfaceType &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generator for an equation with a (floating point) constant as left hand side and a ViennaMath runtime constant as right hand side.  <a href="#a41161cd9c03afda4965842f1204f5756"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a44690bcd75fd4f62047e325cd8eb5652">make_equation</a> (typename InterfaceType::numeric_type lhs, <a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generator for an equation with a (floating point) constant as left hand side and a ViennaMath runtime variable as right hand side.  <a href="#a44690bcd75fd4f62047e325cd8eb5652"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aa851687c416c934329cc6d5e9b58168c">make_equation</a> (<a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> lhs, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generator for an equation with a (floating point) constant as left hand side and a ViennaMath compiletime variable as right hand side.  <a href="#aa851687c416c934329cc6d5e9b58168c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a121d6f860f24f141b9d8659fe8fdd820">make_equation</a> (typename InterfaceType::numeric_type lhs, <a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generator for an equation with a (floating point) constant as left hand side and a ViennaMath runtime unary expression as right hand side.  <a href="#a121d6f860f24f141b9d8659fe8fdd820"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a1d2696afe9a144d1718635fb9218ae21">make_equation</a> (typename InterfaceType::numeric_type lhs, <a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt; InterfaceType &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generator for an equation with a (floating point) constant as left hand side and a ViennaMath runtime binary expression as right hand side.  <a href="#a1d2696afe9a144d1718635fb9218ae21"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aa4f2427f8a68104b5b82178fc4f528b9">make_equation</a> (typename InterfaceType::numeric_type lhs, <a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generator for an equation with a (floating point) constant as left hand side and a ViennaMath runtime expression wrapper as right hand side.  <a href="#aa4f2427f8a68104b5b82178fc4f528b9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename InterfaceType , typename RHSType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ac2339621f49675d392dc2b32ac2fb909">make_equation</a> (<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; NumericT, InterfaceType &gt; const &amp;lhs, RHSType const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generator for an equation with a ViennaMath runtime constant as left hand side.  <a href="#ac2339621f49675d392dc2b32ac2fb909"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename RHSType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a253b8cde5329dd9e3672ad8cdb7d0959">make_equation</a> (<a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; const &amp;lhs, RHSType const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generator for an equation with a ViennaMath runtime variable as left hand side.  <a href="#a253b8cde5329dd9e3672ad8cdb7d0959"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename RHSType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a227eb2b725343bb8993a2108087f806c">make_equation</a> (<a class="el" href="classviennamath_1_1rt__function__symbol.html">rt_function_symbol</a>&lt; InterfaceType &gt; const &amp;lhs, RHSType const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generator for an equation with a ViennaMath runtime function symbol as left hand side.  <a href="#a227eb2b725343bb8993a2108087f806c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename RHSType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ab75b3884f5e724b445b631ffa0a038a4">make_equation</a> (<a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt; const &amp;lhs, RHSType const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generator for an equation with a ViennaMath runtime unary expression as left hand side.  <a href="#ab75b3884f5e724b445b631ffa0a038a4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename RHSType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aca9e663980567e5038febdae97e8916f">make_equation</a> (<a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt; InterfaceType &gt; const &amp;lhs, RHSType const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generator for an equation with a ViennaMath runtime binary expression as left hand side.  <a href="#aca9e663980567e5038febdae97e8916f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename RHSType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a61349cc9febce8acc584c715ac02a04a">make_equation</a> (<a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;lhs, RHSType const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generator for an equation with a ViennaMath runtime expression wrapper as left hand side.  <a href="#a61349cc9febce8acc584c715ac02a04a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP , typename RHS , typename RHSType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a91b44dba590fd0eb8201ea1473da33eb">make_equation</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS, OP, RHS &gt; const &amp;lhs, RHSType const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generator for an equation with a ViennaMath compiletime binary expression as left hand side.  <a href="#a91b44dba590fd0eb8201ea1473da33eb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP , typename RHSType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ab614e35c2bbf9adcdf187aa6c5313e39">make_equation</a> (<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS, OP &gt; const &amp;lhs, RHSType const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generator for an equation with a ViennaMath compiletime unary expression as left hand side.  <a href="#ab614e35c2bbf9adcdf187aa6c5313e39"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long val, typename RHSType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a9e78860f6b8f98b07111ac449dcf789a">make_equation</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; val &gt; const &amp;lhs, RHSType const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generator for an equation with a ViennaMath compiletime constant as left hand side.  <a href="#a9e78860f6b8f98b07111ac449dcf789a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TAG , typename RHSType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aa2c2e672ffcd7858ff8dd796994b6d8a">make_equation</a> (<a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt; const &amp;lhs, RHSType const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generator for an equation with a ViennaMath compiletime function symbol as left hand side.  <a href="#aa2c2e672ffcd7858ff8dd796994b6d8a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id, typename RHSType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a1ce0f267bb1fe74a07eba4afebc69f1d">make_equation</a> (<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;lhs, RHSType const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generator for an equation with a ViennaMath compiletime variable as left hand side.  <a href="#a1ce0f267bb1fe74a07eba4afebc69f1d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#acbac35d965d2d596c91a0d29ed659616">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a029796c0197fb289d90d1dba41d5ac2b">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="classviennamath_1_1rt__function__symbol.html">rt_function_symbol</a>&lt; InterfaceType &gt; const &amp;v)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a648b715f23efe54dad4ccec705ad6a44">integral</a> (<a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt; InterfaceType &gt; const &amp;interv, <a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;integrand, <a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; const &amp;var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an expression encoding the integral of an expression with respect to a runtime variable over a certain interval.  <a href="#a648b715f23efe54dad4ccec705ad6a44"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a80fb54a6b2bafb1589bea4feb7c46b23">integral</a> (<a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt; InterfaceType &gt; const &amp;interv, <a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;integrand, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an expression encoding the integral of an expression with respect to a compiletime variable over a certain interval.  <a href="#a80fb54a6b2bafb1589bea4feb7c46b23"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aaef5b7023eb2629381e53a03bc968bf0">integral</a> (<a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt; InterfaceType &gt; const &amp;interv, <a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt; InterfaceType &gt; const &amp;integrand, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;var)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an expression encoding the integral of a binary expression with respect to a compiletime variable over a certain interval.  <a href="#aaef5b7023eb2629381e53a03bc968bf0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ac4d18932f682c17ac5a7bc707990784e">integral</a> (<a class="el" href="classviennamath_1_1rt__symbolic__interval.html">rt_symbolic_interval</a>&lt; InterfaceType &gt; const &amp;interv, <a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;integrand)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Integral generator function taking a symbolic interval and a runtime expression wrapper for the integrand.  <a href="#ac4d18932f682c17ac5a7bc707990784e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a3bbcb625b53a61ca3f6e549084f7bcd9">integral</a> (<a class="el" href="classviennamath_1_1rt__symbolic__interval.html">rt_symbolic_interval</a>&lt; InterfaceType &gt; const &amp;interv, <a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt; InterfaceType &gt; const &amp;integrand)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Integral generator function taking a symbolic interval and a runtime binary expression for the integrand.  <a href="#a3bbcb625b53a61ca3f6e549084f7bcd9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ac643593961a6c590ab0d5de202a9491b">integral</a> (<a class="el" href="classviennamath_1_1rt__symbolic__interval.html">rt_symbolic_interval</a>&lt; InterfaceType &gt; const &amp;interv, <a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt; const &amp;integrand)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Integral generator function taking a symbolic interval and a runtime unary expression for the integrand.  <a href="#ac643593961a6c590ab0d5de202a9491b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aed4862f645ae3075a3cc525e4aeca5e1">integral</a> (<a class="el" href="classviennamath_1_1rt__symbolic__interval.html">rt_symbolic_interval</a>&lt; InterfaceType &gt; const &amp;interv, <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; T, InterfaceType &gt; const &amp;integrand)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Integral generator function taking a symbolic interval and a ViennaMath runtime constant for the integrand.  <a href="#aed4862f645ae3075a3cc525e4aeca5e1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aff1321b9e5d1fd2682c401d952116259">integral</a> (<a class="el" href="classviennamath_1_1rt__symbolic__interval.html">rt_symbolic_interval</a>&lt; InterfaceType &gt; const &amp;interv, <a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; const &amp;integrand)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Integral generator function taking a symbolic interval and a ViennaMath runtime variable for the integrand.  <a href="#aff1321b9e5d1fd2682c401d952116259"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a2ab676ded45da7a1718f773b9225593c">integral</a> (<a class="el" href="classviennamath_1_1rt__symbolic__interval.html">rt_symbolic_interval</a>&lt; InterfaceType &gt; const &amp;interv, <a class="el" href="classviennamath_1_1rt__function__symbol.html">rt_function_symbol</a>&lt; InterfaceType &gt; const &amp;integrand)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Integral generator function taking a symbolic interval and a ViennaMath runtime function symbol for the integrand.  <a href="#a2ab676ded45da7a1718f773b9225593c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a671d30cfe31003c33e5552a77d351318">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience overload for streaming an interval to an output stream.  <a href="#a671d30cfe31003c33e5552a77d351318"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a6498609221413523451a8012b76fdf49">make_interval</a> (<a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> lhs, <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an interval with two numerical limits.  <a href="#a6498609221413523451a8012b76fdf49"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename InterfaceType , typename RHSType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a1e8f2a80bd7ac7d0a271e1034b4aef37">make_interval</a> (typename InterfaceType::numeric_type lhs, <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; NumericT, InterfaceType &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an interval, where the upper bound is given by a ViennaMath constant.  <a href="#a1e8f2a80bd7ac7d0a271e1034b4aef37"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#af7b0e477ed885a3254e3541a4e860c46">make_interval</a> (typename InterfaceType::numeric_type lhs, <a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an interval, where the upper bound is given by a ViennaMath runtime variable.  <a href="#af7b0e477ed885a3254e3541a4e860c46"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a2fa2be9f1e337890485f7974e89ccea3">make_interval</a> (<a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> lhs, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an interval, where the upper bound is given by a ViennaMath compiletime variable.  <a href="#a2fa2be9f1e337890485f7974e89ccea3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a09a751cbd8aee9f04cbdf7020fb2569b">make_interval</a> (typename InterfaceType::numeric_type lhs, <a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an interval, where the upper bound is given by a ViennaMath unary expression.  <a href="#a09a751cbd8aee9f04cbdf7020fb2569b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#af2c938c7a4991262ba94d85466c31ca3">make_interval</a> (typename InterfaceType::numeric_type lhs, <a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt; InterfaceType &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an interval, where the upper bound is given by a ViennaMath binary expression.  <a href="#af2c938c7a4991262ba94d85466c31ca3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ab852779d2653a19d42f9dc2e68c7250c">make_interval</a> (typename InterfaceType::numeric_type lhs, <a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an interval, where the upper bound is given by a ViennaMath expression wrapper.  <a href="#ab852779d2653a19d42f9dc2e68c7250c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename InterfaceType , typename RHSType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ab1c24b8711069a850ee17b95d9699e56">make_interval</a> (<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; NumericT, InterfaceType &gt; const &amp;lhs, RHSType const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an interval, where the lower bound is given by a ViennaMath runtime constant.  <a href="#ab1c24b8711069a850ee17b95d9699e56"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename RHSType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ae703a532dd4c9d253f60cc852d455887">make_interval</a> (<a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; const &amp;lhs, RHSType const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an interval, where the lower bound is given by a ViennaMath runtime variable.  <a href="#ae703a532dd4c9d253f60cc852d455887"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;id_type id, typename RHSType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a6994b6aded6f5ee6ca45574657f02e57">make_interval</a> (<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt; id &gt; const &amp;lhs, RHSType const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an interval, where the lower bound is given by a ViennaMath compiletime variable.  <a href="#a6994b6aded6f5ee6ca45574657f02e57"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename RHSType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a44bfa18c88d18271b40a22ba03508171">make_interval</a> (<a class="el" href="classviennamath_1_1rt__function__symbol.html">rt_function_symbol</a>&lt; InterfaceType &gt; const &amp;lhs, RHSType const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an interval, where the lower bound is given by a ViennaMath runtime function symbol.  <a href="#a44bfa18c88d18271b40a22ba03508171"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename RHSType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aba0e4705369d1dbbf2198e588db87d74">make_interval</a> (<a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt; const &amp;lhs, RHSType const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an interval, where the lower bound is given by a ViennaMath runtime unary expression.  <a href="#aba0e4705369d1dbbf2198e588db87d74"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename RHSType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ab1313b9bdf123efb43e0652e415b7e8a">make_interval</a> (<a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt; InterfaceType &gt; const &amp;lhs, RHSType const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an interval, where the lower bound is given by a ViennaMath runtime binary expression.  <a href="#ab1313b9bdf123efb43e0652e415b7e8a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename RHSType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ad8a5727a5d025bf366f9ab080cc5a249">make_interval</a> (<a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;lhs, RHSType const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an interval, where the lower bound is given by a ViennaMath runtime expression wrapper.  <a href="#ad8a5727a5d025bf366f9ab080cc5a249"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP , typename RHS , typename RHSType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt; typename <br class="typebreak"/>
RHSType::interface_type &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a9e09bcf326a34a06bca4787afe70793b">make_interval</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; LHS, OP, RHS &gt; const &amp;lhs, RHSType const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an interval, where the lower bound is given by a ViennaMath compiletime binary expression.  <a href="#a9e09bcf326a34a06bca4787afe70793b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename LHS , typename OP , typename RHSType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt; typename <br class="typebreak"/>
RHSType::interface_type &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#afa02c21471433c73792f2a76efd12484">make_interval</a> (<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt; LHS, OP &gt; const &amp;lhs, RHSType const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an interval, where the lower bound is given by a ViennaMath compiletime unary expression.  <a href="#afa02c21471433c73792f2a76efd12484"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long val, typename RHSType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt; typename <br class="typebreak"/>
RHSType::interface_type &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a8c166e36a6c13c9df5ebced001973ce1">make_interval</a> (<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; val &gt; const &amp;lhs, RHSType const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an interval, where the lower bound is given by a ViennaMath compiletime constant.  <a href="#a8c166e36a6c13c9df5ebced001973ce1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename TAG , typename RHSType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt; typename <br class="typebreak"/>
RHSType::interface_type &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a73f4222ebf9a33334f27860f7e51acea">make_interval</a> (<a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt; TAG &gt; const &amp;lhs, RHSType const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an interval, where the lower bound is given by a ViennaMath compiletime function symbol.  <a href="#a73f4222ebf9a33334f27860f7e51acea"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename InterfaceType , typename OtherScalarType , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a><br class="typebreak"/>
&lt; typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a><br class="typebreak"/>
&lt; ScalarType, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a><br class="typebreak"/>
&lt; typename <br class="typebreak"/>
InterfaceType::numeric_type &gt;<br class="typebreak"/>
, OtherScalarType &gt;<br class="typebreak"/>
::result_type, InterfaceType &gt;<br class="typebreak"/>
, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt; typename <br class="typebreak"/>
InterfaceType::numeric_type &gt;<br class="typebreak"/>
, RHS &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a80a3bf98d0ca82ed116230c1545d13ba">operator+</a> (<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; ScalarType, InterfaceType &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; OtherScalarType, InterfaceType &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt; typename InterfaceType::numeric_type &gt;, RHS &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload for c1 + (c2 + X) -&gt; [c1 + c2] + X, where c1 and c2 are runtime constants and X is any expression:  <a href="#a80a3bf98d0ca82ed116230c1545d13ba"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename InterfaceType , long value, typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a><br class="typebreak"/>
&lt; typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a><br class="typebreak"/>
&lt; ScalarType, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a><br class="typebreak"/>
&lt; typename <br class="typebreak"/>
InterfaceType::numeric_type &gt;<br class="typebreak"/>
, long &gt;::result_type, <br class="typebreak"/>
InterfaceType &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a><br class="typebreak"/>
&lt; typename <br class="typebreak"/>
InterfaceType::numeric_type &gt;<br class="typebreak"/>
, RHS &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a315e9e2f2528b1c1080d836976f50b16">operator+</a> (<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; ScalarType, InterfaceType &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt; typename InterfaceType::numeric_type &gt;, RHS &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload for c1 + (ct_c2 + X) -&gt; [c1 + ct_c2] + X, where c1 is a runtime constant, ct_c2 is a compiletime constant, and X is any expression:  <a href="#a315e9e2f2528b1c1080d836976f50b16"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename InterfaceType , typename OtherScalarType , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a><br class="typebreak"/>
&lt; typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a><br class="typebreak"/>
&lt; ScalarType, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a><br class="typebreak"/>
&lt; typename <br class="typebreak"/>
InterfaceType::numeric_type &gt;<br class="typebreak"/>
, OtherScalarType &gt;<br class="typebreak"/>
::result_type, InterfaceType &gt;<br class="typebreak"/>
, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt; typename <br class="typebreak"/>
InterfaceType::numeric_type &gt;<br class="typebreak"/>
, RHS &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a0d05916e7b1421b8b75969d6b11d1a4f">operator+</a> (<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; ScalarType, InterfaceType &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; OtherScalarType, InterfaceType &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt; typename InterfaceType::numeric_type &gt;, RHS &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload for c1 + (c2 - X) -&gt; [c1 + c2] - X, where c1 and c2 are runtime constants and X is any expression:  <a href="#a0d05916e7b1421b8b75969d6b11d1a4f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename InterfaceType , long value, typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a><br class="typebreak"/>
&lt; typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a><br class="typebreak"/>
&lt; ScalarType, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a><br class="typebreak"/>
&lt; typename <br class="typebreak"/>
InterfaceType::numeric_type &gt;<br class="typebreak"/>
, long &gt;::result_type, <br class="typebreak"/>
InterfaceType &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a><br class="typebreak"/>
&lt; typename <br class="typebreak"/>
InterfaceType::numeric_type &gt;<br class="typebreak"/>
, RHS &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a0cd0fcfe3109122f026b7e84b1d9d4f1">operator+</a> (<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; ScalarType, InterfaceType &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt; typename InterfaceType::numeric_type &gt;, RHS &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload for c1 + (ct_c2 - X) -&gt; [c1 + ct_c2] - X, where c1 is a runtime constant, ct_c2 is a compiletime constant, and X is any expression:  <a href="#a0cd0fcfe3109122f026b7e84b1d9d4f1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value, typename RHS , typename ScalarType , typename T , typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a><br class="typebreak"/>
&lt; typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a><br class="typebreak"/>
&lt; long, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt; T &gt;<br class="typebreak"/>
, ScalarType &gt;::result_type &gt;<br class="typebreak"/>
, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt; T &gt;, RHS &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ad472832eddd8bcffc0a37837eab7a276">operator+</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt; T &gt;, RHS &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; ScalarType, InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload for (ct_c1 + X) + c2 -&gt; [ct_c1 + c2] + X, where ct_c1 is a compile constant, c2 is a runtime constant, and X is any expression:  <a href="#ad472832eddd8bcffc0a37837eab7a276"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;long value, typename RHS , typename ScalarType , typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>, <br class="typebreak"/>
InterfaceType &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> &gt;, RHS &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#add657c99d615c1990fefcdf268e60295">operator+</a> (<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt; <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> &gt;, RHS &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; ScalarType, InterfaceType &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload for (ct_c1 - X) + c2 -&gt; [ct_c1 + c2] - X, where ct_c1 is a compile constant, c2 is a runtime constant, and X is any expression:  <a href="#add657c99d615c1990fefcdf268e60295"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename InterfaceType , typename OtherScalarType , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a><br class="typebreak"/>
&lt; typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a><br class="typebreak"/>
&lt; ScalarType, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a><br class="typebreak"/>
&lt; typename <br class="typebreak"/>
InterfaceType::numeric_type &gt;<br class="typebreak"/>
, OtherScalarType &gt;<br class="typebreak"/>
::result_type, InterfaceType &gt;<br class="typebreak"/>
, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt; typename <br class="typebreak"/>
InterfaceType::numeric_type &gt;<br class="typebreak"/>
, RHS &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a605b04922d052aaf90275295f760b1fa">operator-</a> (<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; ScalarType, InterfaceType &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; OtherScalarType, InterfaceType &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt; typename InterfaceType::numeric_type &gt;, RHS &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload for c1 - (c2 + X) -&gt; [c1 - c2] - X, where c1 and c2 are runtime constants and X is any expression:  <a href="#a605b04922d052aaf90275295f760b1fa"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename InterfaceType , long value, typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a><br class="typebreak"/>
&lt; typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a><br class="typebreak"/>
&lt; ScalarType, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a><br class="typebreak"/>
&lt; typename <br class="typebreak"/>
InterfaceType::numeric_type &gt;<br class="typebreak"/>
, long &gt;::result_type, <br class="typebreak"/>
InterfaceType &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a><br class="typebreak"/>
&lt; typename <br class="typebreak"/>
InterfaceType::numeric_type &gt;<br class="typebreak"/>
, RHS &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ad2c13bd71fc10f21715aed3e06d77e12">operator-</a> (<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; ScalarType, InterfaceType &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt; typename InterfaceType::numeric_type &gt;, RHS &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload for c1 - (ct_c2 + X) -&gt; [c1 - ct_c2] - X, where c1 is a runtime constant, ct_c2 is a compiletime constant, and X is any expression:  <a href="#ad2c13bd71fc10f21715aed3e06d77e12"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename InterfaceType , typename OtherScalarType , typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a><br class="typebreak"/>
&lt; typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a><br class="typebreak"/>
&lt; ScalarType, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a><br class="typebreak"/>
&lt; typename <br class="typebreak"/>
InterfaceType::numeric_type &gt;<br class="typebreak"/>
, OtherScalarType &gt;<br class="typebreak"/>
::result_type, InterfaceType &gt;<br class="typebreak"/>
, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt; typename <br class="typebreak"/>
InterfaceType::numeric_type &gt;<br class="typebreak"/>
, RHS &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a124bc79e9ab4caa6b3a81429991811e9">operator-</a> (<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; ScalarType, InterfaceType &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; OtherScalarType, InterfaceType &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt; typename InterfaceType::numeric_type &gt;, RHS &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload for c1 - (c2 - X) -&gt; [c1 - c2] + X, where c1 and c2 are runtime constants and X is any expression:  <a href="#a124bc79e9ab4caa6b3a81429991811e9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename InterfaceType , long value, typename RHS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a><br class="typebreak"/>
&lt; typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a><br class="typebreak"/>
&lt; ScalarType, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a><br class="typebreak"/>
&lt; typename <br class="typebreak"/>
InterfaceType::numeric_type &gt;<br class="typebreak"/>
, long &gt;::result_type, <br class="typebreak"/>
InterfaceType &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a><br class="typebreak"/>
&lt; typename <br class="typebreak"/>
InterfaceType::numeric_type &gt;<br class="typebreak"/>
, RHS &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a21cfb8382ef091ea00128c6958ec3333">operator-</a> (<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; ScalarType, InterfaceType &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt; typename InterfaceType::numeric_type &gt;, RHS &gt; const &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload for c1 - (ct_c2 - X) -&gt; [c1 - ct_c2] + X, where c1 is a runtime constant, ct_c2 is a compiletime constant, and X is any expression:  <a href="#a21cfb8382ef091ea00128c6958ec3333"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename NumericT , typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ac7c9e972f9e31e0f4c489d07d524b6e2">operator*</a> (<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; NumericT, InterfaceType &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1rt__function__symbol.html">rt_function_symbol</a>&lt; InterfaceType &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload for the multiplication of a function symbol with a ViennaMath runtime constant.  <a href="#ac7c9e972f9e31e0f4c489d07d524b6e2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ab051ef2d7bfda3f3decc17d7d8e8309c">operator*</a> (<a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1rt__function__symbol.html">rt_function_symbol</a>&lt; InterfaceType &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special overload for the multiplication of a function symbol with a ViennaMath runtime expression wrapper.  <a href="#ab051ef2d7bfda3f3decc17d7d8e8309c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a25a9a9662614fb7b641e7a4f1e08a32a">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="classviennamath_1_1rt__symbolic__interval.html">rt_symbolic_interval</a>&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience overload for obtaining a string representation of a symbolic interval.  <a href="#a25a9a9662614fb7b641e7a4f1e08a32a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a72f88f5abbd2b1f61c3f10498604fe85">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overload of the stream operator in order to allow for a convenient conversion of a unary expression to a string.  <a href="#a72f88f5abbd2b1f61c3f10498604fe85"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a161236234f212240c8946721f8366562">unary_op_equal</a> (T const &amp;lhs, T const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function returning true if the two arguments are of the same type.  <a href="#a161236234f212240c8946721f8366562"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VectorType::value_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#af127bad7291f5b91a873810a374ea821">get_from_vector</a> (VectorType const &amp;vec, <a class="el" href="namespaceviennamath.html#acff9357d27786ad0c1d9ae2e78ab83d2">id_type</a> i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic wrapper function for accessing the i-th entry of a vector. Provides a uniform interface for compile-time and run-time vectors.  <a href="#af127bad7291f5b91a873810a374ea821"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a563ce2927de883d4e75c673b042604e7">get_from_vector</a> (<a class="el" href="classviennamath_1_1ct__vector__1.html">ct_vector_1</a>&lt; T1 &gt; const &amp;vec, <a class="el" href="namespaceviennamath.html#acff9357d27786ad0c1d9ae2e78ab83d2">id_type</a> i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic wrapper function for accessing the i-th entry of a vector. Provides a uniform interface for compile-time and run-time vectors.  <a href="#a563ce2927de883d4e75c673b042604e7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aa7c90f77e052d9583cac44bc049624ce">get_from_vector</a> (<a class="el" href="classviennamath_1_1ct__vector__2.html">ct_vector_2</a>&lt; T1, T2 &gt; const &amp;vec, <a class="el" href="namespaceviennamath.html#acff9357d27786ad0c1d9ae2e78ab83d2">id_type</a> i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic wrapper function for accessing the i-th entry of a vector. Provides a uniform interface for compile-time and run-time vectors.  <a href="#aa7c90f77e052d9583cac44bc049624ce"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#ac185fae0345a308e5125547007192308">get_from_vector</a> (<a class="el" href="classviennamath_1_1ct__vector__3.html">ct_vector_3</a>&lt; T1, T2, T3 &gt; const &amp;vec, <a class="el" href="namespaceviennamath.html#acff9357d27786ad0c1d9ae2e78ab83d2">id_type</a> i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic wrapper function for accessing the i-th entry of a vector. Provides a uniform interface for compile-time and run-time vectors.  <a href="#ac185fae0345a308e5125547007192308"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a61156a6761913f9bd3e9d6b446df23b0">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a>&lt; InterfaceType &gt; const &amp;u)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output stream overload, mostly used for printing an expression to screen.  <a href="#a61156a6761913f9bd3e9d6b446df23b0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aa5422111f525aa1fb878585842de12fc">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="classviennamath_1_1rt__vector__expr.html">rt_vector_expr</a>&lt; InterfaceType &gt; const &amp;e)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__vector__expr.html">rt_vector_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a6e0454dd8f9c2b2e199348db10ac802d">operator*</a> (<a class="el" href="classviennamath_1_1rt__vector__expr.html">rt_vector_expr</a>&lt; InterfaceType &gt; const &amp;lhs, T const &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__vector__expr.html">rt_vector_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a58e542ef6cbfd4726528a48c6f288efa">operator*</a> (T const &amp;lhs, <a class="el" href="classviennamath_1_1rt__vector__expr.html">rt_vector_expr</a>&lt; InterfaceType &gt; const &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#aa092de3a8ed2a81de68824c0aa66218f">operator*</a> (<a class="el" href="classviennamath_1_1rt__vector__expr.html">rt_vector_expr</a>&lt; InterfaceType &gt; const &amp;lhs, <a class="el" href="classviennamath_1_1rt__vector__expr.html">rt_vector_expr</a>&lt; InterfaceType &gt; const &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InterfaceType , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__vector__expr.html">rt_vector_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a369e52002e304b528ca2747e9ff2479b">operator/</a> (<a class="el" href="classviennamath_1_1rt__vector__expr.html">rt_vector_expr</a>&lt; InterfaceType &gt; const &amp;lhs, T const &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename InterfaceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classviennamath_1_1rt__vector__expr.html">rt_vector_expr</a>&lt; InterfaceType &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceviennamath.html#a94a6ec97828479323cc13bcc0b7c4301">operator/</a> (T const &amp;lhs, <a class="el" href="classviennamath_1_1rt__vector__expr.html">rt_vector_expr</a>&lt; InterfaceType &gt; const &amp;rhs)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The main ViennaMath namespace. All types and functions for the user reside here. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ad9a6d21e340fc856e9e2a7ebb6cf21ca"></a><!-- doxytag: member="viennamath::binary_expr" ref="ad9a6d21e340fc856e9e2a7ebb6cf21ca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a> <a class="el" href="classviennamath_1_1rt__binary__expr.html">binary_expr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aba5112b4db8f18758911907e380cf264"></a><!-- doxytag: member="viennamath::constant" ref="aba5112b4db8f18758911907e380cf264" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a> <a class="el" href="classviennamath_1_1rt__constant.html">constant</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac8b78c7806640b05ca58aaeba616d9c1"></a><!-- doxytag: member="viennamath::default_interface_type" ref="ac8b78c7806640b05ca58aaeba616d9c1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennamath_1_1rt__expression__interface.html">rt_expression_interface</a>&lt;<a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>&gt; <a class="el" href="classviennamath_1_1rt__expression__interface.html">default_interface_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience type definition for the default expression interface. </p>

</div>
</div>
<a class="anchor" id="a97e77ded8737e25ae18d165a33179286"></a><!-- doxytag: member="viennamath::default_numeric_type" ref="a97e77ded8737e25ae18d165a33179286" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The underlying floating point type to be used in case of doubt (e.g. when new constants are created during manipulation). </p>

</div>
</div>
<a class="anchor" id="a851bad3788c5dbe912da12d0c40d4d20"></a><!-- doxytag: member="viennamath::equation" ref="a851bad3788c5dbe912da12d0c40d4d20" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a> <a class="el" href="classviennamath_1_1rt__equation.html">equation</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a50974365c0be03981bbd761766c970b6"></a><!-- doxytag: member="viennamath::expr" ref="a50974365c0be03981bbd761766c970b6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a> <a class="el" href="classviennamath_1_1rt__expr.html">expr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab6b5705970b712844d53cbe01b130eec"></a><!-- doxytag: member="viennamath::function_symbol" ref="ab6b5705970b712844d53cbe01b130eec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennamath_1_1rt__function__symbol.html">rt_function_symbol</a> <a class="el" href="classviennamath_1_1rt__function__symbol.html">function_symbol</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a36770fadae668b44095f251e00511537"></a><!-- doxytag: member="viennamath::gauss_quad_1" ref="a36770fadae668b44095f251e00511537" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennamath_1_1rt__gauss__quad__1.html">rt_gauss_quad_1</a> <a class="el" href="classviennamath_1_1rt__gauss__quad__1.html">gauss_quad_1</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acff9357d27786ad0c1d9ae2e78ab83d2"></a><!-- doxytag: member="viennamath::id_type" ref="acff9357d27786ad0c1d9ae2e78ab83d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned long <a class="el" href="namespaceviennamath.html#acff9357d27786ad0c1d9ae2e78ab83d2">id_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type used for any kind of IDs (variable, etc.). </p>

</div>
</div>
<a class="anchor" id="a4b0e68703e0147319ac33fb857f1cdea"></a><!-- doxytag: member="viennamath::interval" ref="a4b0e68703e0147319ac33fb857f1cdea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a> <a class="el" href="classviennamath_1_1rt__interval.html">interval</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a60b5a0cfc11e63a12ed29bb2ed6a364e"></a><!-- doxytag: member="viennamath::latex_translator" ref="a60b5a0cfc11e63a12ed29bb2ed6a364e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennamath_1_1rt__latex__translator.html">rt_latex_translator</a> <a class="el" href="classviennamath_1_1rt__latex__translator.html">latex_translator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience typedef for the latex translator in order to avoid the ugly '&lt;&gt;' for the default template parameter of <a class="el" href="classviennamath_1_1rt__latex__translator.html" title="The main LaTeX translator class. To be used and manipulated by the ViennaMath library user...">rt_latex_translator</a>. </p>

</div>
</div>
<a class="anchor" id="a79a2a51538257b304d7801a5d4404474"></a><!-- doxytag: member="viennamath::numerical_quadrature" ref="a79a2a51538257b304d7801a5d4404474" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennamath_1_1rt__numerical__quadrature.html">rt_numerical_quadrature</a> <a class="el" href="classviennamath_1_1rt__numerical__quadrature.html">numerical_quadrature</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2f381b80192d3734ea27b03e10d7bb21"></a><!-- doxytag: member="viennamath::symbolic_interval" ref="a2f381b80192d3734ea27b03e10d7bb21" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennamath_1_1rt__symbolic__interval.html">rt_symbolic_interval</a> <a class="el" href="classviennamath_1_1rt__symbolic__interval.html">symbolic_interval</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a28408548bab180778977b5f39a383449"></a><!-- doxytag: member="viennamath::unary_expr" ref="a28408548bab180778977b5f39a383449" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> <a class="el" href="classviennamath_1_1rt__unary__expr.html">unary_expr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aca2ca1f2df887f6733612f7bebb12550"></a><!-- doxytag: member="viennamath::variable" ref="aca2ca1f2df887f6733612f7bebb12550" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennamath_1_1rt__variable.html">rt_variable</a> <a class="el" href="classviennamath_1_1rt__variable.html">variable</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2993287894f3ac500b754b731eadc295"></a><!-- doxytag: member="viennamath::vector_expr" ref="a2993287894f3ac500b754b731eadc295" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classviennamath_1_1rt__vector__expr.html">rt_vector_expr</a> <a class="el" href="classviennamath_1_1rt__vector__expr.html">vector_expr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ac92bb7219a73e9249de48ce223188f64"></a><!-- doxytag: member="viennamath::apply_coordinate_system" ref="ac92bb7219a73e9249de48ce223188f64" args="(cartesian&lt; 1 &gt;, rt_expr&lt; InterfaceType &gt; const &amp;ex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::apply_coordinate_system </td>
          <td>(</td>
          <td class="paramtype">cartesian&lt; 1 &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>ex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transforms the expression to a Cartesian coordinate system in one dimension. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ex</em>&nbsp;</td><td>The runtime expression wrapper to be transformed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3f6f67ccee010451bf05ccf324cd3703"></a><!-- doxytag: member="viennamath::apply_coordinate_system" ref="a3f6f67ccee010451bf05ccf324cd3703" args="(cartesian&lt; 1 &gt;, rt_unary_expr&lt; InterfaceType &gt; const &amp;ex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::apply_coordinate_system </td>
          <td>(</td>
          <td class="paramtype">cartesian&lt; 1 &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_unary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>ex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transforms the expression to a Cartesian coordinate system in one dimension. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ex</em>&nbsp;</td><td>The runtime unary expression to be transformed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a902afcecfaad71142eea4fbed682a7b5"></a><!-- doxytag: member="viennamath::apply_coordinate_system" ref="a902afcecfaad71142eea4fbed682a7b5" args="(cartesian&lt; 1 &gt;, rt_binary_expr&lt; InterfaceType &gt; const &amp;ex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::apply_coordinate_system </td>
          <td>(</td>
          <td class="paramtype">cartesian&lt; 1 &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_binary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>ex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transforms the expression to a Cartesian coordinate system in one dimension. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ex</em>&nbsp;</td><td>The runtime binary expression to be transformed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c6f262a6341815bf3e351a66f75e673"></a><!-- doxytag: member="viennamath::apply_coordinate_system" ref="a8c6f262a6341815bf3e351a66f75e673" args="(cartesian&lt; 2 &gt;, rt_expr&lt; InterfaceType &gt; const &amp;ex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::apply_coordinate_system </td>
          <td>(</td>
          <td class="paramtype">cartesian&lt; 2 &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>ex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transforms the expression to a Cartesian coordinate system in two dimensions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ex</em>&nbsp;</td><td>The runtime expression wrapper to be transformed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9404f9d8a924aca257b04610322f75ca"></a><!-- doxytag: member="viennamath::apply_coordinate_system" ref="a9404f9d8a924aca257b04610322f75ca" args="(cartesian&lt; 2 &gt;, rt_unary_expr&lt; InterfaceType &gt; const &amp;ex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::apply_coordinate_system </td>
          <td>(</td>
          <td class="paramtype">cartesian&lt; 2 &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_unary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>ex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transforms the expression to a Cartesian coordinate system in two dimensions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ex</em>&nbsp;</td><td>The runtime unary expression to be transformed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a35f31f13ad8fdffe7e8794b9f6dc4a08"></a><!-- doxytag: member="viennamath::apply_coordinate_system" ref="a35f31f13ad8fdffe7e8794b9f6dc4a08" args="(cartesian&lt; 2 &gt;, rt_binary_expr&lt; InterfaceType &gt; const &amp;ex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::apply_coordinate_system </td>
          <td>(</td>
          <td class="paramtype">cartesian&lt; 2 &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_binary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>ex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transforms the expression to a Cartesian coordinate system in two dimensions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ex</em>&nbsp;</td><td>The runtime binary expression to be transformed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d844bc96490b7de1badeb12f8d1fa8b"></a><!-- doxytag: member="viennamath::apply_coordinate_system" ref="a0d844bc96490b7de1badeb12f8d1fa8b" args="(cartesian&lt; 3 &gt;, rt_expr&lt; InterfaceType &gt; const &amp;ex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::apply_coordinate_system </td>
          <td>(</td>
          <td class="paramtype">cartesian&lt; 3 &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>ex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transforms the expression to a Cartesian coordinate system in two dimensions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ex</em>&nbsp;</td><td>The runtime expression wrapper to be transformed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="addb1d3f9467893cbfa12b5ee8f15bdf4"></a><!-- doxytag: member="viennamath::apply_coordinate_system" ref="addb1d3f9467893cbfa12b5ee8f15bdf4" args="(cartesian&lt; 3 &gt;, rt_unary_expr&lt; InterfaceType &gt; const &amp;ex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::apply_coordinate_system </td>
          <td>(</td>
          <td class="paramtype">cartesian&lt; 3 &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_unary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>ex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transforms the expression to a Cartesian coordinate system in three dimensions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ex</em>&nbsp;</td><td>The runtime unary expression to be transformed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad7d9bad718c2e2c91e2df780b275709b"></a><!-- doxytag: member="viennamath::apply_coordinate_system" ref="ad7d9bad718c2e2c91e2df780b275709b" args="(cartesian&lt; 3 &gt;, rt_binary_expr&lt; InterfaceType &gt; const &amp;ex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::apply_coordinate_system </td>
          <td>(</td>
          <td class="paramtype">cartesian&lt; 3 &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_binary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>ex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transforms the expression to a Cartesian coordinate system in three dimensions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ex</em>&nbsp;</td><td>The runtime binary expression to be transformed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90a0140ca5c7c0956bc4cf2e05aeaed1"></a><!-- doxytag: member="viennamath::apply_coordinate_system" ref="a90a0140ca5c7c0956bc4cf2e05aeaed1" args="(cartesian&lt; dim &gt;, rt_equation&lt; InterfaceType &gt; const &amp;equ)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&lt;InterfaceType&gt; viennamath::apply_coordinate_system </td>
          <td>(</td>
          <td class="paramtype">cartesian&lt; dim &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_equation&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>equ</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience overload which automatically applies the coordinate transformation to the right hand left hand side of an equation. </p>

</div>
</div>
<a class="anchor" id="aa897431732086eff2b487d13b163ba1d"></a><!-- doxytag: member="viennamath::can_simplify_impl" ref="aa897431732086eff2b487d13b163ba1d" args="(const InterfaceType *lhs, op_plus&lt; NumericT &gt;, const InterfaceType *rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool can_simplify_impl </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">op_plus&lt; NumericT &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether an expression of the form e1 + e2 can be simplified. </p>

</div>
</div>
<a class="anchor" id="ae55ecd908151aa5bd5370d852e096738"></a><!-- doxytag: member="viennamath::can_simplify_impl" ref="ae55ecd908151aa5bd5370d852e096738" args="(const InterfaceType *lhs, op_minus&lt; NumericT &gt;, const InterfaceType *rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool can_simplify_impl </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">op_minus&lt; NumericT &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether an expression of the form e1 - e2 can be simplified. </p>

</div>
</div>
<a class="anchor" id="a07f64745b64d72de0b8b2851f1f10fb1"></a><!-- doxytag: member="viennamath::can_simplify_impl" ref="a07f64745b64d72de0b8b2851f1f10fb1" args="(const InterfaceType *lhs, op_mult&lt; NumericT &gt;, const InterfaceType *rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool can_simplify_impl </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">op_mult&lt; NumericT &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether an expression of the form e1 * e2 can be simplified. </p>

</div>
</div>
<a class="anchor" id="a0b6c204941b90a57ce27da642b68d531"></a><!-- doxytag: member="viennamath::can_simplify_impl" ref="a0b6c204941b90a57ce27da642b68d531" args="(const InterfaceType *lhs, op_div&lt; NumericT &gt;, const InterfaceType *rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool can_simplify_impl </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">op_div&lt; NumericT &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether an expression of the form e1 / e2 can be simplified. </p>

</div>
</div>
<a class="anchor" id="ae70ee72fa691c4309562685abdc08c9d"></a><!-- doxytag: member="viennamath::coefficient" ref="ae70ee72fa691c4309562685abdc08c9d" args="(FactorType const &amp;f, ExpressionType const &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennamath_1_1result__of_1_1coefficient.html">viennamath::result_of::coefficient</a>&lt;FactorType, ExpressionType&gt;::type viennamath::coefficient </td>
          <td>(</td>
          <td class="paramtype">FactorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExpressionType const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>User function for extracting the coefficient of a variable or sub-expression from an expression. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>The variable or sub-expression to be extracted </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>e</em>&nbsp;</td><td>The expression from which the coefficient is to be extracted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab34c1026105a04eef6e8433cc228893c"></a><!-- doxytag: member="viennamath::cos" ref="ab34c1026105a04eef6e8433cc228893c" args="(rt_constant&lt; NumericT, InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::cos </td>
          <td>(</td>
          <td class="paramtype">rt_constant&lt; NumericT, InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the cosine function for a ViennaMath runtime constant. </p>

</div>
</div>
<a class="anchor" id="a5f9160049c00d26edcbf7223c9a9cc92"></a><!-- doxytag: member="viennamath::cos" ref="a5f9160049c00d26edcbf7223c9a9cc92" args="(rt_variable&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::cos </td>
          <td>(</td>
          <td class="paramtype">rt_variable&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the cosine function for a ViennaMath runtime variable. </p>

</div>
</div>
<a class="anchor" id="a0252e9b79684a885babceb416c0f7eeb"></a><!-- doxytag: member="viennamath::cos" ref="a0252e9b79684a885babceb416c0f7eeb" args="(ct_variable&lt; id &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> viennamath::cos </td>
          <td>(</td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the cosine function for a ViennaMath compiletime variable. </p>

</div>
</div>
<a class="anchor" id="abd11bddf2d5ea29cd6dc432ae84f0691"></a><!-- doxytag: member="viennamath::cos" ref="abd11bddf2d5ea29cd6dc432ae84f0691" args="(ct_binary_expr&lt; LHS, OP, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> viennamath::cos </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; LHS, OP, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the cosine function for a ViennaMath compiletime binary expression. </p>

</div>
</div>
<a class="anchor" id="a241e81bac772871f95061481fe5a912c"></a><!-- doxytag: member="viennamath::cos" ref="a241e81bac772871f95061481fe5a912c" args="(ct_unary_expr&lt; LHS, OP &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> viennamath::cos </td>
          <td>(</td>
          <td class="paramtype">ct_unary_expr&lt; LHS, OP &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the cosine function for a ViennaMath compiletime unary expression. </p>

</div>
</div>
<a class="anchor" id="abfdb31cae3e8b1958e19aff8d8caf240"></a><!-- doxytag: member="viennamath::cos" ref="abfdb31cae3e8b1958e19aff8d8caf240" args="(rt_unary_expr&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::cos </td>
          <td>(</td>
          <td class="paramtype">rt_unary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the cosine function for a ViennaMath runtime unary expression. </p>

</div>
</div>
<a class="anchor" id="a6760f76e92b43f668ca0aadfa6f0bde0"></a><!-- doxytag: member="viennamath::cos" ref="a6760f76e92b43f668ca0aadfa6f0bde0" args="(rt_binary_expr&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::cos </td>
          <td>(</td>
          <td class="paramtype">rt_binary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the cosine function for a ViennaMath runtime binary expression. </p>

</div>
</div>
<a class="anchor" id="a20397bef45df45443e7fd1e9627ad12e"></a><!-- doxytag: member="viennamath::cos" ref="a20397bef45df45443e7fd1e9627ad12e" args="(rt_expr&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::cos </td>
          <td>(</td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the cosine function for a ViennaMath runtime expression wrapper. </p>

</div>
</div>
<a class="anchor" id="a64939d85ad712c555e36b4ad7b2bbe1a"></a><!-- doxytag: member="viennamath::diff" ref="a64939d85ad712c555e36b4ad7b2bbe1a" args="(rt_binary_expr&lt; InterfaceType &gt; const &amp;e, rt_variable&lt; InterfaceType &gt; const &amp;var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::diff </td>
          <td>(</td>
          <td class="paramtype">rt_binary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_variable&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the derivative of the provided runtime binary expression. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>e</em>&nbsp;</td><td>The expression to be differentiated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The differentiation variable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a31ee8f1d64581ca114dc0fe3d2802a53"></a><!-- doxytag: member="viennamath::diff" ref="a31ee8f1d64581ca114dc0fe3d2802a53" args="(rt_unary_expr&lt; InterfaceType &gt; const &amp;e, rt_variable&lt; InterfaceType &gt; const &amp;var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::diff </td>
          <td>(</td>
          <td class="paramtype">rt_unary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_variable&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the derivative of the provided runtime unary expression. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>e</em>&nbsp;</td><td>The expression to be differentiated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The differentiation variable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6bacb9c25981a59bde285ae251411679"></a><!-- doxytag: member="viennamath::diff" ref="a6bacb9c25981a59bde285ae251411679" args="(rt_expr&lt; InterfaceType &gt; const &amp;e, rt_variable&lt; InterfaceType &gt; const &amp;var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::diff </td>
          <td>(</td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_variable&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the derivative of the provided runtime expression wrapper. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>e</em>&nbsp;</td><td>The expression to be differentiated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The differentiation variable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac419e6ca9f4617f8a067b76425b50842"></a><!-- doxytag: member="viennamath::diff" ref="ac419e6ca9f4617f8a067b76425b50842" args="(rt_binary_expr&lt; InterfaceType &gt; const &amp;e, ct_variable&lt; id &gt; const &amp;var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::diff </td>
          <td>(</td>
          <td class="paramtype">rt_binary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the derivative of the provided runtime binary expression. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>e</em>&nbsp;</td><td>The expression to be differentiated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The differentiation variable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9c0967e60ffcbc81c111f9915cd1c2e2"></a><!-- doxytag: member="viennamath::diff" ref="a9c0967e60ffcbc81c111f9915cd1c2e2" args="(rt_unary_expr&lt; InterfaceType &gt; const &amp;e, ct_variable&lt; id &gt; const &amp;var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::diff </td>
          <td>(</td>
          <td class="paramtype">rt_unary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the derivative of the provided runtime unary expression. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>e</em>&nbsp;</td><td>The expression to be differentiated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The differentiation variable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8e239d8c7d96460390e42e716dc38de9"></a><!-- doxytag: member="viennamath::diff" ref="a8e239d8c7d96460390e42e716dc38de9" args="(rt_expr&lt; InterfaceType &gt; const &amp;e, ct_variable&lt; id &gt; const &amp;var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::diff </td>
          <td>(</td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the derivative of the provided runtime expression wrapper. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>e</em>&nbsp;</td><td>The expression to be differentiated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>The differentiation variable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeee9a608db41f2ba50043818657b49d0"></a><!-- doxytag: member="viennamath::diff" ref="aeee9a608db41f2ba50043818657b49d0" args="(rt_function_symbol&lt; InterfaceType &gt; const &amp;other, rt_variable&lt; InterfaceType &gt; const &amp;var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::diff </td>
          <td>(</td>
          <td class="paramtype">rt_function_symbol&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_variable&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a symbolic representation of a differentiated function. </p>

</div>
</div>
<a class="anchor" id="a297fafc1ec5b442c97b6574863c33569"></a><!-- doxytag: member="viennamath::diff" ref="a297fafc1ec5b442c97b6574863c33569" args="(rt_function_symbol&lt; InterfaceType &gt; const &amp;other, ct_variable&lt; id &gt; const &amp;var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::diff </td>
          <td>(</td>
          <td class="paramtype">rt_function_symbol&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a symbolic representation of a differentiated function. </p>

</div>
</div>
<a class="anchor" id="afba60fe763204bd93cbc06f374415adb"></a><!-- doxytag: member="viennamath::diff" ref="afba60fe763204bd93cbc06f374415adb" args="(typename InterfaceType::numeric_type value, rt_variable&lt; InterfaceType &gt; const &amp;var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt;typename InterfaceType::numeric_type&gt; viennamath::diff </td>
          <td>(</td>
          <td class="paramtype">typename InterfaceType::numeric_type&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_variable&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload for the derivative of a function. </p>

</div>
</div>
<a class="anchor" id="a00a4befbb56c300bc567ecb9957025e7"></a><!-- doxytag: member="viennamath::diff" ref="a00a4befbb56c300bc567ecb9957025e7" args="(rt_constant&lt; OtherScalarType, InterfaceType &gt; const &amp;c, rt_variable&lt; InterfaceType &gt; const &amp;var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt;typename InterfaceType::numeric_type&gt; viennamath::diff </td>
          <td>(</td>
          <td class="paramtype">rt_constant&lt; OtherScalarType, InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_variable&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload for the derivative of a ViennaMath runtime constant. </p>

</div>
</div>
<a class="anchor" id="a8d2887dc545d3557aac5cdd776408bfd"></a><!-- doxytag: member="viennamath::diff" ref="a8d2887dc545d3557aac5cdd776408bfd" args="(rt_variable&lt; InterfaceType &gt; const &amp;c, rt_variable&lt; InterfaceType &gt; const &amp;var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt;typename InterfaceType::numeric_type&gt; viennamath::diff </td>
          <td>(</td>
          <td class="paramtype">rt_variable&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_variable&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload for computing the derivative of a runtime variable. </p>

</div>
</div>
<a class="anchor" id="a3a61a081f98d587311e238af776275e7"></a><!-- doxytag: member="viennamath::diff" ref="a3a61a081f98d587311e238af776275e7" args="(ExpressionType const &amp;c, ct_variable&lt; id &gt; const &amp;var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennamath_1_1result__of_1_1diff.html">result_of::diff</a>&lt;ExpressionType, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt;id&gt; &gt;::result_type viennamath::diff </td>
          <td>(</td>
          <td class="paramtype">ExpressionType const &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The user function for differentiation of a compile time expression with respect to a compile time variable. </p>

</div>
</div>
<a class="anchor" id="a0d86fa7b07f826fd1da058c99bbe5c8b"></a><!-- doxytag: member="viennamath::diff_impl" ref="a0d86fa7b07f826fd1da058c99bbe5c8b" args="(const InterfaceType *e, op_cos&lt; NumericT &gt;, const InterfaceType *diff_var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType * diff_impl </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">op_cos&lt; NumericT &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>diff_var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Differentation of cos(e), where e is an expression. </p>

</div>
</div>
<a class="anchor" id="a2765cdcc5145a1080b085750334a9064"></a><!-- doxytag: member="viennamath::diff_impl" ref="a2765cdcc5145a1080b085750334a9064" args="(const InterfaceType *e, op_tan&lt; NumericT &gt;, const InterfaceType *diff_var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType * diff_impl </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">op_tan&lt; NumericT &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>diff_var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Differentation of tan(e), where e is an expression. </p>

</div>
</div>
<a class="anchor" id="a43f146b14bccaeeb99e20f5c0c3fe2cc"></a><!-- doxytag: member="viennamath::diff_impl" ref="a43f146b14bccaeeb99e20f5c0c3fe2cc" args="(const InterfaceType *e, op_fabs&lt; NumericT &gt;, const InterfaceType *diff_var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType * diff_impl </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">op_fabs&lt; NumericT &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>diff_var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the differentation of |e|, where e is an expression. Since the modulus is not differentiable everywhere, an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a7c1ea7f64c46f85bdee5a5eea2fd79a4"></a><!-- doxytag: member="viennamath::diff_impl" ref="a7c1ea7f64c46f85bdee5a5eea2fd79a4" args="(const InterfaceType *e, op_sqrt&lt; NumericT &gt;, const InterfaceType *diff_var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType * diff_impl </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">op_sqrt&lt; NumericT &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>diff_var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the differentation of \sqrt{e}, where e is an expression. </p>

</div>
</div>
<a class="anchor" id="a08dbc843d6877c0821b8cce7d30c8ffe"></a><!-- doxytag: member="viennamath::diff_impl" ref="a08dbc843d6877c0821b8cce7d30c8ffe" args="(const InterfaceType *e, op_log&lt; NumericT &gt;, const InterfaceType *diff_var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType * diff_impl </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">op_log&lt; NumericT &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>diff_var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the differentation of ln(e), where e is an expression. </p>

</div>
</div>
<a class="anchor" id="adb58aa5f11273da6486e4581959ea13a"></a><!-- doxytag: member="viennamath::diff_impl" ref="adb58aa5f11273da6486e4581959ea13a" args="(const InterfaceType *e, op_log10&lt; NumericT &gt;, const InterfaceType *diff_var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType * diff_impl </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">op_log10&lt; NumericT &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>diff_var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the differentation of log10(e), where e is an expression. </p>
<p>Uses the rule (log10(f))' = f' / (ln(f) * ln(10)) </p>

</div>
</div>
<a class="anchor" id="a1f335a870411768416d7711e16b11c30"></a><!-- doxytag: member="viennamath::diff_impl" ref="a1f335a870411768416d7711e16b11c30" args="(const InterfaceType *e, op_gradient&lt; NumericT &gt;, const InterfaceType *diff_var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType* viennamath::diff_impl </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">op_gradient&lt; NumericT &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>diff_var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the differentation of a gradient. This is currently not supported, thus an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="aad557e872cac4a1385b7e6317f2bbc02"></a><!-- doxytag: member="viennamath::diff_impl" ref="aad557e872cac4a1385b7e6317f2bbc02" args="(const InterfaceType *e, op_divergence&lt; NumericT &gt;, const InterfaceType *diff_var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType* viennamath::diff_impl </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">op_divergence&lt; NumericT &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>diff_var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the differentation of the divergence operator. This is currently not supported, thus an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="aa51eddfe0bc23018878703f5e5d0f622"></a><!-- doxytag: member="viennamath::diff_impl" ref="aa51eddfe0bc23018878703f5e5d0f622" args="(const InterfaceType *e, op_partial_deriv&lt; NumericT &gt;, const InterfaceType *diff_var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType* viennamath::diff_impl </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">op_partial_deriv&lt; NumericT &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>diff_var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the differentation of a partial derivative. This is currently not supported, thus an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a89e5e3980bfaf17936d92ada9594d611"></a><!-- doxytag: member="viennamath::diff_impl" ref="a89e5e3980bfaf17936d92ada9594d611" args="(const InterfaceType *e, op_rt_integral&lt; InterfaceType &gt;, const InterfaceType *diff_var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType* viennamath::diff_impl </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">op_rt_integral&lt; InterfaceType &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>diff_var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the differentation of an integral. This is currently not supported, thus an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a664a62b90f283761c819f8cccc56c5ae"></a><!-- doxytag: member="viennamath::diff_impl" ref="a664a62b90f283761c819f8cccc56c5ae" args="(const InterfaceType *e, op_rt_symbolic_integral&lt; InterfaceType &gt;, const InterfaceType *diff_var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType* viennamath::diff_impl </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">op_rt_symbolic_integral&lt; InterfaceType &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>diff_var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the differentation of an integral with symbolic integration domain. This is currently not supported, thus an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="ab2aded2fd0a5e180147b4e571389ae0a"></a><!-- doxytag: member="viennamath::diff_impl" ref="ab2aded2fd0a5e180147b4e571389ae0a" args="(const InterfaceType *lhs, op_plus&lt; NumericT &gt;, const InterfaceType *rhs, const InterfaceType *diff_var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType * diff_impl </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">op_plus&lt; NumericT &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>diff_var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the differentation of e1 + e1, where e1 and e2 are expressions. </p>

</div>
</div>
<a class="anchor" id="a61e5fca5087550574135b593cfdfce59"></a><!-- doxytag: member="viennamath::diff_impl" ref="a61e5fca5087550574135b593cfdfce59" args="(const InterfaceType *lhs, op_minus&lt; NumericT &gt;, const InterfaceType *rhs, const InterfaceType *diff_var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType * diff_impl </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">op_minus&lt; NumericT &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>diff_var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the differentation of e1 - e1, where e1 and e2 are expressions. </p>

</div>
</div>
<a class="anchor" id="a72280e28b99d3acf307d9cd2d07ffa36"></a><!-- doxytag: member="viennamath::diff_impl" ref="a72280e28b99d3acf307d9cd2d07ffa36" args="(const InterfaceType *lhs, op_mult&lt; NumericT &gt;, const InterfaceType *rhs, const InterfaceType *diff_var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType * diff_impl </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">op_mult&lt; NumericT &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>diff_var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the differentation of e1 * e1, where e1 and e2 are expressions. </p>

</div>
</div>
<a class="anchor" id="a145f22648aab309a9196fc2f5401a0c6"></a><!-- doxytag: member="viennamath::diff_impl" ref="a145f22648aab309a9196fc2f5401a0c6" args="(const InterfaceType *lhs, op_div&lt; NumericT &gt;, const InterfaceType *rhs, const InterfaceType *diff_var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType * diff_impl </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">op_div&lt; NumericT &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>diff_var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the differentation of e1 / e1, where e1 and e2 are expressions. </p>

</div>
</div>
<a class="anchor" id="af046a1c2c0925c4abcebff160ccd9b74"></a><!-- doxytag: member="viennamath::diff_impl" ref="af046a1c2c0925c4abcebff160ccd9b74" args="(const InterfaceType *e, op_id&lt; NumericT &gt;, const InterfaceType *diff_var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType * diff_impl </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">op_id&lt; NumericT &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>diff_var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Differentation of a unary expression containing identity. </p>

</div>
</div>
<a class="anchor" id="ac28c355c4b8937f04d3029c0072c6aa5"></a><!-- doxytag: member="viennamath::diff_impl" ref="ac28c355c4b8937f04d3029c0072c6aa5" args="(const InterfaceType *e, op_exp&lt; NumericT &gt;, const InterfaceType *diff_var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType * diff_impl </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">op_exp&lt; NumericT &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>diff_var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Differentation of exp(e), where e is an expression. </p>

</div>
</div>
<a class="anchor" id="ad5d7fe3c536f80a4afe29d2a5a136e97"></a><!-- doxytag: member="viennamath::diff_impl" ref="ad5d7fe3c536f80a4afe29d2a5a136e97" args="(const InterfaceType *e, op_sin&lt; NumericT &gt;, const InterfaceType *diff_var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType * diff_impl </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">op_sin&lt; NumericT &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>diff_var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Differentation of sin(e), where e is an expression. </p>

</div>
</div>
<a class="anchor" id="a7aae8ad176b5963f7f09ca1316ee93e5"></a><!-- doxytag: member="viennamath::div" ref="a7aae8ad176b5963f7f09ca1316ee93e5" args="(rt_expr&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::div </td>
          <td>(</td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the divergence function for a ViennaMath runtime expression wrapper. </p>

</div>
</div>
<a class="anchor" id="a77d3b61ee7c51c9915eb9725acb977e5"></a><!-- doxytag: member="viennamath::div" ref="a77d3b61ee7c51c9915eb9725acb977e5" args="(rt_unary_expr&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::div </td>
          <td>(</td>
          <td class="paramtype">rt_unary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the divergence function for a ViennaMath runtime unary expression. </p>

</div>
</div>
<a class="anchor" id="a3a7ffb1808fe0426557b7e89b8e2affc"></a><!-- doxytag: member="viennamath::div" ref="a3a7ffb1808fe0426557b7e89b8e2affc" args="(rt_binary_expr&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::div </td>
          <td>(</td>
          <td class="paramtype">rt_binary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the divergence function for a ViennaMath runtime binary expression. </p>

</div>
</div>
<a class="anchor" id="aa2c45c85d6f6c3b49926444879bb2655"></a><!-- doxytag: member="viennamath::div" ref="aa2c45c85d6f6c3b49926444879bb2655" args="(rt_function_symbol&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::div </td>
          <td>(</td>
          <td class="paramtype">rt_function_symbol&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the divergence function for a ViennaMath runtime function symbol. </p>

</div>
</div>
<a class="anchor" id="a2ba179781678a0025cb911124c786d06"></a><!-- doxytag: member="viennamath::drop_dependent_terms" ref="a2ba179781678a0025cb911124c786d06" args="(FactorType const &amp;f, ExpressionType const &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennamath_1_1result__of_1_1drop__dependent__terms.html">result_of::drop_dependent_terms</a>&lt;FactorType, ExpressionType&gt;::type viennamath::drop_dependent_terms </td>
          <td>(</td>
          <td class="paramtype">FactorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExpressionType const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Main user function for dropping all terms from an expression which depend on a certain variable or expression. </p>
<p>Technically, this is accomplished by replacing the respective factor by zero</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>The factor which should be set to zero </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>e</em>&nbsp;</td><td>The full expression from which the dependent terms should be dropped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc71b02c9631188dfd54d127ab2fabd4"></a><!-- doxytag: member="viennamath::eval" ref="adc71b02c9631188dfd54d127ab2fabd4" args="(ExpressionType const &amp;e, VectorType const &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennamath_1_1enable__if.html">enable_if</a>&lt;<a class="el" href="structviennamath_1_1result__of_1_1is__ct__evaluable.html">result_of::is_ct_evaluable</a>&lt;ExpressionType&gt;::value &amp;&amp; <a class="el" href="structviennamath_1_1result__of_1_1is__ct__vector.html">result_of::is_ct_vector</a>&lt;VectorType&gt;::value, <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>&gt;::type viennamath::eval </td>
          <td>(</td>
          <td class="paramtype">ExpressionType const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Main user function for the evaluation of a compiletime expression at compiletime. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>e</em>&nbsp;</td><td>The compiletime expression </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>A compiletime vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25f3d5f97481e938b9bede810d3d998f"></a><!-- doxytag: member="viennamath::eval" ref="a25f3d5f97481e938b9bede810d3d998f" args="(default_numeric_type value, VectorType const &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> viennamath::eval </td>
          <td>(</td>
          <td class="paramtype">default_numeric_type&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluation of a numeric constant at a vector: Return the constant. </p>

</div>
</div>
<a class="anchor" id="aa367b9783bb88e37367156901310030e"></a><!-- doxytag: member="viennamath::eval" ref="aa367b9783bb88e37367156901310030e" args="(long value, VectorType const &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long viennamath::eval </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluation of a long integer at a vector: Return the integer. </p>

</div>
</div>
<a class="anchor" id="a2697bfce5d19ac98b3ec55e5eb44b417"></a><!-- doxytag: member="viennamath::eval" ref="a2697bfce5d19ac98b3ec55e5eb44b417" args="(rt_constant&lt; T, InterfaceType &gt; c, VectorType const &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType::numeric_type viennamath::eval </td>
          <td>(</td>
          <td class="paramtype">rt_constant&lt; T, InterfaceType &gt;&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluation of a runtime constant at a vector: Return the runtime constant. </p>

</div>
</div>
<a class="anchor" id="ae063e8264a95daa4f729dc3f94d22263"></a><!-- doxytag: member="viennamath::eval" ref="ae063e8264a95daa4f729dc3f94d22263" args="(rt_expr&lt; InterfaceType &gt; e, VectorType const &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType::numeric_type viennamath::eval </td>
          <td>(</td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluation of a ViennaMath expression wrapper. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>e</em>&nbsp;</td><td>The expression wrapper </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Either a single number (typically of type double) or a vector type offering bracket-access </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a81109d65dd902fdaf8a005b92cc5f8d6"></a><!-- doxytag: member="viennamath::eval" ref="a81109d65dd902fdaf8a005b92cc5f8d6" args="(rt_binary_expr&lt; InterfaceType &gt; e, VectorType const &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType::numeric_type viennamath::eval </td>
          <td>(</td>
          <td class="paramtype">rt_binary_expr&lt; InterfaceType &gt;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluation of a ViennaMath binary expression. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>e</em>&nbsp;</td><td>The expression wrapper </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Either a single number (typically of type double) or a vector type offering bracket-access </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a82fcef91453e4c79b810bbd8732388af"></a><!-- doxytag: member="viennamath::eval" ref="a82fcef91453e4c79b810bbd8732388af" args="(rt_unary_expr&lt; InterfaceType &gt; e, VectorType const &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType::numeric_type viennamath::eval </td>
          <td>(</td>
          <td class="paramtype">rt_unary_expr&lt; InterfaceType &gt;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluation of a ViennaMath unary expression. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>e</em>&nbsp;</td><td>The expression wrapper </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Either a single number (typically of type double) or a vector type offering bracket-access </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a15b3925e322b066bceb1ca58fdb7a6e7"></a><!-- doxytag: member="viennamath::eval" ref="a15b3925e322b066bceb1ca58fdb7a6e7" args="(rt_variable&lt; InterfaceType &gt; e, VectorType const &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType::numeric_type viennamath::eval </td>
          <td>(</td>
          <td class="paramtype">rt_variable&lt; InterfaceType &gt;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluation of a ViennaMath variable. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>e</em>&nbsp;</td><td>The expression wrapper </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Either a single number (typically of type double) or a vector type offering bracket-access </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5c9885515a49186ecb6ee21c93bf7701"></a><!-- doxytag: member="viennamath::eval" ref="a5c9885515a49186ecb6ee21c93bf7701" args="(ct_binary_expr&lt; LHS, OP, RHS &gt; ex, VectorType const &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennamath_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structviennamath_1_1result__of_1_1is__ct__evaluable.html">result_of::is_ct_evaluable</a>&lt; <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;LHS, OP, RHS&gt; &gt;::value || !<a class="el" href="structviennamath_1_1result__of_1_1is__ct__vector.html">result_of::is_ct_vector</a>&lt;VectorType&gt;::value, <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>&gt;::type viennamath::eval </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; LHS, OP, RHS &gt;&nbsp;</td>
          <td class="paramname"> <em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluation of a ViennaMath compiletime binary expression using a runtime vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ex</em>&nbsp;</td><td>The compiletime binary expression </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Either a single number (typically of type double) or a vector type offering bracket-access (e.g. std::vector&lt;&gt;) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b3443e4253490ad4f06590d551a7098"></a><!-- doxytag: member="viennamath::eval" ref="a6b3443e4253490ad4f06590d551a7098" args="(ct_unary_expr&lt; LHS, OP &gt; ex, VectorType const &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennamath_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structviennamath_1_1result__of_1_1is__ct__evaluable.html">result_of::is_ct_evaluable</a>&lt; <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt;LHS, OP&gt; &gt;::value || !<a class="el" href="structviennamath_1_1result__of_1_1is__ct__vector.html">result_of::is_ct_vector</a>&lt;VectorType&gt;::value, <a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>&gt;::type viennamath::eval </td>
          <td>(</td>
          <td class="paramtype">ct_unary_expr&lt; LHS, OP &gt;&nbsp;</td>
          <td class="paramname"> <em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluation of a ViennaMath compiletime unary expression using a runtime vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ex</em>&nbsp;</td><td>The compiletime unary expression </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Either a single number (typically of type double) or a vector type offering bracket-access (e.g. std::vector&lt;&gt;) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab0530d94cd91a922373ded31ce59046e"></a><!-- doxytag: member="viennamath::eval" ref="ab0530d94cd91a922373ded31ce59046e" args="(ct_constant&lt; value &gt; c, VectorType const &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> viennamath::eval </td>
          <td>(</td>
          <td class="paramtype">ct_constant&lt; value &gt;&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluation of a ViennaMath compiletime constant using a runtime vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The compiletime constant </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Either a single number (typically of type double) or a vector type offering bracket-access (e.g. std::vector&lt;&gt;) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add057cfdd00564ef57e8dc6bf71e2f8d"></a><!-- doxytag: member="viennamath::eval" ref="add057cfdd00564ef57e8dc6bf71e2f8d" args="(ct_variable&lt; id &gt; c, VectorType const &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> viennamath::eval </td>
          <td>(</td>
          <td class="paramtype">ct_variable&lt; id &gt;&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluation of a ViennaMath compiletime variable using a runtime vector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The compiletime variable </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>Either a single number (typically of type double) or a vector type offering bracket-access (e.g. std::vector&lt;&gt;) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a739cbee44c2b4c272312743453ebbb2d"></a><!-- doxytag: member="viennamath::eval" ref="a739cbee44c2b4c272312743453ebbb2d" args="(ct_variable&lt; id &gt; c, ct_vector_1&lt; T0 &gt; const &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> viennamath::eval </td>
          <td>(</td>
          <td class="paramtype">ct_variable&lt; id &gt;&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_vector_1&lt; T0 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluation of a ViennaMath compiletime variable using a compiletime vector with one entry. </p>

</div>
</div>
<a class="anchor" id="aeb2c47237b0f5997f695f40bdc49fb8b"></a><!-- doxytag: member="viennamath::eval" ref="aeb2c47237b0f5997f695f40bdc49fb8b" args="(ct_variable&lt; id &gt; c, ct_vector_2&lt; T0, T1 &gt; const &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> viennamath::eval </td>
          <td>(</td>
          <td class="paramtype">ct_variable&lt; id &gt;&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_vector_2&lt; T0, T1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluation of a ViennaMath compiletime variable using a compiletime vector with two entries. </p>

</div>
</div>
<a class="anchor" id="a112b8368ef6c6825946c30d010088dff"></a><!-- doxytag: member="viennamath::eval" ref="a112b8368ef6c6825946c30d010088dff" args="(ct_variable&lt; id &gt; c, ct_vector_3&lt; T0, T1, T2 &gt; const &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> viennamath::eval </td>
          <td>(</td>
          <td class="paramtype">ct_variable&lt; id &gt;&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_vector_3&lt; T0, T1, T2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluation of a ViennaMath compiletime variable using a compiletime vector with three entries. </p>

</div>
</div>
<a class="anchor" id="aebc9979a5a89c77c58d3648a2dbb218e"></a><!-- doxytag: member="viennamath::exp" ref="aebc9979a5a89c77c58d3648a2dbb218e" args="(rt_constant&lt; NumericT, InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::exp </td>
          <td>(</td>
          <td class="paramtype">rt_constant&lt; NumericT, InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the exponential function for a ViennaMath runtime constant. </p>

</div>
</div>
<a class="anchor" id="a987cd95708aed4f6ac167110874d4a2c"></a><!-- doxytag: member="viennamath::exp" ref="a987cd95708aed4f6ac167110874d4a2c" args="(rt_variable&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::exp </td>
          <td>(</td>
          <td class="paramtype">rt_variable&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the exponential function for a ViennaMath runtime variable. </p>

</div>
</div>
<a class="anchor" id="ad90b3035ce745a93c453bbb7d96ae46b"></a><!-- doxytag: member="viennamath::exp" ref="ad90b3035ce745a93c453bbb7d96ae46b" args="(ct_variable&lt; id &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> viennamath::exp </td>
          <td>(</td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the exponential function for a ViennaMath compiletime variable. </p>

</div>
</div>
<a class="anchor" id="ab026d3b9ba9bcd69872a1344b1deb337"></a><!-- doxytag: member="viennamath::exp" ref="ab026d3b9ba9bcd69872a1344b1deb337" args="(ct_binary_expr&lt; LHS, OP, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> viennamath::exp </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; LHS, OP, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the exponential function for a ViennaMath compiletime binary expression. </p>

</div>
</div>
<a class="anchor" id="a2c32cb661a87fef8e39deeb0e925bc0b"></a><!-- doxytag: member="viennamath::exp" ref="a2c32cb661a87fef8e39deeb0e925bc0b" args="(ct_unary_expr&lt; LHS, OP &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> viennamath::exp </td>
          <td>(</td>
          <td class="paramtype">ct_unary_expr&lt; LHS, OP &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the exponential function for a ViennaMath compiletime unary expression. </p>

</div>
</div>
<a class="anchor" id="a1a9b4ef02365b4587acb152fd08d6da6"></a><!-- doxytag: member="viennamath::exp" ref="a1a9b4ef02365b4587acb152fd08d6da6" args="(rt_expr&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::exp </td>
          <td>(</td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the exponential function for a ViennaMath runtime expression wrapper. </p>

</div>
</div>
<a class="anchor" id="a61b858b450e456302f721b4ff282d9e3"></a><!-- doxytag: member="viennamath::exp" ref="a61b858b450e456302f721b4ff282d9e3" args="(rt_binary_expr&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::exp </td>
          <td>(</td>
          <td class="paramtype">rt_binary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the exponential function for a ViennaMath runtime binary expression. </p>

</div>
</div>
<a class="anchor" id="ae659107e853ebcbb55407bb153a39e47"></a><!-- doxytag: member="viennamath::expand" ref="ae659107e853ebcbb55407bb153a39e47" args="(ExpressionType const &amp;type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennamath_1_1result__of_1_1expand.html">result_of::expand</a>&lt;ExpressionType&gt;::type viennamath::expand </td>
          <td>(</td>
          <td class="paramtype">ExpressionType const &amp;&nbsp;</td>
          <td class="paramname"> <em>type</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>User function for expanding a compile time expression. </p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ExpressionType</em>&nbsp;</td><td>The compiletime expression for expansion </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa3594f0a2c482ac86fd8ec8873d3c3e7"></a><!-- doxytag: member="viennamath::fabs" ref="aa3594f0a2c482ac86fd8ec8873d3c3e7" args="(rt_constant&lt; NumericT, InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::fabs </td>
          <td>(</td>
          <td class="paramtype">rt_constant&lt; NumericT, InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the modulus function for a ViennaMath runtime constant. </p>

</div>
</div>
<a class="anchor" id="a2ede41bcefb44408201a88dbcbe0cfb2"></a><!-- doxytag: member="viennamath::fabs" ref="a2ede41bcefb44408201a88dbcbe0cfb2" args="(rt_variable&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::fabs </td>
          <td>(</td>
          <td class="paramtype">rt_variable&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the modulus function for a ViennaMath runtime variable. </p>

</div>
</div>
<a class="anchor" id="a6f44a9f96dd780601ea180516815f502"></a><!-- doxytag: member="viennamath::fabs" ref="a6f44a9f96dd780601ea180516815f502" args="(ct_variable&lt; id &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> viennamath::fabs </td>
          <td>(</td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the modulus function for a ViennaMath compiletime variable. </p>

</div>
</div>
<a class="anchor" id="ae076c0df57cbd72ce3bdfee7e6a7d213"></a><!-- doxytag: member="viennamath::fabs" ref="ae076c0df57cbd72ce3bdfee7e6a7d213" args="(ct_binary_expr&lt; LHS, OP, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> viennamath::fabs </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; LHS, OP, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the modulus function for a ViennaMath compiletime binary expression. </p>

</div>
</div>
<a class="anchor" id="a7a237c3e4d8c86f74dedff3d35f20f4a"></a><!-- doxytag: member="viennamath::fabs" ref="a7a237c3e4d8c86f74dedff3d35f20f4a" args="(ct_unary_expr&lt; LHS, OP &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> viennamath::fabs </td>
          <td>(</td>
          <td class="paramtype">ct_unary_expr&lt; LHS, OP &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the modulus function for a ViennaMath compiletime unary expression. </p>

</div>
</div>
<a class="anchor" id="a6a178d09db8cca450fb30c34e72d94e8"></a><!-- doxytag: member="viennamath::fabs" ref="a6a178d09db8cca450fb30c34e72d94e8" args="(rt_unary_expr&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::fabs </td>
          <td>(</td>
          <td class="paramtype">rt_unary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the modulus function for a ViennaMath runtime unary expression. </p>

</div>
</div>
<a class="anchor" id="afea99b6d77391cfb133b5453af718527"></a><!-- doxytag: member="viennamath::fabs" ref="afea99b6d77391cfb133b5453af718527" args="(rt_binary_expr&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::fabs </td>
          <td>(</td>
          <td class="paramtype">rt_binary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the modulus function for a ViennaMath runtime binary expression. </p>

</div>
</div>
<a class="anchor" id="a9b4616e8a2666125465ce772af757368"></a><!-- doxytag: member="viennamath::fabs" ref="a9b4616e8a2666125465ce772af757368" args="(rt_expr&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::fabs </td>
          <td>(</td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the modulus function for a ViennaMath runtime expression wrapper. </p>

</div>
</div>
<a class="anchor" id="af127bad7291f5b91a873810a374ea821"></a><!-- doxytag: member="viennamath::get_from_vector" ref="af127bad7291f5b91a873810a374ea821" args="(VectorType const &amp;vec, id_type i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorType::value_type viennamath::get_from_vector </td>
          <td>(</td>
          <td class="paramtype">VectorType const &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">id_type&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic wrapper function for accessing the i-th entry of a vector. Provides a uniform interface for compile-time and run-time vectors. </p>
<p>This is the default implementation. </p>

</div>
</div>
<a class="anchor" id="a563ce2927de883d4e75c673b042604e7"></a><!-- doxytag: member="viennamath::get_from_vector" ref="a563ce2927de883d4e75c673b042604e7" args="(ct_vector_1&lt; T1 &gt; const &amp;vec, id_type i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> viennamath::get_from_vector </td>
          <td>(</td>
          <td class="paramtype">ct_vector_1&lt; T1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">id_type&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic wrapper function for accessing the i-th entry of a vector. Provides a uniform interface for compile-time and run-time vectors. </p>
<p>This is the overload for a compile-time vector of size 1 </p>

</div>
</div>
<a class="anchor" id="aa7c90f77e052d9583cac44bc049624ce"></a><!-- doxytag: member="viennamath::get_from_vector" ref="aa7c90f77e052d9583cac44bc049624ce" args="(ct_vector_2&lt; T1, T2 &gt; const &amp;vec, id_type i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> viennamath::get_from_vector </td>
          <td>(</td>
          <td class="paramtype">ct_vector_2&lt; T1, T2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">id_type&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic wrapper function for accessing the i-th entry of a vector. Provides a uniform interface for compile-time and run-time vectors. </p>
<p>This is the overload for a compile-time vector of size 2 </p>

</div>
</div>
<a class="anchor" id="ac185fae0345a308e5125547007192308"></a><!-- doxytag: member="viennamath::get_from_vector" ref="ac185fae0345a308e5125547007192308" args="(ct_vector_3&lt; T1, T2, T3 &gt; const &amp;vec, id_type i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a> viennamath::get_from_vector </td>
          <td>(</td>
          <td class="paramtype">ct_vector_3&lt; T1, T2, T3 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">id_type&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic wrapper function for accessing the i-th entry of a vector. Provides a uniform interface for compile-time and run-time vectors. </p>
<p>This is the overload for a compile-time vector of size 3 </p>

</div>
</div>
<a class="anchor" id="aa7a9cb779ba7c6e763d1a94cb3d04111"></a><!-- doxytag: member="viennamath::grad" ref="aa7a9cb779ba7c6e763d1a94cb3d04111" args="(rt_unary_expr&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::grad </td>
          <td>(</td>
          <td class="paramtype">rt_unary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the gradient function for a ViennaMath runtime unary expression. </p>

</div>
</div>
<a class="anchor" id="a77e82fadba1cd6372147e8ae28082908"></a><!-- doxytag: member="viennamath::grad" ref="a77e82fadba1cd6372147e8ae28082908" args="(rt_function_symbol&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::grad </td>
          <td>(</td>
          <td class="paramtype">rt_function_symbol&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the gradient function for a ViennaMath runtime function symbol. </p>

</div>
</div>
<a class="anchor" id="a17319bad30cc7bb804f34bfc1df2c773"></a><!-- doxytag: member="viennamath::inplace_simplify" ref="a17319bad30cc7bb804f34bfc1df2c773" args="(rt_expr&lt; InterfaceType &gt; &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennamath::inplace_simplify </td>
          <td>(</td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Simplifies an expression. Directly manipulates the provided expression. </p>

</div>
</div>
<a class="anchor" id="accae5edbf08f26762a753808fb37cb03"></a><!-- doxytag: member="viennamath::inplace_simplify" ref="accae5edbf08f26762a753808fb37cb03" args="(rt_unary_expr&lt; InterfaceType &gt; &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennamath::inplace_simplify </td>
          <td>(</td>
          <td class="paramtype">rt_unary_expr&lt; InterfaceType &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Simplifies an expression. Directly manipulates the provided expression. </p>

</div>
</div>
<a class="anchor" id="a0514b3a86d63537776a8c06d5064305a"></a><!-- doxytag: member="viennamath::inplace_simplify" ref="a0514b3a86d63537776a8c06d5064305a" args="(rt_binary_expr&lt; InterfaceType &gt; &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennamath::inplace_simplify </td>
          <td>(</td>
          <td class="paramtype">rt_binary_expr&lt; InterfaceType &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Simplifies an expression. Directly manipulates the provided expression. </p>

</div>
</div>
<a class="anchor" id="ab2bb6d0b7464765a9921c836412577ff"></a><!-- doxytag: member="viennamath::inplace_simplify" ref="ab2bb6d0b7464765a9921c836412577ff" args="(T &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void viennamath::inplace_simplify </td>
          <td>(</td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Simplifies an expression. Directly manipulates the provided expression. </p>

</div>
</div>
<a class="anchor" id="a648b715f23efe54dad4ccec705ad6a44"></a><!-- doxytag: member="viennamath::integral" ref="a648b715f23efe54dad4ccec705ad6a44" args="(rt_interval&lt; InterfaceType &gt; const &amp;interv, rt_expr&lt; InterfaceType &gt; const &amp;integrand, rt_variable&lt; InterfaceType &gt; const &amp;var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::integral </td>
          <td>(</td>
          <td class="paramtype">rt_interval&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>interv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>integrand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_variable&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an expression encoding the integral of an expression with respect to a runtime variable over a certain interval. </p>

</div>
</div>
<a class="anchor" id="a80fb54a6b2bafb1589bea4feb7c46b23"></a><!-- doxytag: member="viennamath::integral" ref="a80fb54a6b2bafb1589bea4feb7c46b23" args="(rt_interval&lt; InterfaceType &gt; const &amp;interv, rt_expr&lt; InterfaceType &gt; const &amp;integrand, ct_variable&lt; id &gt; const &amp;var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::integral </td>
          <td>(</td>
          <td class="paramtype">rt_interval&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>interv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>integrand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an expression encoding the integral of an expression with respect to a compiletime variable over a certain interval. </p>

</div>
</div>
<a class="anchor" id="aaef5b7023eb2629381e53a03bc968bf0"></a><!-- doxytag: member="viennamath::integral" ref="aaef5b7023eb2629381e53a03bc968bf0" args="(rt_interval&lt; InterfaceType &gt; const &amp;interv, rt_binary_expr&lt; InterfaceType &gt; const &amp;integrand, ct_variable&lt; id &gt; const &amp;var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::integral </td>
          <td>(</td>
          <td class="paramtype">rt_interval&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>interv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_binary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>integrand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an expression encoding the integral of a binary expression with respect to a compiletime variable over a certain interval. </p>

</div>
</div>
<a class="anchor" id="ac4d18932f682c17ac5a7bc707990784e"></a><!-- doxytag: member="viennamath::integral" ref="ac4d18932f682c17ac5a7bc707990784e" args="(rt_symbolic_interval&lt; InterfaceType &gt; const &amp;interv, rt_expr&lt; InterfaceType &gt; const &amp;integrand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::integral </td>
          <td>(</td>
          <td class="paramtype">rt_symbolic_interval&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>interv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>integrand</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Integral generator function taking a symbolic interval and a runtime expression wrapper for the integrand. </p>

</div>
</div>
<a class="anchor" id="a3bbcb625b53a61ca3f6e549084f7bcd9"></a><!-- doxytag: member="viennamath::integral" ref="a3bbcb625b53a61ca3f6e549084f7bcd9" args="(rt_symbolic_interval&lt; InterfaceType &gt; const &amp;interv, rt_binary_expr&lt; InterfaceType &gt; const &amp;integrand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::integral </td>
          <td>(</td>
          <td class="paramtype">rt_symbolic_interval&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>interv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_binary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>integrand</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Integral generator function taking a symbolic interval and a runtime binary expression for the integrand. </p>

</div>
</div>
<a class="anchor" id="ac643593961a6c590ab0d5de202a9491b"></a><!-- doxytag: member="viennamath::integral" ref="ac643593961a6c590ab0d5de202a9491b" args="(rt_symbolic_interval&lt; InterfaceType &gt; const &amp;interv, rt_unary_expr&lt; InterfaceType &gt; const &amp;integrand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::integral </td>
          <td>(</td>
          <td class="paramtype">rt_symbolic_interval&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>interv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_unary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>integrand</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Integral generator function taking a symbolic interval and a runtime unary expression for the integrand. </p>

</div>
</div>
<a class="anchor" id="aff1321b9e5d1fd2682c401d952116259"></a><!-- doxytag: member="viennamath::integral" ref="aff1321b9e5d1fd2682c401d952116259" args="(rt_symbolic_interval&lt; InterfaceType &gt; const &amp;interv, rt_variable&lt; InterfaceType &gt; const &amp;integrand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::integral </td>
          <td>(</td>
          <td class="paramtype">rt_symbolic_interval&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>interv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_variable&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>integrand</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Integral generator function taking a symbolic interval and a ViennaMath runtime variable for the integrand. </p>

</div>
</div>
<a class="anchor" id="a2ab676ded45da7a1718f773b9225593c"></a><!-- doxytag: member="viennamath::integral" ref="a2ab676ded45da7a1718f773b9225593c" args="(rt_symbolic_interval&lt; InterfaceType &gt; const &amp;interv, rt_function_symbol&lt; InterfaceType &gt; const &amp;integrand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::integral </td>
          <td>(</td>
          <td class="paramtype">rt_symbolic_interval&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>interv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_function_symbol&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>integrand</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Integral generator function taking a symbolic interval and a ViennaMath runtime function symbol for the integrand. </p>

</div>
</div>
<a class="anchor" id="aed4862f645ae3075a3cc525e4aeca5e1"></a><!-- doxytag: member="viennamath::integral" ref="aed4862f645ae3075a3cc525e4aeca5e1" args="(rt_symbolic_interval&lt; InterfaceType &gt; const &amp;interv, rt_constant&lt; T, InterfaceType &gt; const &amp;integrand)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::integral </td>
          <td>(</td>
          <td class="paramtype">rt_symbolic_interval&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>interv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_constant&lt; T, InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>integrand</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Integral generator function taking a symbolic interval and a ViennaMath runtime constant for the integrand. </p>

</div>
</div>
<a class="anchor" id="a3e087490d53accc08db64b493a8d204e"></a><!-- doxytag: member="viennamath::integrate" ref="a3e087490d53accc08db64b493a8d204e" args="(ct_interval&lt; LowerBound, UpperBound &gt; const &amp;interv, IntegrandType const &amp;integrand, VariableType const &amp;var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennamath_1_1result__of_1_1integrate.html">result_of::integrate</a>&lt;LowerBound, UpperBound, IntegrandType, VariableType&gt;::type viennamath::integrate </td>
          <td>(</td>
          <td class="paramtype">ct_interval&lt; LowerBound, UpperBound &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>interv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegrandType const &amp;&nbsp;</td>
          <td class="paramname"> <em>integrand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VariableType const &amp;&nbsp;</td>
          <td class="paramname"> <em>var</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The user function for the compile time integration of a compile time expression. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>interv</em>&nbsp;</td><td>The compiletime integration interval </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>integrand</em>&nbsp;</td><td>A compiletime integrand </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>A compiletime variable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c217094f61fa562b2f38d8d31bd236b"></a><!-- doxytag: member="viennamath::laplace" ref="a0c217094f61fa562b2f38d8d31bd236b" args="(rt_expr&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::laplace </td>
          <td>(</td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For convenience, the Laplace operator (divergence of the gradient) is provided as a separate function. </p>

</div>
</div>
<a class="anchor" id="ad2b1b2c5a42ce2ff90216898f1c09697"></a><!-- doxytag: member="viennamath::laplace" ref="ad2b1b2c5a42ce2ff90216898f1c09697" args="(rt_function_symbol&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::laplace </td>
          <td>(</td>
          <td class="paramtype">rt_function_symbol&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For convenience, the Laplace operator (divergence of the gradient) is provided as a separate function. </p>

</div>
</div>
<a class="anchor" id="aeb237d8f5686e7cddc50e8b2dc5a703e"></a><!-- doxytag: member="viennamath::log" ref="aeb237d8f5686e7cddc50e8b2dc5a703e" args="(rt_constant&lt; NumericT, InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::log </td>
          <td>(</td>
          <td class="paramtype">rt_constant&lt; NumericT, InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the natural logarithm function for a ViennaMath runtime constant. </p>

</div>
</div>
<a class="anchor" id="a0ecd5f1586131782887cb1347a728eb0"></a><!-- doxytag: member="viennamath::log" ref="a0ecd5f1586131782887cb1347a728eb0" args="(rt_variable&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::log </td>
          <td>(</td>
          <td class="paramtype">rt_variable&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the natural logarithm function for a ViennaMath runtime variable. </p>

</div>
</div>
<a class="anchor" id="a3e37b0e91fcd0ea5b307e4288a247aa4"></a><!-- doxytag: member="viennamath::log" ref="a3e37b0e91fcd0ea5b307e4288a247aa4" args="(ct_variable&lt; id &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> viennamath::log </td>
          <td>(</td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the natural logarithm function for a ViennaMath compiletime variable. </p>

</div>
</div>
<a class="anchor" id="ad0422a93d2137caa7872f0be7a5a897c"></a><!-- doxytag: member="viennamath::log" ref="ad0422a93d2137caa7872f0be7a5a897c" args="(ct_binary_expr&lt; LHS, OP, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> viennamath::log </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; LHS, OP, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the natural logarithm function for a ViennaMath compiletime binary expression. </p>

</div>
</div>
<a class="anchor" id="a6e05131933e69d2974eb42c47908623d"></a><!-- doxytag: member="viennamath::log" ref="a6e05131933e69d2974eb42c47908623d" args="(ct_unary_expr&lt; LHS, OP &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> viennamath::log </td>
          <td>(</td>
          <td class="paramtype">ct_unary_expr&lt; LHS, OP &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the natural logarithm function for a ViennaMath compiletime unary expression. </p>

</div>
</div>
<a class="anchor" id="a93c8877c03a3a06b30c9204dd0d13e8e"></a><!-- doxytag: member="viennamath::log" ref="a93c8877c03a3a06b30c9204dd0d13e8e" args="(rt_unary_expr&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::log </td>
          <td>(</td>
          <td class="paramtype">rt_unary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the natural logarithm function for a ViennaMath runtime unary expression. </p>

</div>
</div>
<a class="anchor" id="a63888ee558eaa93fd56a110b907f5669"></a><!-- doxytag: member="viennamath::log" ref="a63888ee558eaa93fd56a110b907f5669" args="(rt_binary_expr&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::log </td>
          <td>(</td>
          <td class="paramtype">rt_binary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the natural logarithm function for a ViennaMath runtime binary expression. </p>

</div>
</div>
<a class="anchor" id="a34927e53ac2ea16e6a43d6e2fa71c808"></a><!-- doxytag: member="viennamath::log" ref="a34927e53ac2ea16e6a43d6e2fa71c808" args="(rt_expr&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::log </td>
          <td>(</td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the natural logarithm function for a ViennaMath runtime expression wrapper. </p>

</div>
</div>
<a class="anchor" id="ae4f69733aee4b9fc4265d02db6b5b7d1"></a><!-- doxytag: member="viennamath::log10" ref="ae4f69733aee4b9fc4265d02db6b5b7d1" args="(rt_constant&lt; NumericT, InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::log10 </td>
          <td>(</td>
          <td class="paramtype">rt_constant&lt; NumericT, InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the logarithm with base 10 for a ViennaMath runtime constant. </p>

</div>
</div>
<a class="anchor" id="a7e22a44799aa61baa2fa262f1a0045b8"></a><!-- doxytag: member="viennamath::log10" ref="a7e22a44799aa61baa2fa262f1a0045b8" args="(rt_variable&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::log10 </td>
          <td>(</td>
          <td class="paramtype">rt_variable&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the logarithm with base 10 for a ViennaMath runtime variable. </p>

</div>
</div>
<a class="anchor" id="a587bd0314a06e67fec06cc8330458c5f"></a><!-- doxytag: member="viennamath::log10" ref="a587bd0314a06e67fec06cc8330458c5f" args="(ct_variable&lt; id &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> viennamath::log10 </td>
          <td>(</td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the logarithm with base 10 for a ViennaMath compiletime variable. </p>

</div>
</div>
<a class="anchor" id="a5e79b5affd916aef44eb91595e9fe023"></a><!-- doxytag: member="viennamath::log10" ref="a5e79b5affd916aef44eb91595e9fe023" args="(ct_binary_expr&lt; LHS, OP, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> viennamath::log10 </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; LHS, OP, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the logarithm with base 10 for a ViennaMath compiletime binary expression. </p>

</div>
</div>
<a class="anchor" id="a555f9270711b945f99226b3b7da95841"></a><!-- doxytag: member="viennamath::log10" ref="a555f9270711b945f99226b3b7da95841" args="(ct_unary_expr&lt; LHS, OP &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> viennamath::log10 </td>
          <td>(</td>
          <td class="paramtype">ct_unary_expr&lt; LHS, OP &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the logarithm with base 10 for a ViennaMath compiletime unary expression. </p>

</div>
</div>
<a class="anchor" id="a214c73b75ed19e2123fb6d5f48ffa31a"></a><!-- doxytag: member="viennamath::log10" ref="a214c73b75ed19e2123fb6d5f48ffa31a" args="(rt_unary_expr&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::log10 </td>
          <td>(</td>
          <td class="paramtype">rt_unary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the logarithm with base 10 for a ViennaMath runtime unary expression. </p>

</div>
</div>
<a class="anchor" id="abba554e4ced71245733157ae0aa09a53"></a><!-- doxytag: member="viennamath::log10" ref="abba554e4ced71245733157ae0aa09a53" args="(rt_binary_expr&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::log10 </td>
          <td>(</td>
          <td class="paramtype">rt_binary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the logarithm with base 10 for a ViennaMath runtime binary expression. </p>

</div>
</div>
<a class="anchor" id="ab0ec9dd80d7522b20ade837e4b181e20"></a><!-- doxytag: member="viennamath::log10" ref="ab0ec9dd80d7522b20ade837e4b181e20" args="(rt_expr&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::log10 </td>
          <td>(</td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the logarithm with base 10 for a ViennaMath runtime expression wrapper. </p>

</div>
</div>
<a class="anchor" id="aa851687c416c934329cc6d5e9b58168c"></a><!-- doxytag: member="viennamath::make_equation" ref="aa851687c416c934329cc6d5e9b58168c" args="(default_numeric_type lhs, ct_variable&lt; id &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a> viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">default_numeric_type&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generator for an equation with a (floating point) constant as left hand side and a ViennaMath compiletime variable as right hand side. </p>

</div>
</div>
<a class="anchor" id="a121d6f860f24f141b9d8659fe8fdd820"></a><!-- doxytag: member="viennamath::make_equation" ref="a121d6f860f24f141b9d8659fe8fdd820" args="(typename InterfaceType::numeric_type lhs, rt_unary_expr&lt; InterfaceType &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&lt;InterfaceType&gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">typename InterfaceType::numeric_type&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_unary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generator for an equation with a (floating point) constant as left hand side and a ViennaMath runtime unary expression as right hand side. </p>

</div>
</div>
<a class="anchor" id="a1d2696afe9a144d1718635fb9218ae21"></a><!-- doxytag: member="viennamath::make_equation" ref="a1d2696afe9a144d1718635fb9218ae21" args="(typename InterfaceType::numeric_type lhs, rt_binary_expr&lt; InterfaceType &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&lt;InterfaceType&gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">typename InterfaceType::numeric_type&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_binary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generator for an equation with a (floating point) constant as left hand side and a ViennaMath runtime binary expression as right hand side. </p>

</div>
</div>
<a class="anchor" id="aa4f2427f8a68104b5b82178fc4f528b9"></a><!-- doxytag: member="viennamath::make_equation" ref="aa4f2427f8a68104b5b82178fc4f528b9" args="(typename InterfaceType::numeric_type lhs, rt_expr&lt; InterfaceType &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&lt;InterfaceType&gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">typename InterfaceType::numeric_type&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generator for an equation with a (floating point) constant as left hand side and a ViennaMath runtime expression wrapper as right hand side. </p>

</div>
</div>
<a class="anchor" id="ac2339621f49675d392dc2b32ac2fb909"></a><!-- doxytag: member="viennamath::make_equation" ref="ac2339621f49675d392dc2b32ac2fb909" args="(rt_constant&lt; NumericT, InterfaceType &gt; const &amp;lhs, RHSType const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&lt;InterfaceType&gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">rt_constant&lt; NumericT, InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHSType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generator for an equation with a ViennaMath runtime constant as left hand side. </p>

</div>
</div>
<a class="anchor" id="a253b8cde5329dd9e3672ad8cdb7d0959"></a><!-- doxytag: member="viennamath::make_equation" ref="a253b8cde5329dd9e3672ad8cdb7d0959" args="(rt_variable&lt; InterfaceType &gt; const &amp;lhs, RHSType const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&lt;InterfaceType&gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">rt_variable&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHSType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generator for an equation with a ViennaMath runtime variable as left hand side. </p>

</div>
</div>
<a class="anchor" id="a227eb2b725343bb8993a2108087f806c"></a><!-- doxytag: member="viennamath::make_equation" ref="a227eb2b725343bb8993a2108087f806c" args="(rt_function_symbol&lt; InterfaceType &gt; const &amp;lhs, RHSType const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&lt;InterfaceType&gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">rt_function_symbol&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHSType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generator for an equation with a ViennaMath runtime function symbol as left hand side. </p>

</div>
</div>
<a class="anchor" id="a767e37950716493d58cd56f9ab11b56c"></a><!-- doxytag: member="viennamath::make_equation" ref="a767e37950716493d58cd56f9ab11b56c" args="(ct_binary_expr&lt; LHS1, OP1, RHS1 &gt; const &amp;lhs, ct_variable&lt; id &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt;<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;LHS1, OP1, RHS1&gt;, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt;id&gt; &gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; LHS1, OP1, RHS1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an equation from a binary expressions and a variable at compiletime. </p>

</div>
</div>
<a class="anchor" id="aca9e663980567e5038febdae97e8916f"></a><!-- doxytag: member="viennamath::make_equation" ref="aca9e663980567e5038febdae97e8916f" args="(rt_binary_expr&lt; InterfaceType &gt; const &amp;lhs, RHSType const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&lt;InterfaceType&gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">rt_binary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHSType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generator for an equation with a ViennaMath runtime binary expression as left hand side. </p>

</div>
</div>
<a class="anchor" id="a61349cc9febce8acc584c715ac02a04a"></a><!-- doxytag: member="viennamath::make_equation" ref="a61349cc9febce8acc584c715ac02a04a" args="(rt_expr&lt; InterfaceType &gt; const &amp;lhs, RHSType const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&lt;InterfaceType&gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHSType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generator for an equation with a ViennaMath runtime expression wrapper as left hand side. </p>

</div>
</div>
<a class="anchor" id="a91b44dba590fd0eb8201ea1473da33eb"></a><!-- doxytag: member="viennamath::make_equation" ref="a91b44dba590fd0eb8201ea1473da33eb" args="(ct_binary_expr&lt; LHS, OP, RHS &gt; const &amp;lhs, RHSType const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a> viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; LHS, OP, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHSType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generator for an equation with a ViennaMath compiletime binary expression as left hand side. </p>

</div>
</div>
<a class="anchor" id="abb9d548fac3628cd418061b3f7540227"></a><!-- doxytag: member="viennamath::make_equation" ref="abb9d548fac3628cd418061b3f7540227" args="(ct_constant&lt; value1 &gt; const &amp;lhs, ct_constant&lt; value2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt;<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;value1&gt;, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;value2&gt; &gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_constant&lt; value1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_constant&lt; value2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an equation from two constants at compiletime. </p>

</div>
</div>
<a class="anchor" id="a9e78860f6b8f98b07111ac449dcf789a"></a><!-- doxytag: member="viennamath::make_equation" ref="a9e78860f6b8f98b07111ac449dcf789a" args="(ct_constant&lt; val &gt; const &amp;lhs, RHSType const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a> viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_constant&lt; val &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHSType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generator for an equation with a ViennaMath compiletime constant as left hand side. </p>

</div>
</div>
<a class="anchor" id="a1ce0f267bb1fe74a07eba4afebc69f1d"></a><!-- doxytag: member="viennamath::make_equation" ref="a1ce0f267bb1fe74a07eba4afebc69f1d" args="(ct_variable&lt; id &gt; const &amp;lhs, RHSType const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a> viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHSType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generator for an equation with a ViennaMath compiletime variable as left hand side. </p>

</div>
</div>
<a class="anchor" id="acee7618050972a4797b9615e244118e3"></a><!-- doxytag: member="viennamath::make_equation" ref="acee7618050972a4797b9615e244118e3" args="(ct_constant&lt; value1 &gt; const &amp;lhs, ct_function_symbol&lt; TAG &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt;<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;value1&gt;, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt;TAG&gt; &gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_constant&lt; value1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_function_symbol&lt; TAG &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an equation from a constant and a function symbol at compiletime. </p>

</div>
</div>
<a class="anchor" id="a84f877a23da1606e62aed3ed23721aa1"></a><!-- doxytag: member="viennamath::make_equation" ref="a84f877a23da1606e62aed3ed23721aa1" args="(ct_unary_expr&lt; LHS1, OP1 &gt; const &amp;lhs, ct_binary_expr&lt; LHS2, OP2, RHS2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt;<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt;LHS1, OP1&gt;, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;LHS2, OP2, RHS2&gt; &gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_unary_expr&lt; LHS1, OP1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_binary_expr&lt; LHS2, OP2, RHS2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an equation from a unary expressions and a binary expression at compiletime. </p>

</div>
</div>
<a class="anchor" id="a7ca225bfb0cfaa3d17c12208b37746c5"></a><!-- doxytag: member="viennamath::make_equation" ref="a7ca225bfb0cfaa3d17c12208b37746c5" args="(ct_constant&lt; value1 &gt; const &amp;lhs, ct_variable&lt; id &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt;<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;value1&gt;, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt;id&gt; &gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_constant&lt; value1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an equation from a constant and a variable at compiletime. </p>

</div>
</div>
<a class="anchor" id="adeaf2a2dcb3b0b7f37aff0878852bbb1"></a><!-- doxytag: member="viennamath::make_equation" ref="adeaf2a2dcb3b0b7f37aff0878852bbb1" args="(ct_function_symbol&lt; TAG &gt; const &amp;lhs, ct_binary_expr&lt; LHS2, OP2, RHS2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt;<a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt;TAG&gt;, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;LHS2, OP2, RHS2&gt; &gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_function_symbol&lt; TAG &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_binary_expr&lt; LHS2, OP2, RHS2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an equation from a function symbol and a binary expression at compiletime. </p>

</div>
</div>
<a class="anchor" id="a80308557d326a80d72ad4f2740bc326e"></a><!-- doxytag: member="viennamath::make_equation" ref="a80308557d326a80d72ad4f2740bc326e" args="(ct_function_symbol&lt; TAG &gt; const &amp;lhs, ct_unary_expr&lt; LHS2, OP2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt;<a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt;TAG&gt;, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt;LHS2, OP2&gt; &gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_function_symbol&lt; TAG &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_unary_expr&lt; LHS2, OP2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an equation from a function symbol and a unary expression at compiletime. </p>

</div>
</div>
<a class="anchor" id="a1392eca4e428f0895b46c627d004005a"></a><!-- doxytag: member="viennamath::make_equation" ref="a1392eca4e428f0895b46c627d004005a" args="(ct_function_symbol&lt; TAG &gt; const &amp;lhs, ct_constant&lt; value &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt;<a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt;TAG&gt;, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;value&gt; &gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_function_symbol&lt; TAG &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_constant&lt; value &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an equation from a function symbol and a constant at compiletime. </p>

</div>
</div>
<a class="anchor" id="a9a265e80d965fbe2d9917e13650892c7"></a><!-- doxytag: member="viennamath::make_equation" ref="a9a265e80d965fbe2d9917e13650892c7" args="(ct_function_symbol&lt; TAG1 &gt; const &amp;lhs, ct_function_symbol&lt; TAG2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt;<a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt;TAG1&gt;, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt;TAG2&gt; &gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_function_symbol&lt; TAG1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_function_symbol&lt; TAG2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an equation from two function symbols at compiletime. </p>

</div>
</div>
<a class="anchor" id="add4a1ae18991014d98974999f73d6501"></a><!-- doxytag: member="viennamath::make_equation" ref="add4a1ae18991014d98974999f73d6501" args="(ct_binary_expr&lt; LHS1, OP1, RHS1 &gt; const &amp;lhs, ct_binary_expr&lt; LHS2, OP2, RHS2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt;<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;LHS1, OP1, RHS1&gt;, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;LHS2, OP2, RHS2&gt; &gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; LHS1, OP1, RHS1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_binary_expr&lt; LHS2, OP2, RHS2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an equation from two binary expressions at compiletime. </p>

</div>
</div>
<a class="anchor" id="a8e7a6ed0e53f2d15e8f2194a235cb699"></a><!-- doxytag: member="viennamath::make_equation" ref="a8e7a6ed0e53f2d15e8f2194a235cb699" args="(ct_unary_expr&lt; LHS1, OP1 &gt; const &amp;lhs, ct_constant&lt; value &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt;<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt;LHS1, OP1&gt;, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;value&gt; &gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_unary_expr&lt; LHS1, OP1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_constant&lt; value &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an equation from a unary expressions and a constant at compiletime. </p>

</div>
</div>
<a class="anchor" id="ab2e734ddfdee0d920848ba181772a6e1"></a><!-- doxytag: member="viennamath::make_equation" ref="ab2e734ddfdee0d920848ba181772a6e1" args="(ct_function_symbol&lt; TAG &gt; const &amp;lhs, ct_variable&lt; id &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt;<a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt;TAG&gt;, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt;id&gt; &gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_function_symbol&lt; TAG &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an equation from a function symbol and a variable at compiletime. </p>

</div>
</div>
<a class="anchor" id="a7888da1175eab8c9581337f19768bd45"></a><!-- doxytag: member="viennamath::make_equation" ref="a7888da1175eab8c9581337f19768bd45" args="(ct_binary_expr&lt; LHS1, OP1, RHS1 &gt; const &amp;lhs, ct_unary_expr&lt; LHS2, OP2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt;<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;LHS1, OP1, RHS1&gt;, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt;LHS2, OP2&gt; &gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; LHS1, OP1, RHS1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_unary_expr&lt; LHS2, OP2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an equation from a binary expressions and a unary expression at compiletime. </p>

</div>
</div>
<a class="anchor" id="a1a9694ff1100f5214a3a87e0cbbe70d6"></a><!-- doxytag: member="viennamath::make_equation" ref="a1a9694ff1100f5214a3a87e0cbbe70d6" args="(ct_unary_expr&lt; LHS1, OP1 &gt; const &amp;lhs, ct_unary_expr&lt; LHS2, OP2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt;<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt;LHS1, OP1&gt;, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt;LHS2, OP2&gt; &gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_unary_expr&lt; LHS1, OP1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_unary_expr&lt; LHS2, OP2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an equation from two unary expressions at compiletime. </p>

</div>
</div>
<a class="anchor" id="a935774c963fa6f3cd64c5171d19720be"></a><!-- doxytag: member="viennamath::make_equation" ref="a935774c963fa6f3cd64c5171d19720be" args="(ct_variable&lt; id1 &gt; const &amp;lhs, ct_binary_expr&lt; LHS2, OP2, RHS2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt;<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt;id1&gt;, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;LHS2, OP2, RHS2&gt; &gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_variable&lt; id1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_binary_expr&lt; LHS2, OP2, RHS2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an equation from a variable and a binary expression at compiletime. </p>

</div>
</div>
<a class="anchor" id="a83deea69be0d24015a7b4192cee5cbd2"></a><!-- doxytag: member="viennamath::make_equation" ref="a83deea69be0d24015a7b4192cee5cbd2" args="(ct_binary_expr&lt; LHS1, OP1, RHS1 &gt; const &amp;lhs, ct_constant&lt; value &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt;<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;LHS1, OP1, RHS1&gt;, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;value&gt; &gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; LHS1, OP1, RHS1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_constant&lt; value &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an equation from a binary expressions and a constant at compiletime. </p>

</div>
</div>
<a class="anchor" id="a5cc963a04160551e0c3c80087c04e9f8"></a><!-- doxytag: member="viennamath::make_equation" ref="a5cc963a04160551e0c3c80087c04e9f8" args="(ct_unary_expr&lt; LHS1, OP1 &gt; const &amp;lhs, ct_function_symbol&lt; TAG &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt;<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt;LHS1, OP1&gt;, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt;TAG&gt; &gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_unary_expr&lt; LHS1, OP1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_function_symbol&lt; TAG &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an equation from a unary expressions and a function symbol at compiletime. </p>

</div>
</div>
<a class="anchor" id="a4bded0b31f7a2dc492b9af6da45c341b"></a><!-- doxytag: member="viennamath::make_equation" ref="a4bded0b31f7a2dc492b9af6da45c341b" args="(ct_variable&lt; id1 &gt; const &amp;lhs, ct_unary_expr&lt; LHS2, OP2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt;<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt;id1&gt;, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt;LHS2, OP2&gt; &gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_variable&lt; id1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_unary_expr&lt; LHS2, OP2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an equation from a variable and a unary expression at compiletime. </p>

</div>
</div>
<a class="anchor" id="a907d596009397f34675578dcc21462dd"></a><!-- doxytag: member="viennamath::make_equation" ref="a907d596009397f34675578dcc21462dd" args="(ct_variable&lt; id1 &gt; const &amp;lhs, ct_constant&lt; value2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt;<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt;id1&gt;, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;value2&gt; &gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_variable&lt; id1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_constant&lt; value2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an equation from a variable and a constant at compiletime. </p>

</div>
</div>
<a class="anchor" id="abe6b4efb7cee97a998c909a5f8cd4a52"></a><!-- doxytag: member="viennamath::make_equation" ref="abe6b4efb7cee97a998c909a5f8cd4a52" args="(ct_unary_expr&lt; LHS1, OP1 &gt; const &amp;lhs, ct_variable&lt; id &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt;<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt;LHS1, OP1&gt;, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt;id&gt; &gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_unary_expr&lt; LHS1, OP1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an equation from a unary expressions and a variable at compiletime. </p>

</div>
</div>
<a class="anchor" id="ab614e35c2bbf9adcdf187aa6c5313e39"></a><!-- doxytag: member="viennamath::make_equation" ref="ab614e35c2bbf9adcdf187aa6c5313e39" args="(ct_unary_expr&lt; LHS, OP &gt; const &amp;lhs, RHSType const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a> viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_unary_expr&lt; LHS, OP &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHSType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generator for an equation with a ViennaMath compiletime unary expression as left hand side. </p>

</div>
</div>
<a class="anchor" id="a7434b2696c2b420582de0f16d03f025f"></a><!-- doxytag: member="viennamath::make_equation" ref="a7434b2696c2b420582de0f16d03f025f" args="(ct_variable&lt; id1 &gt; const &amp;lhs, ct_function_symbol&lt; TAG &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt;<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt;id1&gt;, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt;TAG&gt; &gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_variable&lt; id1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_function_symbol&lt; TAG &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an equation from a variable and a function symbol at compiletime. </p>

</div>
</div>
<a class="anchor" id="aa2c2e672ffcd7858ff8dd796994b6d8a"></a><!-- doxytag: member="viennamath::make_equation" ref="aa2c2e672ffcd7858ff8dd796994b6d8a" args="(ct_function_symbol&lt; TAG &gt; const &amp;lhs, RHSType const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a> viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_function_symbol&lt; TAG &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHSType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generator for an equation with a ViennaMath compiletime function symbol as left hand side. </p>

</div>
</div>
<a class="anchor" id="ab75b3884f5e724b445b631ffa0a038a4"></a><!-- doxytag: member="viennamath::make_equation" ref="ab75b3884f5e724b445b631ffa0a038a4" args="(rt_unary_expr&lt; InterfaceType &gt; const &amp;lhs, RHSType const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&lt;InterfaceType&gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">rt_unary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHSType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generator for an equation with a ViennaMath runtime unary expression as left hand side. </p>

</div>
</div>
<a class="anchor" id="a1e46690ad9bfff5ce059662e0bb8a089"></a><!-- doxytag: member="viennamath::make_equation" ref="a1e46690ad9bfff5ce059662e0bb8a089" args="(ct_variable&lt; id1 &gt; const &amp;lhs, ct_variable&lt; id2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt;<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt;id1&gt;, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt;id2&gt; &gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_variable&lt; id1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_variable&lt; id2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an equation from two variables at compiletime. </p>

</div>
</div>
<a class="anchor" id="afd347142e25ba9f8d059f57322992dcb"></a><!-- doxytag: member="viennamath::make_equation" ref="afd347142e25ba9f8d059f57322992dcb" args="(ct_binary_expr&lt; LHS1, OP1, RHS1 &gt; const &amp;lhs, ct_function_symbol&lt; TAG &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt;<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;LHS1, OP1, RHS1&gt;, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt;TAG&gt; &gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; LHS1, OP1, RHS1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_function_symbol&lt; TAG &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an equation from a binary expressions and a function symbol at compiletime. </p>

</div>
</div>
<a class="anchor" id="a0acc4326232c49b6844ae7d36a3c5321"></a><!-- doxytag: member="viennamath::make_equation" ref="a0acc4326232c49b6844ae7d36a3c5321" args="(ct_constant&lt; value1 &gt; const &amp;lhs, ct_binary_expr&lt; LHS2, OP2, RHS2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt;<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;value1&gt;, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;LHS2, OP2, RHS2&gt; &gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_constant&lt; value1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_binary_expr&lt; LHS2, OP2, RHS2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an equation from a constant and a binary expression at compiletime. </p>

</div>
</div>
<a class="anchor" id="ab4a59a2515079317fa4e4536d5644a1f"></a><!-- doxytag: member="viennamath::make_equation" ref="ab4a59a2515079317fa4e4536d5644a1f" args="(ct_constant&lt; value1 &gt; const &amp;lhs, ct_unary_expr&lt; LHS2, OP2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__equation.html">ct_equation</a>&lt;<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;value1&gt;, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt;LHS2, OP2&gt; &gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">ct_constant&lt; value1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_unary_expr&lt; LHS2, OP2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an equation from a constant and a unary expression at compiletime. </p>

</div>
</div>
<a class="anchor" id="a41161cd9c03afda4965842f1204f5756"></a><!-- doxytag: member="viennamath::make_equation" ref="a41161cd9c03afda4965842f1204f5756" args="(typename InterfaceType::numeric_type lhs, rt_constant&lt; NumericT, InterfaceType &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&lt;InterfaceType&gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">typename InterfaceType::numeric_type&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_constant&lt; NumericT, InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generator for an equation with a (floating point) constant as left hand side and a ViennaMath runtime constant as right hand side. </p>

</div>
</div>
<a class="anchor" id="a44690bcd75fd4f62047e325cd8eb5652"></a><!-- doxytag: member="viennamath::make_equation" ref="a44690bcd75fd4f62047e325cd8eb5652" args="(typename InterfaceType::numeric_type lhs, rt_variable&lt; InterfaceType &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__equation.html">rt_equation</a>&lt;InterfaceType&gt; viennamath::make_equation </td>
          <td>(</td>
          <td class="paramtype">typename InterfaceType::numeric_type&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_variable&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generator for an equation with a (floating point) constant as left hand side and a ViennaMath runtime variable as right hand side. </p>

</div>
</div>
<a class="anchor" id="a09a751cbd8aee9f04cbdf7020fb2569b"></a><!-- doxytag: member="viennamath::make_interval" ref="a09a751cbd8aee9f04cbdf7020fb2569b" args="(typename InterfaceType::numeric_type lhs, rt_unary_expr&lt; InterfaceType &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt;InterfaceType&gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">typename InterfaceType::numeric_type&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_unary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an interval, where the upper bound is given by a ViennaMath unary expression. </p>

</div>
</div>
<a class="anchor" id="a50ae4586eaa29562af3b676cc25b720a"></a><!-- doxytag: member="viennamath::make_interval" ref="a50ae4586eaa29562af3b676cc25b720a" args="(ct_binary_expr&lt; LHS1, OP1, RHS1 &gt; const &amp;lhs, ct_constant&lt; value &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt;<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;LHS1, OP1, RHS1&gt;, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;value&gt; &gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; LHS1, OP1, RHS1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_constant&lt; value &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an interval from a binary expression and a constant at compiletime. </p>

</div>
</div>
<a class="anchor" id="a49b0fea2d3317d93f15a925022329e23"></a><!-- doxytag: member="viennamath::make_interval" ref="a49b0fea2d3317d93f15a925022329e23" args="(ct_binary_expr&lt; LHS1, OP1, RHS1 &gt; const &amp;lhs, ct_function_symbol&lt; TAG &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt;<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;LHS1, OP1, RHS1&gt;, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt;TAG&gt; &gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; LHS1, OP1, RHS1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_function_symbol&lt; TAG &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an interval from a binary expression and a function symbol at compiletime. </p>

</div>
</div>
<a class="anchor" id="a8bcda02cb6f61be2622b77d117ba962d"></a><!-- doxytag: member="viennamath::make_interval" ref="a8bcda02cb6f61be2622b77d117ba962d" args="(ct_binary_expr&lt; LHS1, OP1, RHS1 &gt; const &amp;lhs, ct_variable&lt; id &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt;<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;LHS1, OP1, RHS1&gt;, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt;id&gt; &gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; LHS1, OP1, RHS1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an interval from a binary expression and a variable at compiletime. </p>

</div>
</div>
<a class="anchor" id="a1e8f2a80bd7ac7d0a271e1034b4aef37"></a><!-- doxytag: member="viennamath::make_interval" ref="a1e8f2a80bd7ac7d0a271e1034b4aef37" args="(typename InterfaceType::numeric_type lhs, rt_constant&lt; NumericT, InterfaceType &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt;InterfaceType&gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">typename InterfaceType::numeric_type&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_constant&lt; NumericT, InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an interval, where the upper bound is given by a ViennaMath constant. </p>

</div>
</div>
<a class="anchor" id="af7b0e477ed885a3254e3541a4e860c46"></a><!-- doxytag: member="viennamath::make_interval" ref="af7b0e477ed885a3254e3541a4e860c46" args="(typename InterfaceType::numeric_type lhs, rt_variable&lt; InterfaceType &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt;InterfaceType&gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">typename InterfaceType::numeric_type&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_variable&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an interval, where the upper bound is given by a ViennaMath runtime variable. </p>

</div>
</div>
<a class="anchor" id="a2fa2be9f1e337890485f7974e89ccea3"></a><!-- doxytag: member="viennamath::make_interval" ref="a2fa2be9f1e337890485f7974e89ccea3" args="(default_numeric_type lhs, ct_variable&lt; id &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a> viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">default_numeric_type&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an interval, where the upper bound is given by a ViennaMath compiletime variable. </p>

</div>
</div>
<a class="anchor" id="ae9f6464bdef45ff9c5870e4fb83f5011"></a><!-- doxytag: member="viennamath::make_interval" ref="ae9f6464bdef45ff9c5870e4fb83f5011" args="(ct_unary_expr&lt; LHS1, OP1 &gt; const &amp;lhs, ct_binary_expr&lt; LHS2, OP2, RHS2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt;<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt;LHS1, OP1&gt;, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;LHS2, OP2, RHS2&gt; &gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_unary_expr&lt; LHS1, OP1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_binary_expr&lt; LHS2, OP2, RHS2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an interval from a unary expression and a binary expression at compiletime. </p>

</div>
</div>
<a class="anchor" id="a73f4222ebf9a33334f27860f7e51acea"></a><!-- doxytag: member="viennamath::make_interval" ref="a73f4222ebf9a33334f27860f7e51acea" args="(ct_function_symbol&lt; TAG &gt; const &amp;lhs, RHSType const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt;typename RHSType::interface_type&gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_function_symbol&lt; TAG &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHSType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an interval, where the lower bound is given by a ViennaMath compiletime function symbol. </p>

</div>
</div>
<a class="anchor" id="afa02c21471433c73792f2a76efd12484"></a><!-- doxytag: member="viennamath::make_interval" ref="afa02c21471433c73792f2a76efd12484" args="(ct_unary_expr&lt; LHS, OP &gt; const &amp;lhs, RHSType const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt;typename RHSType::interface_type&gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_unary_expr&lt; LHS, OP &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHSType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an interval, where the lower bound is given by a ViennaMath compiletime unary expression. </p>

</div>
</div>
<a class="anchor" id="af2c938c7a4991262ba94d85466c31ca3"></a><!-- doxytag: member="viennamath::make_interval" ref="af2c938c7a4991262ba94d85466c31ca3" args="(typename InterfaceType::numeric_type lhs, rt_binary_expr&lt; InterfaceType &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt;InterfaceType&gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">typename InterfaceType::numeric_type&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_binary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an interval, where the upper bound is given by a ViennaMath binary expression. </p>

</div>
</div>
<a class="anchor" id="ab852779d2653a19d42f9dc2e68c7250c"></a><!-- doxytag: member="viennamath::make_interval" ref="ab852779d2653a19d42f9dc2e68c7250c" args="(typename InterfaceType::numeric_type lhs, rt_expr&lt; InterfaceType &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt;InterfaceType&gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">typename InterfaceType::numeric_type&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an interval, where the upper bound is given by a ViennaMath expression wrapper. </p>

</div>
</div>
<a class="anchor" id="ab1c24b8711069a850ee17b95d9699e56"></a><!-- doxytag: member="viennamath::make_interval" ref="ab1c24b8711069a850ee17b95d9699e56" args="(rt_constant&lt; NumericT, InterfaceType &gt; const &amp;lhs, RHSType const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt;InterfaceType&gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">rt_constant&lt; NumericT, InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHSType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an interval, where the lower bound is given by a ViennaMath runtime constant. </p>

</div>
</div>
<a class="anchor" id="a6994b6aded6f5ee6ca45574657f02e57"></a><!-- doxytag: member="viennamath::make_interval" ref="a6994b6aded6f5ee6ca45574657f02e57" args="(ct_variable&lt; id &gt; const &amp;lhs, RHSType const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt; typename RHSType::interface_type &gt; make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHSType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an interval, where the lower bound is given by a ViennaMath compiletime variable. </p>

</div>
</div>
<a class="anchor" id="a44bfa18c88d18271b40a22ba03508171"></a><!-- doxytag: member="viennamath::make_interval" ref="a44bfa18c88d18271b40a22ba03508171" args="(rt_function_symbol&lt; InterfaceType &gt; const &amp;lhs, RHSType const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt;InterfaceType&gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">rt_function_symbol&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHSType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an interval, where the lower bound is given by a ViennaMath runtime function symbol. </p>

</div>
</div>
<a class="anchor" id="aba0e4705369d1dbbf2198e588db87d74"></a><!-- doxytag: member="viennamath::make_interval" ref="aba0e4705369d1dbbf2198e588db87d74" args="(rt_unary_expr&lt; InterfaceType &gt; const &amp;lhs, RHSType const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt;InterfaceType&gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">rt_unary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHSType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an interval, where the lower bound is given by a ViennaMath runtime unary expression. </p>

</div>
</div>
<a class="anchor" id="ad8a5727a5d025bf366f9ab080cc5a249"></a><!-- doxytag: member="viennamath::make_interval" ref="ad8a5727a5d025bf366f9ab080cc5a249" args="(rt_expr&lt; InterfaceType &gt; const &amp;lhs, RHSType const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt;InterfaceType&gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHSType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an interval, where the lower bound is given by a ViennaMath runtime expression wrapper. </p>

</div>
</div>
<a class="anchor" id="a9e09bcf326a34a06bca4787afe70793b"></a><!-- doxytag: member="viennamath::make_interval" ref="a9e09bcf326a34a06bca4787afe70793b" args="(ct_binary_expr&lt; LHS, OP, RHS &gt; const &amp;lhs, RHSType const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt;typename RHSType::interface_type&gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; LHS, OP, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHSType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an interval, where the lower bound is given by a ViennaMath compiletime binary expression. </p>

</div>
</div>
<a class="anchor" id="a3dba992f3529b044a87b528f947ebf25"></a><!-- doxytag: member="viennamath::make_interval" ref="a3dba992f3529b044a87b528f947ebf25" args="(ct_unary_expr&lt; LHS1, OP1 &gt; const &amp;lhs, ct_unary_expr&lt; LHS2, OP2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt;<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt;LHS1, OP1&gt;, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt;LHS2, OP2&gt; &gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_unary_expr&lt; LHS1, OP1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_unary_expr&lt; LHS2, OP2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an interval from two unary expressions at compiletime. </p>

</div>
</div>
<a class="anchor" id="a2657a2dd5bc0573de3bca00f1359ae61"></a><!-- doxytag: member="viennamath::make_interval" ref="a2657a2dd5bc0573de3bca00f1359ae61" args="(ct_unary_expr&lt; LHS1, OP1 &gt; const &amp;lhs, ct_constant&lt; value &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt;<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt;LHS1, OP1&gt;, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;value&gt; &gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_unary_expr&lt; LHS1, OP1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_constant&lt; value &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an interval from a unary expression and a constant at compiletime. </p>

</div>
</div>
<a class="anchor" id="ae703a532dd4c9d253f60cc852d455887"></a><!-- doxytag: member="viennamath::make_interval" ref="ae703a532dd4c9d253f60cc852d455887" args="(rt_variable&lt; InterfaceType &gt; const &amp;lhs, RHSType const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt;InterfaceType&gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">rt_variable&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHSType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an interval, where the lower bound is given by a ViennaMath runtime variable. </p>

</div>
</div>
<a class="anchor" id="a9c8566c7e24e3bb8ab3b69b3e0bf6fb1"></a><!-- doxytag: member="viennamath::make_interval" ref="a9c8566c7e24e3bb8ab3b69b3e0bf6fb1" args="(ct_unary_expr&lt; LHS1, OP1 &gt; const &amp;lhs, ct_function_symbol&lt; TAG &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt;<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt;LHS1, OP1&gt;, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt;TAG&gt; &gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_unary_expr&lt; LHS1, OP1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_function_symbol&lt; TAG &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an interval from a unary expression and a function symbol at compiletime. </p>

</div>
</div>
<a class="anchor" id="afb7ed761b87ff3dadf12c500465e390b"></a><!-- doxytag: member="viennamath::make_interval" ref="afb7ed761b87ff3dadf12c500465e390b" args="(ct_unary_expr&lt; LHS1, OP1 &gt; const &amp;lhs, ct_variable&lt; id &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt;<a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt;LHS1, OP1&gt;, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt;id&gt; &gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_unary_expr&lt; LHS1, OP1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an interval from a unary expression and a variable at compiletime. </p>

</div>
</div>
<a class="anchor" id="ab0f31ba9638abd55997318f91b143c56"></a><!-- doxytag: member="viennamath::make_interval" ref="ab0f31ba9638abd55997318f91b143c56" args="(ct_constant&lt; value1 &gt; const &amp;lhs, ct_binary_expr&lt; LHS2, OP2, RHS2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt;<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;value1&gt;, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;LHS2, OP2, RHS2&gt; &gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_constant&lt; value1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_binary_expr&lt; LHS2, OP2, RHS2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an interval from a constant and a binary expression at compiletime. </p>

</div>
</div>
<a class="anchor" id="ab9e633caae5bf50bf3db985328eac803"></a><!-- doxytag: member="viennamath::make_interval" ref="ab9e633caae5bf50bf3db985328eac803" args="(ct_constant&lt; value1 &gt; const &amp;lhs, ct_unary_expr&lt; LHS2, OP2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt;<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;value1&gt;, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt;LHS2, OP2&gt; &gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_constant&lt; value1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_unary_expr&lt; LHS2, OP2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an interval from a constant and a unary expression at compiletime. </p>

</div>
</div>
<a class="anchor" id="a15f7c1f9a832b3d0deb7992d78cf9233"></a><!-- doxytag: member="viennamath::make_interval" ref="a15f7c1f9a832b3d0deb7992d78cf9233" args="(ct_constant&lt; value1 &gt; const &amp;lhs, ct_constant&lt; value2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt;<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;value1&gt;, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;value2&gt; &gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_constant&lt; value1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_constant&lt; value2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an interval from two constants at compiletime. </p>

</div>
</div>
<a class="anchor" id="a93da8c5b3917e7d87e95a66fbf4057d4"></a><!-- doxytag: member="viennamath::make_interval" ref="a93da8c5b3917e7d87e95a66fbf4057d4" args="(ct_constant&lt; value1 &gt; const &amp;lhs, ct_function_symbol&lt; TAG &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt;<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;value1&gt;, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt;TAG&gt; &gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_constant&lt; value1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_function_symbol&lt; TAG &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an interval from a constant and a function symbol at compiletime. </p>

</div>
</div>
<a class="anchor" id="aa3a28a5f050165138f775e09aeae4a07"></a><!-- doxytag: member="viennamath::make_interval" ref="aa3a28a5f050165138f775e09aeae4a07" args="(ct_constant&lt; value1 &gt; const &amp;lhs, ct_variable&lt; id &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt;<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;value1&gt;, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt;id&gt; &gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_constant&lt; value1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an interval from a constant and a variable at compiletime. </p>

</div>
</div>
<a class="anchor" id="a24c9c83653c0ed54bf2b000d75b62327"></a><!-- doxytag: member="viennamath::make_interval" ref="a24c9c83653c0ed54bf2b000d75b62327" args="(ct_function_symbol&lt; TAG &gt; const &amp;lhs, ct_binary_expr&lt; LHS2, OP2, RHS2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt;<a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt;TAG&gt;, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;LHS2, OP2, RHS2&gt; &gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_function_symbol&lt; TAG &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_binary_expr&lt; LHS2, OP2, RHS2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an interval from a function symbol and a binary expression at compiletime. </p>

</div>
</div>
<a class="anchor" id="a6aa35c36866aa94dd2acdff66dd3bcc8"></a><!-- doxytag: member="viennamath::make_interval" ref="a6aa35c36866aa94dd2acdff66dd3bcc8" args="(ct_function_symbol&lt; TAG &gt; const &amp;lhs, ct_unary_expr&lt; LHS2, OP2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt;<a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt;TAG&gt;, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt;LHS2, OP2&gt; &gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_function_symbol&lt; TAG &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_unary_expr&lt; LHS2, OP2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an interval from a function symbol and a unary expression at compiletime. </p>

</div>
</div>
<a class="anchor" id="a3ad924db674ed5ce43acacb73b872aa7"></a><!-- doxytag: member="viennamath::make_interval" ref="a3ad924db674ed5ce43acacb73b872aa7" args="(ct_function_symbol&lt; TAG &gt; const &amp;lhs, ct_constant&lt; value &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt;<a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt;TAG&gt;, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;value&gt; &gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_function_symbol&lt; TAG &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_constant&lt; value &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an interval from a function symbol and a constant at compiletime. </p>

</div>
</div>
<a class="anchor" id="a6498609221413523451a8012b76fdf49"></a><!-- doxytag: member="viennamath::make_interval" ref="a6498609221413523451a8012b76fdf49" args="(default_numeric_type lhs, default_numeric_type rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a> viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">default_numeric_type&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">default_numeric_type&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an interval with two numerical limits. </p>

</div>
</div>
<a class="anchor" id="aeca718473db37116c1754f414138d898"></a><!-- doxytag: member="viennamath::make_interval" ref="aeca718473db37116c1754f414138d898" args="(ct_function_symbol&lt; TAG1 &gt; const &amp;lhs, ct_function_symbol&lt; TAG2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt;<a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt;TAG1&gt;, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt;TAG2&gt; &gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_function_symbol&lt; TAG1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_function_symbol&lt; TAG2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an interval from two function symbols at compiletime. </p>

</div>
</div>
<a class="anchor" id="a8c166e36a6c13c9df5ebced001973ce1"></a><!-- doxytag: member="viennamath::make_interval" ref="a8c166e36a6c13c9df5ebced001973ce1" args="(ct_constant&lt; val &gt; const &amp;lhs, RHSType const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt;typename RHSType::interface_type&gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_constant&lt; val &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHSType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an interval, where the lower bound is given by a ViennaMath compiletime constant. </p>

</div>
</div>
<a class="anchor" id="aa5214063f27699f986ea90286e4ad66a"></a><!-- doxytag: member="viennamath::make_interval" ref="aa5214063f27699f986ea90286e4ad66a" args="(ct_function_symbol&lt; TAG &gt; const &amp;lhs, ct_variable&lt; id &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt;<a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt;TAG&gt;, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt;id&gt; &gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_function_symbol&lt; TAG &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an interval from a function symbol and a variable at compiletime. </p>

</div>
</div>
<a class="anchor" id="a0887f620f606144edc0e696c0754806d"></a><!-- doxytag: member="viennamath::make_interval" ref="a0887f620f606144edc0e696c0754806d" args="(ct_variable&lt; id1 &gt; const &amp;lhs, ct_binary_expr&lt; LHS2, OP2, RHS2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt;<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt;id1&gt;, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;LHS2, OP2, RHS2&gt; &gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_variable&lt; id1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_binary_expr&lt; LHS2, OP2, RHS2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an interval from a variable and a binary expression at compiletime. </p>

</div>
</div>
<a class="anchor" id="a4e994b2dba9f14c3e08e8406e3b0af87"></a><!-- doxytag: member="viennamath::make_interval" ref="a4e994b2dba9f14c3e08e8406e3b0af87" args="(ct_binary_expr&lt; LHS1, OP1, RHS1 &gt; const &amp;lhs, ct_unary_expr&lt; LHS2, OP2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt;<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;LHS1, OP1, RHS1&gt;, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt;LHS2, OP2&gt; &gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; LHS1, OP1, RHS1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_unary_expr&lt; LHS2, OP2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an interval from a binary expression and a unary expression at compiletime. </p>

</div>
</div>
<a class="anchor" id="aaa5b5b3e96adb2435d6fa5c885239366"></a><!-- doxytag: member="viennamath::make_interval" ref="aaa5b5b3e96adb2435d6fa5c885239366" args="(ct_variable&lt; id1 &gt; const &amp;lhs, ct_unary_expr&lt; LHS2, OP2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt;<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt;id1&gt;, <a class="el" href="classviennamath_1_1ct__unary__expr.html">ct_unary_expr</a>&lt;LHS2, OP2&gt; &gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_variable&lt; id1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_unary_expr&lt; LHS2, OP2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an interval from a variable and a unary expression at compiletime. </p>

</div>
</div>
<a class="anchor" id="abc5ab309374f2294b6b2827a1635b7df"></a><!-- doxytag: member="viennamath::make_interval" ref="abc5ab309374f2294b6b2827a1635b7df" args="(ct_variable&lt; id1 &gt; const &amp;lhs, ct_constant&lt; value2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt;<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt;id1&gt;, <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;value2&gt; &gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_variable&lt; id1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_constant&lt; value2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an interval from a variable and a constant at compiletime. </p>

</div>
</div>
<a class="anchor" id="ab1313b9bdf123efb43e0652e415b7e8a"></a><!-- doxytag: member="viennamath::make_interval" ref="ab1313b9bdf123efb43e0652e415b7e8a" args="(rt_binary_expr&lt; InterfaceType &gt; const &amp;lhs, RHSType const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__interval.html">rt_interval</a>&lt;InterfaceType&gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">rt_binary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHSType const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an interval, where the lower bound is given by a ViennaMath runtime binary expression. </p>

</div>
</div>
<a class="anchor" id="ac4b17fdd9afd30257fd8cbd4cee2d89a"></a><!-- doxytag: member="viennamath::make_interval" ref="ac4b17fdd9afd30257fd8cbd4cee2d89a" args="(ct_variable&lt; id1 &gt; const &amp;lhs, ct_function_symbol&lt; TAG &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt;<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt;id1&gt;, <a class="el" href="classviennamath_1_1ct__function__symbol.html">ct_function_symbol</a>&lt;TAG&gt; &gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_variable&lt; id1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_function_symbol&lt; TAG &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an interval from a variable and a function symbol at compiletime. </p>

</div>
</div>
<a class="anchor" id="ade43afd6088321160d1aea7a3d784baa"></a><!-- doxytag: member="viennamath::make_interval" ref="ade43afd6088321160d1aea7a3d784baa" args="(ct_variable&lt; id1 &gt; const &amp;lhs, ct_variable&lt; id2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt;<a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt;id1&gt;, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt;id2&gt; &gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_variable&lt; id1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_variable&lt; id2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an interval from two variables at compiletime. </p>

</div>
</div>
<a class="anchor" id="a9767bae21e77482491a62a4889c993a5"></a><!-- doxytag: member="viennamath::make_interval" ref="a9767bae21e77482491a62a4889c993a5" args="(ct_binary_expr&lt; LHS1, OP1, RHS1 &gt; const &amp;lhs, ct_binary_expr&lt; LHS2, OP2, RHS2 &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__interval.html">ct_interval</a>&lt;<a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;LHS1, OP1, RHS1&gt;, <a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;LHS2, OP2, RHS2&gt; &gt; viennamath::make_interval </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; LHS1, OP1, RHS1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_binary_expr&lt; LHS2, OP2, RHS2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generates an interval from two binary expressions at compiletime. </p>

</div>
</div>
<a class="anchor" id="a02acd683350b951fef8f2c7f98ddddb3"></a><!-- doxytag: member="viennamath::make_vector" ref="a02acd683350b951fef8f2c7f98ddddb3" args="(T0 const &amp;t0, T1 const &amp;t1, T2 const &amp;t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__vector__3.html">ct_vector_3</a>&lt;T0, T1, T2&gt; viennamath::make_vector </td>
          <td>(</td>
          <td class="paramtype">T0 const &amp;&nbsp;</td>
          <td class="paramname"> <em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const &amp;&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function for creating a compiletime vector with three elements. </p>

</div>
</div>
<a class="anchor" id="ae2b922e3910ae182fef18bddb73bd00d"></a><!-- doxytag: member="viennamath::make_vector" ref="ae2b922e3910ae182fef18bddb73bd00d" args="(T0 const &amp;t0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__vector__1.html">ct_vector_1</a>&lt;T0&gt; viennamath::make_vector </td>
          <td>(</td>
          <td class="paramtype">T0 const &amp;&nbsp;</td>
          <td class="paramname"> <em>t0</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function for creating a compiletime vector with one element. </p>

</div>
</div>
<a class="anchor" id="af8bf92dc3f6734771ae97d808947451e"></a><!-- doxytag: member="viennamath::make_vector" ref="af8bf92dc3f6734771ae97d808947451e" args="(T0 const &amp;t0, T1 const &amp;t1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__vector__2.html">ct_vector_2</a>&lt;T0, T1&gt; viennamath::make_vector </td>
          <td>(</td>
          <td class="paramtype">T0 const &amp;&nbsp;</td>
          <td class="paramname"> <em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const &amp;&nbsp;</td>
          <td class="paramname"> <em>t1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function for creating a compiletime vector with two elements. </p>

</div>
</div>
<a class="anchor" id="ab051ef2d7bfda3f3decc17d7d8e8309c"></a><!-- doxytag: member="viennamath::operator*" ref="ab051ef2d7bfda3f3decc17d7d8e8309c" args="(rt_expr&lt; InterfaceType &gt; const &amp;lhs, rt_function_symbol&lt; InterfaceType &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt;InterfaceType&gt; viennamath::operator* </td>
          <td>(</td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_function_symbol&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload for the multiplication of a function symbol with a ViennaMath runtime expression wrapper. </p>

</div>
</div>
<a class="anchor" id="a6e0454dd8f9c2b2e199348db10ac802d"></a><!-- doxytag: member="viennamath::operator*" ref="a6e0454dd8f9c2b2e199348db10ac802d" args="(rt_vector_expr&lt; InterfaceType &gt; const &amp;lhs, T const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__vector__expr.html">rt_vector_expr</a>&lt;InterfaceType&gt; viennamath::operator* </td>
          <td>(</td>
          <td class="paramtype">rt_vector_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a58e542ef6cbfd4726528a48c6f288efa"></a><!-- doxytag: member="viennamath::operator*" ref="a58e542ef6cbfd4726528a48c6f288efa" args="(T const &amp;lhs, rt_vector_expr&lt; InterfaceType &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__vector__expr.html">rt_vector_expr</a>&lt;InterfaceType&gt; viennamath::operator* </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_vector_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa092de3a8ed2a81de68824c0aa66218f"></a><!-- doxytag: member="viennamath::operator*" ref="aa092de3a8ed2a81de68824c0aa66218f" args="(rt_vector_expr&lt; InterfaceType &gt; const &amp;lhs, rt_vector_expr&lt; InterfaceType &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::operator* </td>
          <td>(</td>
          <td class="paramtype">rt_vector_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_vector_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a456766f51c85687bb300c754e5db6d67"></a><!-- doxytag: member="viennamath::operator*" ref="a456766f51c85687bb300c754e5db6d67" args="(LHS const &amp;lhs, RHS const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennamath_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structviennamath_1_1result__of_1_1is__viennamath.html">result_of::is_viennamath</a>&lt;LHS&gt;::value || <a class="el" href="structviennamath_1_1result__of_1_1is__viennamath.html">result_of::is_viennamath</a>&lt;RHS&gt;::value, typename <a class="el" href="structviennamath_1_1result__of_1_1mult.html">result_of::mult</a>&lt;LHS, RHS&gt;::type &gt;::type viennamath::operator* </td>
          <td>(</td>
          <td class="paramtype">LHS const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic overload of the multiplication operator for ViennaMath types. Uses SFINAE to control the scope, otherwise one may run into very tricky problems with operator* being considered outside the viennamath namespace. </p>

</div>
</div>
<a class="anchor" id="ac7c9e972f9e31e0f4c489d07d524b6e2"></a><!-- doxytag: member="viennamath::operator*" ref="ac7c9e972f9e31e0f4c489d07d524b6e2" args="(rt_constant&lt; NumericT, InterfaceType &gt; const &amp;lhs, rt_function_symbol&lt; InterfaceType &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__binary__expr.html">rt_binary_expr</a>&lt;InterfaceType&gt; viennamath::operator* </td>
          <td>(</td>
          <td class="paramtype">rt_constant&lt; NumericT, InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_function_symbol&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload for the multiplication of a function symbol with a ViennaMath runtime constant. </p>

</div>
</div>
<a class="anchor" id="a5c9e697377a7c6ce26c3315c9169ea01"></a><!-- doxytag: member="viennamath::operator*" ref="a5c9e697377a7c6ce26c3315c9169ea01" args="(ct_constant&lt; value &gt; const &amp;lhs, ct_constant&lt; other_value &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;value * other_value&gt; viennamath::operator* </td>
          <td>(</td>
          <td class="paramtype">ct_constant&lt; value &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_constant&lt; other_value &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload: Condense multiplication of two compiletime constants into one constant. </p>

</div>
</div>
<a class="anchor" id="a5133241f93f36e119c3c7f432a0e8be0"></a><!-- doxytag: member="viennamath::operator+" ref="a5133241f93f36e119c3c7f432a0e8be0" args="(ct_binary_expr&lt; rt_constant&lt; OtherScalarType &gt;, op_minus&lt; ScalarType &gt;, RHS &gt; const &amp;lhs, ct_constant&lt; value &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt;typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a>&lt;OtherScalarType, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt;ScalarType&gt;, long&gt;::result_type &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt;ScalarType&gt;, RHS &gt; viennamath::operator+ </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; rt_constant&lt; OtherScalarType &gt;, op_minus&lt; ScalarType &gt;, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_constant&lt; value &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload: (c1 - X) + ct_c2 -&gt; [c1 + ct_c2] - X, where ct_c1 and ct_c2 are compiletime constants and X is any other expression. </p>

</div>
</div>
<a class="anchor" id="aa1a9be719914d3c45c4ad75494fccbdb"></a><!-- doxytag: member="viennamath::operator+" ref="aa1a9be719914d3c45c4ad75494fccbdb" args="(ct_constant&lt; value &gt; const &amp;lhs, ct_binary_expr&lt; rt_constant&lt; ScalarType &gt;, op_plus&lt; default_numeric_type &gt;, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a>&lt;long, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt;<a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>&gt;, ScalarType&gt;::result_type &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt;<a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>&gt;, RHS &gt; viennamath::operator+ </td>
          <td>(</td>
          <td class="paramtype">ct_constant&lt; value &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_binary_expr&lt; rt_constant&lt; ScalarType &gt;, op_plus&lt; default_numeric_type &gt;, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload: ct_c1 + (c2 + X) -&gt; [ct_c1 + c2] + X, where ct_c1 is a compiletime constant, c2 is a runtime constant, and X is any other expression. </p>

</div>
</div>
<a class="anchor" id="a7d16242e99d0cdd196f815ab8c14774d"></a><!-- doxytag: member="viennamath::operator+" ref="a7d16242e99d0cdd196f815ab8c14774d" args="(ct_constant&lt; value &gt; const &amp;lhs, ct_constant&lt; other_value &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;value + other_value&gt; viennamath::operator+ </td>
          <td>(</td>
          <td class="paramtype">ct_constant&lt; value &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_constant&lt; other_value &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload: Condense addition of two compiletime constants into one constant. </p>

</div>
</div>
<a class="anchor" id="ad472832eddd8bcffc0a37837eab7a276"></a><!-- doxytag: member="viennamath::operator+" ref="ad472832eddd8bcffc0a37837eab7a276" args="(ct_binary_expr&lt; ct_constant&lt; value &gt;, op_plus&lt; T &gt;, RHS &gt; const &amp;lhs, rt_constant&lt; ScalarType, InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt;typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a>&lt;long, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt;T&gt;, ScalarType&gt;::result_type &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt;T&gt;, RHS &gt; viennamath::operator+ </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; ct_constant&lt; value &gt;, op_plus&lt; T &gt;, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_constant&lt; ScalarType, InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload for (ct_c1 + X) + c2 -&gt; [ct_c1 + c2] + X, where ct_c1 is a compile constant, c2 is a runtime constant, and X is any expression: </p>

</div>
</div>
<a class="anchor" id="add657c99d615c1990fefcdf268e60295"></a><!-- doxytag: member="viennamath::operator+" ref="add657c99d615c1990fefcdf268e60295" args="(ct_binary_expr&lt; ct_constant&lt; value &gt;, op_minus&lt; default_numeric_type &gt;, RHS &gt; const &amp;lhs, rt_constant&lt; ScalarType, InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt;<a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>, InterfaceType &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt;<a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>&gt;, RHS &gt; viennamath::operator+ </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; ct_constant&lt; value &gt;, op_minus&lt; default_numeric_type &gt;, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_constant&lt; ScalarType, InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload for (ct_c1 - X) + c2 -&gt; [ct_c1 + c2] - X, where ct_c1 is a compile constant, c2 is a runtime constant, and X is any expression: </p>

</div>
</div>
<a class="anchor" id="a96ec78d34ab84218d7e718c210115796"></a><!-- doxytag: member="viennamath::operator+" ref="a96ec78d34ab84218d7e718c210115796" args="(ct_binary_expr&lt; ct_constant&lt; value_1 &gt;, op_plus&lt; ScalarType &gt;, RHS &gt; const &amp;lhs, ct_constant&lt; value_2 &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value_1 + value_2 &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt;ScalarType&gt;, RHS &gt; viennamath::operator+ </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; ct_constant&lt; value_1 &gt;, op_plus&lt; ScalarType &gt;, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_constant&lt; value_2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload: (ct_c1 + X) + ct_c2 becomes [ct_c1 + ct_c2] + X, where ct_c1 and ct_c2 are compiletime constants and X is any other expression. </p>

</div>
</div>
<a class="anchor" id="a4fe9e5b9767699300dd46af21db100af"></a><!-- doxytag: member="viennamath::operator+" ref="a4fe9e5b9767699300dd46af21db100af" args="(ct_binary_expr&lt; ct_constant&lt; value_1 &gt;, op_minus&lt; ScalarType &gt;, RHS &gt; const &amp;lhs, ct_constant&lt; value_2 &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value_1 + value_2 &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt;ScalarType&gt;, RHS &gt; viennamath::operator+ </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; ct_constant&lt; value_1 &gt;, op_minus&lt; ScalarType &gt;, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_constant&lt; value_2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload: (ct_c1 - X) + ct_c2 becomes [ct_c1 + ct_c2] - X, where ct_c1 and ct_c2 are compiletime constants and X is any other expression. </p>

</div>
</div>
<a class="anchor" id="a315e9e2f2528b1c1080d836976f50b16"></a><!-- doxytag: member="viennamath::operator+" ref="a315e9e2f2528b1c1080d836976f50b16" args="(rt_constant&lt; ScalarType, InterfaceType &gt; const &amp;lhs, ct_binary_expr&lt; ct_constant&lt; value &gt;, op_plus&lt; typename InterfaceType::numeric_type &gt;, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt;typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a>&lt;ScalarType, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt;typename InterfaceType::numeric_type&gt;, long&gt;::result_type, InterfaceType &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt;typename InterfaceType::numeric_type&gt;, RHS &gt; viennamath::operator+ </td>
          <td>(</td>
          <td class="paramtype">rt_constant&lt; ScalarType, InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_binary_expr&lt; ct_constant&lt; value &gt;, op_plus&lt; typename InterfaceType::numeric_type &gt;, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload for c1 + (ct_c2 + X) -&gt; [c1 + ct_c2] + X, where c1 is a runtime constant, ct_c2 is a compiletime constant, and X is any expression: </p>

</div>
</div>
<a class="anchor" id="afc8b0467c2889c5a24ec9a3a053e0951"></a><!-- doxytag: member="viennamath::operator+" ref="afc8b0467c2889c5a24ec9a3a053e0951" args="(ct_variable&lt; id &gt; const &amp;lhs, ct_variable&lt; id &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;2&gt;, <a class="el" href="structviennamath_1_1op__mult.html">op_mult</a>&lt;<a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>&gt;, <a class="el" href="structviennamath_1_1ct__variable.html">ct_variable</a>&lt;id&gt; &gt; viennamath::operator+ </td>
          <td>(</td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload: x + x becomes 2*x. </p>

</div>
</div>
<a class="anchor" id="a0d05916e7b1421b8b75969d6b11d1a4f"></a><!-- doxytag: member="viennamath::operator+" ref="a0d05916e7b1421b8b75969d6b11d1a4f" args="(rt_constant&lt; ScalarType, InterfaceType &gt; const &amp;lhs, ct_binary_expr&lt; rt_constant&lt; OtherScalarType, InterfaceType &gt;, op_minus&lt; typename InterfaceType::numeric_type &gt;, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt;typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a>&lt;ScalarType, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt;typename InterfaceType::numeric_type&gt;, OtherScalarType&gt;::result_type, InterfaceType &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt;typename InterfaceType::numeric_type&gt;, RHS &gt; viennamath::operator+ </td>
          <td>(</td>
          <td class="paramtype">rt_constant&lt; ScalarType, InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_binary_expr&lt; rt_constant&lt; OtherScalarType, InterfaceType &gt;, op_minus&lt; typename InterfaceType::numeric_type &gt;, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload for c1 + (c2 - X) -&gt; [c1 + c2] - X, where c1 and c2 are runtime constants and X is any expression: </p>

</div>
</div>
<a class="anchor" id="aaf03494c176b69f6988225edfc9e74be"></a><!-- doxytag: member="viennamath::operator+" ref="aaf03494c176b69f6988225edfc9e74be" args="(LHS const &amp;lhs, RHS const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennamath_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structviennamath_1_1result__of_1_1is__viennamath.html">result_of::is_viennamath</a>&lt;LHS&gt;::value || <a class="el" href="structviennamath_1_1result__of_1_1is__viennamath.html">result_of::is_viennamath</a>&lt;RHS&gt;::value, typename <a class="el" href="structviennamath_1_1result__of_1_1add.html">result_of::add</a>&lt;LHS, RHS&gt;::type &gt;::type viennamath::operator+ </td>
          <td>(</td>
          <td class="paramtype">LHS const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic overload of the addition operator for ViennaMath types. Uses SFINAE to control the scope, otherwise one may run into very tricky problems with operator+ being considered outside the viennamath namespace. </p>

</div>
</div>
<a class="anchor" id="a9e93dd68221d8bb304f8f3014967413b"></a><!-- doxytag: member="viennamath::operator+" ref="a9e93dd68221d8bb304f8f3014967413b" args="(ct_constant&lt; value &gt; const &amp;lhs, ct_binary_expr&lt; ct_constant&lt; value2 &gt;, op_plus&lt; default_numeric_type &gt;, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;value + value2&gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt;<a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>&gt;, RHS &gt; viennamath::operator+ </td>
          <td>(</td>
          <td class="paramtype">ct_constant&lt; value &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_binary_expr&lt; ct_constant&lt; value2 &gt;, op_plus&lt; default_numeric_type &gt;, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload: ct_c1 + (ct_c2 + X) -&gt; [ct_c1 + ct_c2] + X, where ct_c1 and ct_c2 are compiletime constants and X is any other expression. </p>

</div>
</div>
<a class="anchor" id="af12a4b1127521b1b28888fcc62f563c4"></a><!-- doxytag: member="viennamath::operator+" ref="af12a4b1127521b1b28888fcc62f563c4" args="(ct_constant&lt; value &gt; const &amp;lhs, ct_binary_expr&lt; ct_constant&lt; value2 &gt;, op_minus&lt; default_numeric_type &gt;, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;value + value2&gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt;<a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>&gt;, RHS &gt; viennamath::operator+ </td>
          <td>(</td>
          <td class="paramtype">ct_constant&lt; value &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_binary_expr&lt; ct_constant&lt; value2 &gt;, op_minus&lt; default_numeric_type &gt;, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload: ct_c1 + (ct_c2 - X) -&gt; [ct_c1 + ct_c2] - X, where ct_c1 and ct_c2 are compiletime constants and X is any other expression. </p>

</div>
</div>
<a class="anchor" id="a0cd0fcfe3109122f026b7e84b1d9d4f1"></a><!-- doxytag: member="viennamath::operator+" ref="a0cd0fcfe3109122f026b7e84b1d9d4f1" args="(rt_constant&lt; ScalarType, InterfaceType &gt; const &amp;lhs, ct_binary_expr&lt; ct_constant&lt; value &gt;, op_minus&lt; typename InterfaceType::numeric_type &gt;, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt;typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a>&lt;ScalarType, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt;typename InterfaceType::numeric_type&gt;, long&gt;::result_type, InterfaceType &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt;typename InterfaceType::numeric_type&gt;, RHS &gt; viennamath::operator+ </td>
          <td>(</td>
          <td class="paramtype">rt_constant&lt; ScalarType, InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_binary_expr&lt; ct_constant&lt; value &gt;, op_minus&lt; typename InterfaceType::numeric_type &gt;, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload for c1 + (ct_c2 - X) -&gt; [c1 + ct_c2] - X, where c1 is a runtime constant, ct_c2 is a compiletime constant, and X is any expression: </p>

</div>
</div>
<a class="anchor" id="a80a3bf98d0ca82ed116230c1545d13ba"></a><!-- doxytag: member="viennamath::operator+" ref="a80a3bf98d0ca82ed116230c1545d13ba" args="(rt_constant&lt; ScalarType, InterfaceType &gt; const &amp;lhs, ct_binary_expr&lt; rt_constant&lt; OtherScalarType, InterfaceType &gt;, op_plus&lt; typename InterfaceType::numeric_type &gt;, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt;typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a>&lt;ScalarType, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt;typename InterfaceType::numeric_type&gt;, OtherScalarType&gt;::result_type, InterfaceType &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt;typename InterfaceType::numeric_type&gt;, RHS &gt; viennamath::operator+ </td>
          <td>(</td>
          <td class="paramtype">rt_constant&lt; ScalarType, InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_binary_expr&lt; rt_constant&lt; OtherScalarType, InterfaceType &gt;, op_plus&lt; typename InterfaceType::numeric_type &gt;, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload for c1 + (c2 + X) -&gt; [c1 + c2] + X, where c1 and c2 are runtime constants and X is any expression: </p>

</div>
</div>
<a class="anchor" id="a775b8f96ff955d3c807cd0815cdfa430"></a><!-- doxytag: member="viennamath::operator+" ref="a775b8f96ff955d3c807cd0815cdfa430" args="(ct_constant&lt; value &gt; const &amp;lhs, ct_binary_expr&lt; rt_constant&lt; ScalarType &gt;, op_minus&lt; default_numeric_type &gt;, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a>&lt;long, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt;<a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>&gt;, ScalarType&gt;::result_type &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt;<a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>&gt;, RHS &gt; viennamath::operator+ </td>
          <td>(</td>
          <td class="paramtype">ct_constant&lt; value &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_binary_expr&lt; rt_constant&lt; ScalarType &gt;, op_minus&lt; default_numeric_type &gt;, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload: ct_c1 + (c2 - X) -&gt; [ct_c1 + c2] - X, where ct_c1 is a compiletime constant, c2 is a runtime constant, and X is any other expression. </p>

</div>
</div>
<a class="anchor" id="a3ab61f0e93572689c8fb25c084175fda"></a><!-- doxytag: member="viennamath::operator&#45;" ref="a3ab61f0e93572689c8fb25c084175fda" args="(ct_binary_expr&lt; rt_constant&lt; OtherScalarType &gt;, op_plus&lt; T &gt;, RHS &gt; const &amp;lhs, ct_constant&lt; value &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt;typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a>&lt;OtherScalarType, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt;T&gt;, long&gt;::result_type &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt;T&gt;, RHS &gt; viennamath::operator- </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; rt_constant&lt; OtherScalarType &gt;, op_plus&lt; T &gt;, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_constant&lt; value &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload: (c1 + X) - ct_c2 -&gt; [c1 - ct_c2] + X, where ct_c1 and ct_c2 are compiletime constants and X is any other expression. </p>

</div>
</div>
<a class="anchor" id="ac7c6039c3198189205edf97c72213679"></a><!-- doxytag: member="viennamath::operator&#45;" ref="ac7c6039c3198189205edf97c72213679" args="(ct_constant&lt; value &gt; const &amp;lhs, ct_binary_expr&lt; ct_constant&lt; value2 &gt;, op_minus&lt; default_numeric_type &gt;, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;value - value2&gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt;<a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>&gt;, RHS &gt; viennamath::operator- </td>
          <td>(</td>
          <td class="paramtype">ct_constant&lt; value &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_binary_expr&lt; ct_constant&lt; value2 &gt;, op_minus&lt; default_numeric_type &gt;, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload: ct_c1 - (ct_c2 - X) -&gt; [ct_c1 - ct_c2] + X, where ct_c1 and ct_c2 are compiletime constants and X is any other expression. </p>

</div>
</div>
<a class="anchor" id="a9a96021e72d094dd7dc25f90cf26ed1b"></a><!-- doxytag: member="viennamath::operator&#45;" ref="a9a96021e72d094dd7dc25f90cf26ed1b" args="(ct_constant&lt; value &gt; const &amp;lhs, ct_constant&lt; other_value &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;value - other_value&gt; viennamath::operator- </td>
          <td>(</td>
          <td class="paramtype">ct_constant&lt; value &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_constant&lt; other_value &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload: Condense subtraction of two compiletime constants into one constant. </p>

</div>
</div>
<a class="anchor" id="ad2c13bd71fc10f21715aed3e06d77e12"></a><!-- doxytag: member="viennamath::operator&#45;" ref="ad2c13bd71fc10f21715aed3e06d77e12" args="(rt_constant&lt; ScalarType, InterfaceType &gt; const &amp;lhs, ct_binary_expr&lt; ct_constant&lt; value &gt;, op_plus&lt; typename InterfaceType::numeric_type &gt;, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt;typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a>&lt;ScalarType, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt;typename InterfaceType::numeric_type&gt;, long&gt;::result_type, InterfaceType &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt;typename InterfaceType::numeric_type&gt;, RHS &gt; viennamath::operator- </td>
          <td>(</td>
          <td class="paramtype">rt_constant&lt; ScalarType, InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_binary_expr&lt; ct_constant&lt; value &gt;, op_plus&lt; typename InterfaceType::numeric_type &gt;, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload for c1 - (ct_c2 + X) -&gt; [c1 - ct_c2] - X, where c1 is a runtime constant, ct_c2 is a compiletime constant, and X is any expression: </p>

</div>
</div>
<a class="anchor" id="a124bc79e9ab4caa6b3a81429991811e9"></a><!-- doxytag: member="viennamath::operator&#45;" ref="a124bc79e9ab4caa6b3a81429991811e9" args="(rt_constant&lt; ScalarType, InterfaceType &gt; const &amp;lhs, ct_binary_expr&lt; rt_constant&lt; OtherScalarType, InterfaceType &gt;, op_minus&lt; typename InterfaceType::numeric_type &gt;, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt;typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a>&lt;ScalarType, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt;typename InterfaceType::numeric_type&gt;, OtherScalarType&gt;::result_type, InterfaceType &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt;typename InterfaceType::numeric_type&gt;, RHS &gt; viennamath::operator- </td>
          <td>(</td>
          <td class="paramtype">rt_constant&lt; ScalarType, InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_binary_expr&lt; rt_constant&lt; OtherScalarType, InterfaceType &gt;, op_minus&lt; typename InterfaceType::numeric_type &gt;, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload for c1 - (c2 - X) -&gt; [c1 - c2] + X, where c1 and c2 are runtime constants and X is any expression: </p>

</div>
</div>
<a class="anchor" id="ae3af7f10cb1c8816c1f6912e55a9eed0"></a><!-- doxytag: member="viennamath::operator&#45;" ref="ae3af7f10cb1c8816c1f6912e55a9eed0" args="(ct_binary_expr&lt; rt_constant&lt; OtherScalarType &gt;, op_minus&lt; T &gt;, RHS &gt; const &amp;lhs, ct_constant&lt; value &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt;typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a>&lt;OtherScalarType, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt;T&gt;, long&gt;::result_type &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt;T&gt;, RHS &gt; viennamath::operator- </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; rt_constant&lt; OtherScalarType &gt;, op_minus&lt; T &gt;, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_constant&lt; value &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload: (c1 - X) - ct_c2 -&gt; [c1 - ct_c2] - X, where ct_c1 and ct_c2 are compiletime constants and X is any other expression. </p>

</div>
</div>
<a class="anchor" id="ae13e94bfe9efecfa85d1c7c7cdc92fbe"></a><!-- doxytag: member="viennamath::operator&#45;" ref="ae13e94bfe9efecfa85d1c7c7cdc92fbe" args="(ct_variable&lt; id &gt; const &amp;lhs, ct_variable&lt; id &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;0&gt; viennamath::operator- </td>
          <td>(</td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload: x - x becomes 0. </p>

</div>
</div>
<a class="anchor" id="abc5bac5399fd74594c55f8a65d89b8c4"></a><!-- doxytag: member="viennamath::operator&#45;" ref="abc5bac5399fd74594c55f8a65d89b8c4" args="(LHS const &amp;lhs, RHS const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennamath_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structviennamath_1_1result__of_1_1is__viennamath.html">result_of::is_viennamath</a>&lt;LHS&gt;::value || <a class="el" href="structviennamath_1_1result__of_1_1is__viennamath.html">result_of::is_viennamath</a>&lt;RHS&gt;::value, typename <a class="el" href="structviennamath_1_1result__of_1_1subtract.html">result_of::subtract</a>&lt;LHS, RHS&gt;::type &gt;::type viennamath::operator- </td>
          <td>(</td>
          <td class="paramtype">LHS const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic overload of the subtraction operator for ViennaMath types. Uses SFINAE to control the scope, otherwise one may run into very tricky problems with operator- being considered outside the viennamath namespace. </p>

</div>
</div>
<a class="anchor" id="a8cc0d2be89063b81b38f671dc6458250"></a><!-- doxytag: member="viennamath::operator&#45;" ref="a8cc0d2be89063b81b38f671dc6458250" args="(ct_constant&lt; value &gt; const &amp;lhs, ct_binary_expr&lt; ct_constant&lt; value2 &gt;, op_plus&lt; default_numeric_type &gt;, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;<a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;value - value2&gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt;<a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>&gt;, RHS &gt; viennamath::operator- </td>
          <td>(</td>
          <td class="paramtype">ct_constant&lt; value &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_binary_expr&lt; ct_constant&lt; value2 &gt;, op_plus&lt; default_numeric_type &gt;, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload: ct_c1 - (ct_c2 + X) -&gt; [ct_c1 - ct_c2] - X, where ct_c1 and ct_c2 are compiletime constants and X is any other expression. </p>

</div>
</div>
<a class="anchor" id="a385f10e49b1375a6085b1c4e8b73cbc7"></a><!-- doxytag: member="viennamath::operator&#45;" ref="a385f10e49b1375a6085b1c4e8b73cbc7" args="(ct_constant&lt; value &gt; const &amp;lhs, ct_binary_expr&lt; rt_constant&lt; ScalarType &gt;, op_minus&lt; default_numeric_type &gt;, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a>&lt;long, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt;<a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>&gt;, ScalarType&gt;::result_type &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt;<a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>&gt;, RHS &gt; viennamath::operator- </td>
          <td>(</td>
          <td class="paramtype">ct_constant&lt; value &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_binary_expr&lt; rt_constant&lt; ScalarType &gt;, op_minus&lt; default_numeric_type &gt;, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload: ct_c1 - (c2 - X) -&gt; [ct_c1 - c2] + X, where ct_c1 is a compiletime constant, c2 is a runtime constant, and X is any other expression. </p>

</div>
</div>
<a class="anchor" id="ac765c3d235c5bc88544b3b3931ed8ef8"></a><!-- doxytag: member="viennamath::operator&#45;" ref="ac765c3d235c5bc88544b3b3931ed8ef8" args="(ct_binary_expr&lt; ct_constant&lt; value_1 &gt;, op_plus&lt; T &gt;, RHS &gt; const &amp;lhs, ct_constant&lt; value_2 &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value_1 - value_2 &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt;T&gt;, RHS &gt; viennamath::operator- </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; ct_constant&lt; value_1 &gt;, op_plus&lt; T &gt;, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_constant&lt; value_2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload: (ct_c1 + X) - ct_c2 -&gt; [ct_c1 - ct_c2] + X, where ct_c1 and ct_c2 are compiletime constants and X is any other expression. </p>

</div>
</div>
<a class="anchor" id="a21cfb8382ef091ea00128c6958ec3333"></a><!-- doxytag: member="viennamath::operator&#45;" ref="a21cfb8382ef091ea00128c6958ec3333" args="(rt_constant&lt; ScalarType, InterfaceType &gt; const &amp;lhs, ct_binary_expr&lt; ct_constant&lt; value &gt;, op_minus&lt; typename InterfaceType::numeric_type &gt;, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt;typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a>&lt;ScalarType, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt;typename InterfaceType::numeric_type&gt;, long&gt;::result_type, InterfaceType &gt;, <a class="el" href="structviennamath_1_1op__plus.html">op_plus</a>&lt;typename InterfaceType::numeric_type&gt;, RHS &gt; viennamath::operator- </td>
          <td>(</td>
          <td class="paramtype">rt_constant&lt; ScalarType, InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_binary_expr&lt; ct_constant&lt; value &gt;, op_minus&lt; typename InterfaceType::numeric_type &gt;, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload for c1 - (ct_c2 - X) -&gt; [c1 - ct_c2] + X, where c1 is a runtime constant, ct_c2 is a compiletime constant, and X is any expression: </p>

</div>
</div>
<a class="anchor" id="a605b04922d052aaf90275295f760b1fa"></a><!-- doxytag: member="viennamath::operator&#45;" ref="a605b04922d052aaf90275295f760b1fa" args="(rt_constant&lt; ScalarType, InterfaceType &gt; const &amp;lhs, ct_binary_expr&lt; rt_constant&lt; OtherScalarType, InterfaceType &gt;, op_plus&lt; typename InterfaceType::numeric_type &gt;, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt;typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a>&lt;ScalarType, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt;typename InterfaceType::numeric_type&gt;, OtherScalarType&gt;::result_type, InterfaceType &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt;typename InterfaceType::numeric_type&gt;, RHS &gt; viennamath::operator- </td>
          <td>(</td>
          <td class="paramtype">rt_constant&lt; ScalarType, InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_binary_expr&lt; rt_constant&lt; OtherScalarType, InterfaceType &gt;, op_plus&lt; typename InterfaceType::numeric_type &gt;, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload for c1 - (c2 + X) -&gt; [c1 - c2] - X, where c1 and c2 are runtime constants and X is any expression: </p>

</div>
</div>
<a class="anchor" id="aee490081c338660d19d0262a234a433d"></a><!-- doxytag: member="viennamath::operator&#45;" ref="aee490081c338660d19d0262a234a433d" args="(ct_constant&lt; value &gt; const &amp;lhs, ct_binary_expr&lt; rt_constant&lt; ScalarType &gt;, op_plus&lt; default_numeric_type &gt;, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt;<a class="el" href="classviennamath_1_1rt__constant.html">rt_constant</a>&lt; typename <a class="el" href="structviennamath_1_1promote__traits.html">promote_traits</a>&lt;long, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt;<a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>&gt;, ScalarType&gt;::result_type &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt;<a class="el" href="namespaceviennamath.html#a97e77ded8737e25ae18d165a33179286">default_numeric_type</a>&gt;, RHS &gt; viennamath::operator- </td>
          <td>(</td>
          <td class="paramtype">ct_constant&lt; value &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_binary_expr&lt; rt_constant&lt; ScalarType &gt;, op_plus&lt; default_numeric_type &gt;, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload: ct_c1 - (c2 + X) -&gt; [ct_c1 - c2] - X, where ct_c1 is a compiletime constant, c2 is a runtime constant, and X is any other expression. </p>

</div>
</div>
<a class="anchor" id="a05d342780bb2a0ee78f53ae4a53e3995"></a><!-- doxytag: member="viennamath::operator&#45;" ref="a05d342780bb2a0ee78f53ae4a53e3995" args="(ct_binary_expr&lt; ct_variable&lt; id &gt;, op_plus&lt; ScalarType &gt;, RHS &gt; const &amp;lhs, ct_variable&lt; id &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RHS viennamath::operator- </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; ct_variable&lt; id &gt;, op_plus&lt; ScalarType &gt;, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload: (A + B) - A -&gt; B, where A is an variable and X can be anything. </p>

</div>
</div>
<a class="anchor" id="a79934ad09196a21b4185519cca650fe3"></a><!-- doxytag: member="viennamath::operator&#45;" ref="a79934ad09196a21b4185519cca650fe3" args="(ct_binary_expr&lt; ct_constant&lt; value_1 &gt;, op_minus&lt; T &gt;, RHS &gt; const &amp;lhs, ct_constant&lt; value_2 &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__binary__expr.html">ct_binary_expr</a>&lt; <a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt; value_1 - value_2 &gt;, <a class="el" href="structviennamath_1_1op__minus.html">op_minus</a>&lt;T&gt;, RHS &gt; viennamath::operator- </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; ct_constant&lt; value_1 &gt;, op_minus&lt; T &gt;, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_constant&lt; value_2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload: (ct_c1 - X) - ct_c2 -&gt; [ct_c1 - ct_c2] - X, where ct_c1 and ct_c2 are compiletime constants and X is any other expression. </p>

</div>
</div>
<a class="anchor" id="ab387a8c9fc10cb75a804df8b1640440a"></a><!-- doxytag: member="viennamath::operator/" ref="ab387a8c9fc10cb75a804df8b1640440a" args="(ct_binary_expr&lt; LHS, OP, RHS &gt; const &amp;lhs, ct_binary_expr&lt; LHS, OP, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;1&gt; viennamath::operator/ </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; LHS, OP, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_binary_expr&lt; LHS, OP, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload: division of the same thing leads to '1'. </p>

</div>
</div>
<a class="anchor" id="a59f2a2bb6054ab3ead3aaa6c4ca0dcd4"></a><!-- doxytag: member="viennamath::operator/" ref="a59f2a2bb6054ab3ead3aaa6c4ca0dcd4" args="(ct_variable&lt; id &gt; const &amp;lhs, ct_variable&lt; id &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1ct__constant.html">ct_constant</a>&lt;1&gt; viennamath::operator/ </td>
          <td>(</td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Special overload: x / x becomes 1. </p>

</div>
</div>
<a class="anchor" id="aa3ab0fb522083f3a037467af4b19ef6f"></a><!-- doxytag: member="viennamath::operator/" ref="aa3ab0fb522083f3a037467af4b19ef6f" args="(LHS const &amp;lhs, RHS const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennamath_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structviennamath_1_1result__of_1_1is__viennamath.html">result_of::is_viennamath</a>&lt;LHS&gt;::value || <a class="el" href="structviennamath_1_1result__of_1_1is__viennamath.html">result_of::is_viennamath</a>&lt;RHS&gt;::value, typename <a class="el" href="structviennamath_1_1result__of_1_1div.html">result_of::div</a>&lt;LHS, RHS&gt;::type &gt;::type viennamath::operator/ </td>
          <td>(</td>
          <td class="paramtype">LHS const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHS const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic overload of the division operator for ViennaMath types. Uses SFINAE to control the scope, otherwise one may run into very tricky problems with operator/ being considered outside the viennamath namespace. </p>

</div>
</div>
<a class="anchor" id="a369e52002e304b528ca2747e9ff2479b"></a><!-- doxytag: member="viennamath::operator/" ref="a369e52002e304b528ca2747e9ff2479b" args="(rt_vector_expr&lt; InterfaceType &gt; const &amp;lhs, T const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__vector__expr.html">rt_vector_expr</a>&lt;InterfaceType&gt; viennamath::operator/ </td>
          <td>(</td>
          <td class="paramtype">rt_vector_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a94a6ec97828479323cc13bcc0b7c4301"></a><!-- doxytag: member="viennamath::operator/" ref="a94a6ec97828479323cc13bcc0b7c4301" args="(T const &amp;lhs, rt_vector_expr&lt; InterfaceType &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__vector__expr.html">rt_vector_expr</a>&lt;InterfaceType&gt; viennamath::operator/ </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_vector_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a61156a6761913f9bd3e9d6b446df23b0"></a><!-- doxytag: member="viennamath::operator&lt;&lt;" ref="a61156a6761913f9bd3e9d6b446df23b0" args="(std::ostream &amp;stream, rt_variable&lt; InterfaceType &gt; const &amp;u)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennamath::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_variable&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output stream overload, mostly used for printing an expression to screen. </p>

</div>
</div>
<a class="anchor" id="a029796c0197fb289d90d1dba41d5ac2b"></a><!-- doxytag: member="viennamath::operator&lt;&lt;" ref="a029796c0197fb289d90d1dba41d5ac2b" args="(std::ostream &amp;stream, rt_function_symbol&lt; InterfaceType &gt; const &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennamath::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_function_symbol&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0f94e753da1d69943f9cb75e37f2a1ae"></a><!-- doxytag: member="viennamath::operator&lt;&lt;" ref="a0f94e753da1d69943f9cb75e37f2a1ae" args="(std::ostream &amp;stream, rt_constant&lt; ScalarType, InterfaceType &gt; const &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennamath::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_constant&lt; ScalarType, InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience operator overload for streaming a runtime constant to std::cout or any other STL-compatible output stream. </p>

</div>
</div>
<a class="anchor" id="aa5422111f525aa1fb878585842de12fc"></a><!-- doxytag: member="viennamath::operator&lt;&lt;" ref="aa5422111f525aa1fb878585842de12fc" args="(std::ostream &amp;stream, rt_vector_expr&lt; InterfaceType &gt; const &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennamath::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_vector_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a25a9a9662614fb7b641e7a4f1e08a32a"></a><!-- doxytag: member="viennamath::operator&lt;&lt;" ref="a25a9a9662614fb7b641e7a4f1e08a32a" args="(std::ostream &amp;stream, rt_symbolic_interval&lt; InterfaceType &gt; const &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennamath::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_symbolic_interval&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience overload for obtaining a string representation of a symbolic interval. </p>

</div>
</div>
<a class="anchor" id="a131e77c1c72b390bd576740bd3ddb744"></a><!-- doxytag: member="viennamath::operator&lt;&lt;" ref="a131e77c1c72b390bd576740bd3ddb744" args="(std::ostream &amp;stream, ct_equation&lt; LHS, RHS &gt; const &amp;u)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennamath::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_equation&lt; LHS, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience overload for printing a compiletime equation to an output stream. </p>

</div>
</div>
<a class="anchor" id="a72f88f5abbd2b1f61c3f10498604fe85"></a><!-- doxytag: member="viennamath::operator&lt;&lt;" ref="a72f88f5abbd2b1f61c3f10498604fe85" args="(std::ostream &amp;stream, rt_unary_expr&lt; InterfaceType &gt; const &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennamath::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_unary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the stream operator in order to allow for a convenient conversion of a unary expression to a string. </p>

</div>
</div>
<a class="anchor" id="acbac35d965d2d596c91a0d29ed659616"></a><!-- doxytag: member="viennamath::operator&lt;&lt;" ref="acbac35d965d2d596c91a0d29ed659616" args="(std::ostream &amp;stream, rt_expr&lt; InterfaceType &gt; const &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennamath::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a671d30cfe31003c33e5552a77d351318"></a><!-- doxytag: member="viennamath::operator&lt;&lt;" ref="a671d30cfe31003c33e5552a77d351318" args="(std::ostream &amp;stream, rt_interval&lt; InterfaceType &gt; const &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennamath::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_interval&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience overload for streaming an interval to an output stream. </p>

</div>
</div>
<a class="anchor" id="aa03dffe4e96434bab3268451aa2f9180"></a><!-- doxytag: member="viennamath::operator&lt;&lt;" ref="aa03dffe4e96434bab3268451aa2f9180" args="(std::ostream &amp;stream, ct_vector_2&lt; T0, T1 &gt; const &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennamath::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_vector_2&lt; T0, T1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience functionality for printing a compiletime vector with two entries to an output stream. </p>

</div>
</div>
<a class="anchor" id="a4a65fb56be14e23ca213f8d6806ae287"></a><!-- doxytag: member="viennamath::operator&lt;&lt;" ref="a4a65fb56be14e23ca213f8d6806ae287" args="(std::ostream &amp;stream, ct_function_symbol&lt; Tag &gt; const &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennamath::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_function_symbol&lt; Tag &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience overload for printing a compiletime function symbol to an output stream. </p>

</div>
</div>
<a class="anchor" id="a2b93076569cd52d663262e1f6f2a272f"></a><!-- doxytag: member="viennamath::operator&lt;&lt;" ref="a2b93076569cd52d663262e1f6f2a272f" args="(std::ostream &amp;stream, rt_binary_expr&lt; InterfaceType &gt; const &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennamath::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_binary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the stream operator in order to allow for a convenient conversion of a unary expression to a string. </p>

</div>
</div>
<a class="anchor" id="a4ad290f04051ef6fd8dc907265ecbae0"></a><!-- doxytag: member="viennamath::operator&lt;&lt;" ref="a4ad290f04051ef6fd8dc907265ecbae0" args="(std::ostream &amp;stream, rt_equation&lt; InterfaceType &gt; const &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennamath::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_equation&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience operator overload for streaming a runtime equation to std::cout or any other STL-compatible output stream. </p>

</div>
</div>
<a class="anchor" id="a403ecd7be88e92a2ccfc901e82c81a73"></a><!-- doxytag: member="viennamath::operator&lt;&lt;" ref="a403ecd7be88e92a2ccfc901e82c81a73" args="(std::ostream &amp;stream, ct_interval&lt; LHS, RHS &gt; const &amp;u)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennamath::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_interval&lt; LHS, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience overload for printing a compiletime interval to an output stream. </p>

</div>
</div>
<a class="anchor" id="a2f3d57f39b39e62c1137df0d1ed41bd0"></a><!-- doxytag: member="viennamath::operator&lt;&lt;" ref="a2f3d57f39b39e62c1137df0d1ed41bd0" args="(std::ostream &amp;stream, ct_constant&lt; value_ &gt; const &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennamath::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_constant&lt; value_ &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience overload for printing a compiletime constant to an output stream. </p>

</div>
</div>
<a class="anchor" id="a87236971206e8eef4a0d6506cc8a4050"></a><!-- doxytag: member="viennamath::operator&lt;&lt;" ref="a87236971206e8eef4a0d6506cc8a4050" args="(std::ostream &amp;stream, ct_unary_expr&lt; LHS, OP &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennamath::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_unary_expr&lt; LHS, OP &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience overload for printing a compiletime unary expression to an output stream. </p>

</div>
</div>
<a class="anchor" id="a3e4801b3e30bf59480a7031dc668b590"></a><!-- doxytag: member="viennamath::operator&lt;&lt;" ref="a3e4801b3e30bf59480a7031dc668b590" args="(std::ostream &amp;stream, ct_variable&lt; id &gt; const &amp;u)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennamath::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience overload for printing a variable to an output stream. </p>

</div>
</div>
<a class="anchor" id="aa5038fa5139aeecdaeae19bb50817cbc"></a><!-- doxytag: member="viennamath::operator&lt;&lt;" ref="aa5038fa5139aeecdaeae19bb50817cbc" args="(std::ostream &amp;stream, ct_vector_1&lt; T0 &gt; const &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennamath::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_vector_1&lt; T0 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience functionality for printing a compiletime vector with one entry to an output stream. </p>

</div>
</div>
<a class="anchor" id="a9bffff51daca9b5beabf23ea9d28e53d"></a><!-- doxytag: member="viennamath::operator&lt;&lt;" ref="a9bffff51daca9b5beabf23ea9d28e53d" args="(std::ostream &amp;stream, ct_vector_3&lt; T0, T1, T2 &gt; const &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennamath::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_vector_3&lt; T0, T1, T2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience functionality for printing a compiletime vector with three entries to an output stream. </p>

</div>
</div>
<a class="anchor" id="a6718c3868b4e8d87b724e88366c38b0c"></a><!-- doxytag: member="viennamath::operator&lt;&lt;" ref="a6718c3868b4e8d87b724e88366c38b0c" args="(std::ostream &amp;stream, ct_binary_expr&lt; LHS, OP, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; viennamath::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ct_binary_expr&lt; LHS, OP, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience overload for printing a compiletime binary expression to an output stream. </p>

</div>
</div>
<a class="anchor" id="a099a3472ee309f0a7f3856ea53b4c224"></a><!-- doxytag: member="viennamath::simplify" ref="a099a3472ee309f0a7f3856ea53b4c224" args="(ExpressionType const &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennamath_1_1result__of_1_1simplify.html">result_of::simplify</a>&lt;ExpressionType&gt;::type viennamath::simplify </td>
          <td>(</td>
          <td class="paramtype">ExpressionType const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The generic interface function for compiletime manipulations. </p>

</div>
</div>
<a class="anchor" id="a7f0a16889b15a3820baff9d6d8e4e4b8"></a><!-- doxytag: member="viennamath::simplify" ref="a7f0a16889b15a3820baff9d6d8e4e4b8" args="(rt_expr&lt; InterfaceType &gt; const &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::simplify </td>
          <td>(</td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a new, simplified expression. </p>

</div>
</div>
<a class="anchor" id="af9cdf0307fb2394e9e3aafec045f46fb"></a><!-- doxytag: member="viennamath::simplify" ref="af9cdf0307fb2394e9e3aafec045f46fb" args="(rt_binary_expr&lt; InterfaceType &gt; const &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::simplify </td>
          <td>(</td>
          <td class="paramtype">rt_binary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a new, simplified expression. </p>

</div>
</div>
<a class="anchor" id="a03aca40c921022b15f1a9f7848111e3b"></a><!-- doxytag: member="viennamath::simplify" ref="a03aca40c921022b15f1a9f7848111e3b" args="(T const &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T viennamath::simplify </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a new, simplified expression. </p>

</div>
</div>
<a class="anchor" id="a1117bd43873542d12cbcd9e4519577e0"></a><!-- doxytag: member="viennamath::simplify" ref="a1117bd43873542d12cbcd9e4519577e0" args="(rt_unary_expr&lt; InterfaceType &gt; const &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::simplify </td>
          <td>(</td>
          <td class="paramtype">rt_unary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a new, simplified expression. </p>

</div>
</div>
<a class="anchor" id="a1c8fb4e0cbecf7705f1a79e21b083962"></a><!-- doxytag: member="viennamath::simplify_impl" ref="a1c8fb4e0cbecf7705f1a79e21b083962" args="(const InterfaceType *lhs, op_div&lt; NumericT &gt;, const InterfaceType *rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType * simplify_impl </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">op_div&lt; NumericT &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the simplification procedures for an expression of the form e1 / e2. </p>

</div>
</div>
<a class="anchor" id="a43db4c7b01bb93d7ef27715437d47ee2"></a><!-- doxytag: member="viennamath::simplify_impl" ref="a43db4c7b01bb93d7ef27715437d47ee2" args="(const InterfaceType *lhs, op_plus&lt; NumericT &gt;, const InterfaceType *rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType * simplify_impl </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">op_plus&lt; NumericT &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the simplification procedures for an expression of the form e1 + e2. </p>

</div>
</div>
<a class="anchor" id="afc140581a47526c8806588e89ba9170c"></a><!-- doxytag: member="viennamath::simplify_impl" ref="afc140581a47526c8806588e89ba9170c" args="(const InterfaceType *lhs, op_minus&lt; NumericT &gt;, const InterfaceType *rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType * simplify_impl </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">op_minus&lt; NumericT &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the simplification procedures for an expression of the form e1 - e2. </p>

</div>
</div>
<a class="anchor" id="a0242029fb878937caab203ca397848c2"></a><!-- doxytag: member="viennamath::simplify_impl" ref="a0242029fb878937caab203ca397848c2" args="(const InterfaceType *lhs, op_mult&lt; NumericT &gt;, const InterfaceType *rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterfaceType * simplify_impl </td>
          <td>(</td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">op_mult&lt; NumericT &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InterfaceType *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation of the simplification procedures for an expression of the form e1 * e2. </p>

</div>
</div>
<a class="anchor" id="a87a291b8cd5e8810deb3aa173a6e31c7"></a><!-- doxytag: member="viennamath::sin" ref="a87a291b8cd5e8810deb3aa173a6e31c7" args="(rt_expr&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::sin </td>
          <td>(</td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the sine function for a ViennaMath runtime expression wrapper. </p>

</div>
</div>
<a class="anchor" id="ae4fd81949da2c40ee2d5a0078460e177"></a><!-- doxytag: member="viennamath::sin" ref="ae4fd81949da2c40ee2d5a0078460e177" args="(ct_variable&lt; id &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> viennamath::sin </td>
          <td>(</td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the sine function for a ViennaMath compiletime variable. </p>

</div>
</div>
<a class="anchor" id="ad9542d9a32538308ca47867384f0001e"></a><!-- doxytag: member="viennamath::sin" ref="ad9542d9a32538308ca47867384f0001e" args="(rt_unary_expr&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::sin </td>
          <td>(</td>
          <td class="paramtype">rt_unary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the sine function for a ViennaMath runtime unary expression. </p>

</div>
</div>
<a class="anchor" id="a01828a35cd515c72e5631c690cc9d661"></a><!-- doxytag: member="viennamath::sin" ref="a01828a35cd515c72e5631c690cc9d661" args="(rt_binary_expr&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::sin </td>
          <td>(</td>
          <td class="paramtype">rt_binary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the sine function for a ViennaMath runtime binary expression. </p>

</div>
</div>
<a class="anchor" id="adb139682031d58c74f3251482c912a65"></a><!-- doxytag: member="viennamath::sin" ref="adb139682031d58c74f3251482c912a65" args="(rt_constant&lt; NumericT, InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::sin </td>
          <td>(</td>
          <td class="paramtype">rt_constant&lt; NumericT, InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the sine function for a ViennaMath runtime constant. </p>

</div>
</div>
<a class="anchor" id="a063eb151d24c03cf9179918b5c312af4"></a><!-- doxytag: member="viennamath::sin" ref="a063eb151d24c03cf9179918b5c312af4" args="(ct_binary_expr&lt; LHS, OP, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> viennamath::sin </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; LHS, OP, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the sine function for a ViennaMath compiletime binary expression. </p>

</div>
</div>
<a class="anchor" id="a0e90789fe641f5b4a081e56b08fc9291"></a><!-- doxytag: member="viennamath::sin" ref="a0e90789fe641f5b4a081e56b08fc9291" args="(rt_variable&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::sin </td>
          <td>(</td>
          <td class="paramtype">rt_variable&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the sine function for a ViennaMath runtime variable. </p>

</div>
</div>
<a class="anchor" id="a6e7edbb3417d17155fe81a296aac16ee"></a><!-- doxytag: member="viennamath::sin" ref="a6e7edbb3417d17155fe81a296aac16ee" args="(ct_unary_expr&lt; LHS, OP &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> viennamath::sin </td>
          <td>(</td>
          <td class="paramtype">ct_unary_expr&lt; LHS, OP &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the sine function for a ViennaMath compiletime unary expression. </p>

</div>
</div>
<a class="anchor" id="a7a77c13989060743c6446ce7253d08f7"></a><!-- doxytag: member="viennamath::sqrt" ref="a7a77c13989060743c6446ce7253d08f7" args="(ct_variable&lt; id &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> viennamath::sqrt </td>
          <td>(</td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the square-root function for a ViennaMath compiletime variable. </p>

</div>
</div>
<a class="anchor" id="a133ebc258c5eb5062eed77b6b872e784"></a><!-- doxytag: member="viennamath::sqrt" ref="a133ebc258c5eb5062eed77b6b872e784" args="(rt_unary_expr&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::sqrt </td>
          <td>(</td>
          <td class="paramtype">rt_unary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the square-root function for a ViennaMath runtime unary expression. </p>

</div>
</div>
<a class="anchor" id="a169cd852af6f99d1fafc6a02f872a69e"></a><!-- doxytag: member="viennamath::sqrt" ref="a169cd852af6f99d1fafc6a02f872a69e" args="(rt_variable&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::sqrt </td>
          <td>(</td>
          <td class="paramtype">rt_variable&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the square-root function for a ViennaMath runtime variable. </p>

</div>
</div>
<a class="anchor" id="a30f229ea98616d7ef9f0497564119b84"></a><!-- doxytag: member="viennamath::sqrt" ref="a30f229ea98616d7ef9f0497564119b84" args="(rt_binary_expr&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::sqrt </td>
          <td>(</td>
          <td class="paramtype">rt_binary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the square-root function for a ViennaMath runtime binary expression. </p>

</div>
</div>
<a class="anchor" id="a36e1fb9ed0568a4913278d3456a28a37"></a><!-- doxytag: member="viennamath::sqrt" ref="a36e1fb9ed0568a4913278d3456a28a37" args="(ct_binary_expr&lt; LHS, OP, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> viennamath::sqrt </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; LHS, OP, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the square-root function for a ViennaMath compiletime binary expression. </p>

</div>
</div>
<a class="anchor" id="a5ae7b8f5fb1d62a122860950bd34838e"></a><!-- doxytag: member="viennamath::sqrt" ref="a5ae7b8f5fb1d62a122860950bd34838e" args="(rt_expr&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::sqrt </td>
          <td>(</td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the square-root function for a ViennaMath runtime expression wrapper. </p>

</div>
</div>
<a class="anchor" id="abfaab8e3dea4888fe01c6bd8e125431a"></a><!-- doxytag: member="viennamath::sqrt" ref="abfaab8e3dea4888fe01c6bd8e125431a" args="(rt_constant&lt; NumericT, InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::sqrt </td>
          <td>(</td>
          <td class="paramtype">rt_constant&lt; NumericT, InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the square-root function for a ViennaMath runtime constant. </p>

</div>
</div>
<a class="anchor" id="a465666c605b600b20acc607b4754abf8"></a><!-- doxytag: member="viennamath::sqrt" ref="a465666c605b600b20acc607b4754abf8" args="(ct_unary_expr&lt; LHS, OP &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> viennamath::sqrt </td>
          <td>(</td>
          <td class="paramtype">ct_unary_expr&lt; LHS, OP &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the square-root function for a ViennaMath compiletime unary expression. </p>

</div>
</div>
<a class="anchor" id="af6c27a8c577b4d1a3a43160eee378a90"></a><!-- doxytag: member="viennamath::substitute" ref="af6c27a8c577b4d1a3a43160eee378a90" args="(rt_variable&lt; InterfaceType &gt; const &amp;u, default_numeric_type repl, rt_expr&lt; InterfaceType &gt; const &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::substitute </td>
          <td>(</td>
          <td class="paramtype">rt_variable&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">default_numeric_type&nbsp;</td>
          <td class="paramname"> <em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces all occurances of the variable 'u' in the expression 'e' with 'repl'. </p>

</div>
</div>
<a class="anchor" id="a3558dd9b9b06dd97f0593c90055bcd82"></a><!-- doxytag: member="viennamath::substitute" ref="a3558dd9b9b06dd97f0593c90055bcd82" args="(rt_unary_expr&lt; InterfaceType &gt; const &amp;search, rt_expr&lt; InterfaceType &gt; const &amp;repl, rt_expr&lt; InterfaceType &gt; const &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::substitute </td>
          <td>(</td>
          <td class="paramtype">rt_unary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces all occurances of the unary expression 'search' in the expression 'e' with 'repl'. </p>

</div>
</div>
<a class="anchor" id="a62df9bea306cfe3e5df84601d41e5afa"></a><!-- doxytag: member="viennamath::substitute" ref="a62df9bea306cfe3e5df84601d41e5afa" args="(rt_function_symbol&lt; InterfaceType &gt; const &amp;u, rt_expr&lt; InterfaceType &gt; const &amp;repl, rt_expr&lt; InterfaceType &gt; const &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::substitute </td>
          <td>(</td>
          <td class="paramtype">rt_function_symbol&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces all occurances of the function symbol 'u' in the expression 'e' with 'repl'. </p>

</div>
</div>
<a class="anchor" id="a175715df224eeeaca505554906516230"></a><!-- doxytag: member="viennamath::substitute" ref="a175715df224eeeaca505554906516230" args="(SearchType const &amp;, ReplacementType const &amp;, ExpressionType const &amp;ex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structviennamath_1_1result__of_1_1substitute.html">result_of::substitute</a>&lt; SearchType, ReplacementType, ExpressionType&gt;::type viennamath::substitute </td>
          <td>(</td>
          <td class="paramtype">SearchType const &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReplacementType const &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExpressionType const &amp;&nbsp;</td>
          <td class="paramname"> <em>ex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The generic interface function for compiletime substitution. </p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>SearchType</em>&nbsp;</td><td>Type of the expression to be substituted </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ReplacementType</em>&nbsp;</td><td>Type of the expression used as replacement </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ExpressionType</em>&nbsp;</td><td>Type of the expression in which the substitution is carried out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa31d186e422de5b063d30a189107257c"></a><!-- doxytag: member="viennamath::substitute" ref="aa31d186e422de5b063d30a189107257c" args="(rt_symbolic_interval&lt; InterfaceType &gt; const &amp;search, PairType const &amp;repl, rt_expr&lt; InterfaceType &gt; const &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::substitute </td>
          <td>(</td>
          <td class="paramtype">rt_symbolic_interval&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PairType const &amp;&nbsp;</td>
          <td class="paramname"> <em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Substitutes a symbolic interval with a concrete interval. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>search</em>&nbsp;</td><td>The symbolic interval to be replaced </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>repl</em>&nbsp;</td><td>A pair consisting of the integration interval and the integration variable. Must be interface compatible with std::pair&lt;&gt;. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>e</em>&nbsp;</td><td>The expression on which the substitution is carried out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aebf95ab660141cea0a1657e9d3ca29d7"></a><!-- doxytag: member="viennamath::substitute" ref="aebf95ab660141cea0a1657e9d3ca29d7" args="(rt_variable&lt; InterfaceType &gt; const &amp;u, ReplacementType const &amp;repl, ExpressionType const &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::substitute </td>
          <td>(</td>
          <td class="paramtype">rt_variable&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReplacementType const &amp;&nbsp;</td>
          <td class="paramname"> <em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExpressionType const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces all occurances of the variable 'u' in the expression 'e' with 'repl'. </p>

</div>
</div>
<a class="anchor" id="aa5add5eb3186740a97c9d02e9530b30e"></a><!-- doxytag: member="viennamath::substitute" ref="aa5add5eb3186740a97c9d02e9530b30e" args="(rt_variable&lt; InterfaceType &gt; const &amp;u, ReplacementType const &amp;repl, rt_expr&lt; InterfaceType &gt; const &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::substitute </td>
          <td>(</td>
          <td class="paramtype">rt_variable&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReplacementType const &amp;&nbsp;</td>
          <td class="paramname"> <em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces all occurances of the variable 'u' in the expression 'e' with 'repl'. </p>

</div>
</div>
<a class="anchor" id="ac9ee50377d9c6ac19e3e06cc07e40a91"></a><!-- doxytag: member="viennamath::substitute" ref="ac9ee50377d9c6ac19e3e06cc07e40a91" args="(std::vector&lt; rt_expr&lt; InterfaceType &gt; &gt; const &amp;search, std::vector&lt; rt_expr&lt; InterfaceType &gt; &gt; const &amp;repl, rt_expr&lt; InterfaceType &gt; const &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::substitute </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; rt_expr&lt; InterfaceType &gt; &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; rt_expr&lt; InterfaceType &gt; &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces all occurances of the the expressions in 'search' in the expression 'e' with the corresponding expressions in 'repl'. </p>

</div>
</div>
<a class="anchor" id="a7615a8e86229b78c6839dd562a7d5d65"></a><!-- doxytag: member="viennamath::substitute" ref="a7615a8e86229b78c6839dd562a7d5d65" args="(rt_unary_expr&lt; InterfaceType &gt; const &amp;search, ReplacementType const &amp;repl, rt_expr&lt; InterfaceType &gt; const &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::substitute </td>
          <td>(</td>
          <td class="paramtype">rt_unary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReplacementType const &amp;&nbsp;</td>
          <td class="paramname"> <em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces all occurances of the unary expression 'search' in the expression 'e' with 'repl'. </p>

</div>
</div>
<a class="anchor" id="a14a37e585c04587cbdd2b5bae45810f6"></a><!-- doxytag: member="viennamath::substitute" ref="a14a37e585c04587cbdd2b5bae45810f6" args="(rt_binary_expr&lt; InterfaceType &gt; const &amp;search, ReplacementType const &amp;repl, rt_expr&lt; InterfaceType &gt; const &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::substitute </td>
          <td>(</td>
          <td class="paramtype">rt_binary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReplacementType const &amp;&nbsp;</td>
          <td class="paramname"> <em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces all occurances of the binary expression 'search' in the expression 'e' with 'repl'. </p>

</div>
</div>
<a class="anchor" id="aa757a4af65d821d7023707a3308f20d4"></a><!-- doxytag: member="viennamath::substitute" ref="aa757a4af65d821d7023707a3308f20d4" args="(rt_function_symbol&lt; InterfaceType &gt; const &amp;u, default_numeric_type repl, rt_expr&lt; InterfaceType &gt; const &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::substitute </td>
          <td>(</td>
          <td class="paramtype">rt_function_symbol&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">default_numeric_type&nbsp;</td>
          <td class="paramname"> <em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces all occurances of the function symbol 'u' in the expression 'e' with 'repl'. </p>

</div>
</div>
<a class="anchor" id="a62faa5f9c1dfff907b94060b54211a7f"></a><!-- doxytag: member="viennamath::substitute" ref="a62faa5f9c1dfff907b94060b54211a7f" args="(rt_expr&lt; InterfaceType &gt; const &amp;search, rt_expr&lt; InterfaceType &gt; const &amp;repl, rt_expr&lt; InterfaceType &gt; const &amp;e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__expr.html">rt_expr</a>&lt;InterfaceType&gt; viennamath::substitute </td>
          <td>(</td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces all occurances of the expression 'search' in the expression 'e' with 'repl'. </p>

</div>
</div>
<a class="anchor" id="ad8126ebb56c187caf6a1ba56914a70e8"></a><!-- doxytag: member="viennamath::tan" ref="ad8126ebb56c187caf6a1ba56914a70e8" args="(rt_binary_expr&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::tan </td>
          <td>(</td>
          <td class="paramtype">rt_binary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the tangent function for a ViennaMath runtime binary expression. </p>

</div>
</div>
<a class="anchor" id="ad62dadb75a7676cdb66e793783e27da5"></a><!-- doxytag: member="viennamath::tan" ref="ad62dadb75a7676cdb66e793783e27da5" args="(rt_unary_expr&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::tan </td>
          <td>(</td>
          <td class="paramtype">rt_unary_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the tangent function for a ViennaMath runtime unary expression. </p>

</div>
</div>
<a class="anchor" id="a6466850318e6dcc1a0997af207ccde57"></a><!-- doxytag: member="viennamath::tan" ref="a6466850318e6dcc1a0997af207ccde57" args="(rt_constant&lt; NumericT, InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::tan </td>
          <td>(</td>
          <td class="paramtype">rt_constant&lt; NumericT, InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the tangent function for a ViennaMath runtime constant. </p>

</div>
</div>
<a class="anchor" id="a71505792183df693d76ff36342e9ac09"></a><!-- doxytag: member="viennamath::tan" ref="a71505792183df693d76ff36342e9ac09" args="(rt_expr&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::tan </td>
          <td>(</td>
          <td class="paramtype">rt_expr&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the tangent function for a ViennaMath runtime expression wrapper. </p>

</div>
</div>
<a class="anchor" id="a8b481f3d63879c2978f03653e6153d37"></a><!-- doxytag: member="viennamath::tan" ref="a8b481f3d63879c2978f03653e6153d37" args="(rt_variable&lt; InterfaceType &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a>&lt;InterfaceType&gt; viennamath::tan </td>
          <td>(</td>
          <td class="paramtype">rt_variable&lt; InterfaceType &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the tangent function for a ViennaMath runtime variable. </p>

</div>
</div>
<a class="anchor" id="a12c45b179f539b54bf24141d4c10ad37"></a><!-- doxytag: member="viennamath::tan" ref="a12c45b179f539b54bf24141d4c10ad37" args="(ct_unary_expr&lt; LHS, OP &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> viennamath::tan </td>
          <td>(</td>
          <td class="paramtype">ct_unary_expr&lt; LHS, OP &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the tangent function for a ViennaMath compiletime unary expression. </p>

</div>
</div>
<a class="anchor" id="ac8bd49e99dc88986d1fc3273c0e36fc2"></a><!-- doxytag: member="viennamath::tan" ref="ac8bd49e99dc88986d1fc3273c0e36fc2" args="(ct_variable&lt; id &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> viennamath::tan </td>
          <td>(</td>
          <td class="paramtype">ct_variable&lt; id &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the tangent function for a ViennaMath compiletime variable. </p>

</div>
</div>
<a class="anchor" id="a6dad9a86aa4baf42aa2458dc87643c61"></a><!-- doxytag: member="viennamath::tan" ref="a6dad9a86aa4baf42aa2458dc87643c61" args="(ct_binary_expr&lt; LHS, OP, RHS &gt; const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classviennamath_1_1rt__unary__expr.html">rt_unary_expr</a> viennamath::tan </td>
          <td>(</td>
          <td class="paramtype">ct_binary_expr&lt; LHS, OP, RHS &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overload of the tangent function for a ViennaMath compiletime binary expression. </p>

</div>
</div>
<a class="anchor" id="a161236234f212240c8946721f8366562"></a><!-- doxytag: member="viennamath::unary_op_equal" ref="a161236234f212240c8946721f8366562" args="(T const &amp;lhs, T const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool viennamath::unary_op_equal </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper function returning true if the two arguments are of the same type. </p>

</div>
</div>
<a class="anchor" id="a53b7241560fc9d3020efcbe0a70a16f6"></a><!-- doxytag: member="viennamath::unary_op_equal" ref="a53b7241560fc9d3020efcbe0a70a16f6" args="(op_partial_deriv&lt; T &gt; const &amp;lhs, op_partial_deriv&lt; T &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool viennamath::unary_op_equal </td>
          <td>(</td>
          <td class="paramtype">op_partial_deriv&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">op_partial_deriv&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compares two partial derivatives for equality with respect to the differentiation variable. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Feb 29 2012 21:50:44 for ViennaMath by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
